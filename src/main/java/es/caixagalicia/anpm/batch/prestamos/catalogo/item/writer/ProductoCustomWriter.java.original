package es.caixagalicia.anpm.batch.prestamos.catalogo.item.writer;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.commons.lang.CharEncoding;
import org.apache.commons.lang.StringUtils;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemStream;
import org.springframework.batch.item.ItemStreamException;
import org.springframework.util.Assert;

import es.caixagalicia.anpm.batch.prestamos.catalogo.item.Constantes;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.DefaultItem;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.DetalleItem;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.ProductoItem;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.SubProductoItem;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.to.DefaultTO;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.to.GenericosTO;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.to.ProductoTO;
import es.caixagalicia.anpm.batch.prestamos.catalogo.item.domain.to.SubProductoTO;
import es.caixagalicia.anpm.batch.prestamos.comun.Util;
import es.caixagalicia.ifrt.batch.context.ContextConfiguracion;
import es.caixagalicia.ifrt.batch.ficheros.CGFileResource;
import es.caixagalicia.ifrt.batch.writer.ICGItemWriter;
import es.caixagalicia.ifrt.log.LogHelper;


public class ProductoCustomWriter implements ICGItemWriter<DefaultItem>, ItemStream
{

	
	private static LogHelper logger = LogHelper.getLog(ProductoCustomWriter.class);
	
	private CGFileResource resource;
	private BufferedWriter bw;
	
	private Util util;
	

	
	
	/*
	 * (non-Javadoc)
	 * @see org.springframework.batch.item.ItemStream#close()
	 */
	public void close() throws ItemStreamException
	{
		try
		{
			if (bw!= null)
				bw.close();
		}
		catch(IOException e)
		{
			throw new ItemStreamException(
				"Could not close buffered writer", e);
		}
		
	}

	
	/*
	 * (non-Javadoc)
	 * @see org.springframework.batch.item.ItemStream#open(org.springframework.batch.item.ExecutionContext)
	 */
	public void open(ExecutionContext arg0) throws ItemStreamException
	{

		File file;
		try
		{
			file = resource.getFile();
			//FileWriter fw = new FileWriter(file);
			//bw = new BufferedWriter(fw);
			bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(resource.getPath()), CharEncoding.ISO_8859_1));
			
		}
		catch (IOException e)
		{
			throw new ItemStreamException(
					"Could not convert resource to file: [" + resource + "]", e);
		}
		Assert.state(!file.exists() || file.canWrite(),
				"Resource is not writable: [" + resource + "]");
		

	}

	
	/*
	 * (non-Javadoc)
	 * @see org.springframework.batch.item.ItemStream#update(org.springframework.batch.item.ExecutionContext)
	 */
	public void update(ExecutionContext arg0) throws ItemStreamException
	{
		
		try
		{
			if (bw != null)
				bw.flush();
		}
		catch(IOException e)
		{
			throw new ItemStreamException(
					"Could not flush buffered writer", e);			
		}
		
	}

	
	/*
	 * (non-Javadoc)
	 * @see es.caixagalicia.ifrt.batch.writer.ICGItemWriter#write(java.util.List)
	 */
	public void write(List < ? extends DefaultItem> items)
	{
		
		ProductoItem item = null;
		for(int i=0; i<items.size(); i++)
		{
			item = (ProductoItem) items.get(i);
			
			this.doAggregate(item);		
			
			// Nueva linea despues de procesar cada item
			//try
			//{
			//	bw.newLine();
			//}
			//catch (IOException e)
			//{
			//	// TODO Auto-generated catch block
			//	e.printStackTrace();
			//	logger.debug(e.getMessage());
			//}
		}
		
	}
	
	
	
	/**
	 * Metodo que añade al fichero de salida el detalle de producto y el detalle de
	 * los subproductos (si los tiene)
	 * 
	 * @param productoItem item para el cual se van a añadir tanto el detalle de 
	 *                     producto como el de subproductos
	 */
	private void doAggregate(ProductoItem productoItem)
	{
				
		// Agregar detalle de producto (si lo tiene)
		this.agregarDetalle(productoItem.getCodProducto(), 
				productoItem.getDetalle(), Constantes.TIPO_PRODUCTO_AGRUPADOR);
		
		
		// Agregar detalle de subproductos (si lo tiene)
		if(productoItem.getSubProductos() != null && 
				productoItem.getSubProductos().size() > 0)
		{
			for(SubProductoItem subProductoItem : productoItem.getSubProductos())
			{
				this.agregarDetalle(subProductoItem.getCodSubProducto(),
						subProductoItem.getDetalle(), Constantes.TIPO_PRODUCTO_COMERCIALIZABLE);
			}
		}
		
	}


	/**
	 * Metodo que añade al fichero de salida el detalle indicado en el item de detalle
	 * recibido (DetalleItem). Este item de detalle contiene datos de comisiones, 
	 * datos economicos, producto/subproducto, etc.
	 * 
	 * @param codProducto codigo de producto del que se va a añadir el detalle
	 * @param detalle item que representa el detalle del producto
	 * @param tipo indica si el producto es un agrupador (se agregaran datos de 
	 *             producto) o un comercializable (se agregaran datos de 
	 *             subproducto)
	 */
	private void agregarDetalle(String codProducto, DetalleItem detalle, String tipo)
	{
		
		if(detalle != null)
		{
			
			// Obtener indicadores de informacion a escribir.
			// Se escribe la informacion de todos los indicadores con valor S, blanco o nulo.
			String indGenericos = ContextConfiguracion.getInstance()
					.getStringJobParameter(Constantes.JOB_PARAMETER_GENERICOS);

			String indProducto = ContextConfiguracion.getInstance()
					.getStringJobParameter(Constantes.JOB_PARAMETER_PRODUCTO);

			String indClausulasRestringidas = ContextConfiguracion
					.getInstance().getStringJobParameter(
							Constantes.JOB_PARAMETER_CLAUSULAS_RESTRINGIDAS);

			String indComisiones = ContextConfiguracion.getInstance()
					.getStringJobParameter(Constantes.JOB_PARAMETER_COMISIONES);

			String indCondicionesCapital = ContextConfiguracion.getInstance()
					.getStringJobParameter(
							Constantes.JOB_PARAMETER_CONDICIONES_CAPITAL);

			String indDatosEconomicos = ContextConfiguracion.getInstance()
					.getStringJobParameter(
							Constantes.JOB_PARAMETER_DATOS_ECONOMICOS);

			String indDiferencialesTechosSuelos = ContextConfiguracion
					.getInstance()
					.getStringJobParameter(
							Constantes.JOB_PARAMETER_DIFERENCIALES_TECHOS_SUELOS);

			String indIntereses = ContextConfiguracion.getInstance()
					.getStringJobParameter(Constantes.JOB_PARAMETER_INTERESES);

			String indModalidadesAmortizacion = ContextConfiguracion
					.getInstance().getStringJobParameter(
							Constantes.JOB_PARAMETER_MODALIDADES_AMORTIZACION);

			String indNivelesSubProducto = ContextConfiguracion.getInstance()
					.getStringJobParameter(
							Constantes.JOB_PARAMETER_NIVELES_SUBPRODUCTO);

			String indRedondeos = ContextConfiguracion.getInstance()
					.getStringJobParameter(Constantes.JOB_PARAMETER_REDONDEOS);

			String indTiposReferencia = ContextConfiguracion.getInstance()
					.getStringJobParameter(
							Constantes.JOB_PARAMETER_TIPOS_REFERENCIA);

			String indTratamientosAdelanto = ContextConfiguracion.getInstance()
					.getStringJobParameter(
							Constantes.JOB_PARAMETER_TRATAMIENTOS_ADELANTO);
			
			
			
			// Agregar datos producto (si tipo = A) o subproducto (si tipo = C)
			if(StringUtils.isBlank(indProducto) || indProducto.equals(Constantes.CTE_SI))
			{
				if(tipo.equals(Constantes.TIPO_PRODUCTO_AGRUPADOR))
				{
					if(detalle.getProducto() != null)
					{
						List<ProductoTO> datosProducto = new ArrayList<ProductoTO>();
						datosProducto.add(detalle.getProducto());
						this.agregarElementos(codProducto, datosProducto);	
					}
				}
						
				if(tipo.equals(Constantes.TIPO_PRODUCTO_COMERCIALIZABLE))
				{
					if(detalle.getSubProducto() != null)
					{
						List<SubProductoTO> datosSubProducto = new ArrayList<SubProductoTO>();
						datosSubProducto.add(detalle.getSubProducto());
						this.agregarElementos(codProducto, datosSubProducto);	
					}
				}
			}
			
			
			// Agregar genericos
			if(StringUtils.isBlank(indGenericos) || indGenericos.equals(Constantes.CTE_SI))
			{
				if(detalle.getGenericos() != null )
				{
					List<GenericosTO> genericos = new ArrayList<GenericosTO>();
					genericos.add(detalle.getGenericos());
					this.agregarElementos(codProducto, genericos);
				}
				
				//agrego los genericos de tipo de expediente
				if(detalle.getGenericosExp() != null && detalle.getGenericosExp().size() > 0) {
					this.agregarElementos(codProducto, detalle.getGenericosExp());
				}
			}
			
			// Agregar comisiones
			if(StringUtils.isBlank(indComisiones) || indComisiones.equals(Constantes.CTE_SI))
			{
				if(detalle.getComisiones() != null && detalle.getComisiones().size() > 0)
					this.agregarElementos(codProducto, detalle.getComisiones());
			}
			
			// Agregar adelantos
			if(StringUtils.isBlank(indTratamientosAdelanto) || indTratamientosAdelanto.equals(Constantes.CTE_SI))
			{
				if(detalle.getTratamientosAdelantos() != null && detalle.getTratamientosAdelantos().size() > 0)
					this.agregarElementos(codProducto, detalle.getTratamientosAdelantos());
			}
	
			// Agregar condiciones de capital
			if(StringUtils.isBlank(indCondicionesCapital) || indCondicionesCapital.equals(Constantes.CTE_SI))
			{
				if(detalle.getCondicionesCapital() != null && detalle.getCondicionesCapital().size() > 0)
					this.agregarElementos(codProducto, detalle.getCondicionesCapital());
			}
			
			// Agregar modalidades de amortizacion
			if(StringUtils.isBlank(indModalidadesAmortizacion) || indModalidadesAmortizacion.equals(Constantes.CTE_SI))
			{
				if(detalle.getModalidadesAmortizacion() != null && detalle.getModalidadesAmortizacion().size() > 0)
					this.agregarElementos(codProducto, detalle.getModalidadesAmortizacion());
			}
				
			// Agregar clausulas restringidas
			if(StringUtils.isBlank(indClausulasRestringidas) || indClausulasRestringidas.equals(Constantes.CTE_SI))
			{
				if(detalle.getClausulasRestringidas() != null && detalle.getClausulasRestringidas().size() > 0)
					this.agregarElementos(codProducto, detalle.getClausulasRestringidas());
			}
			
			// Agregar datos economicos
			if(StringUtils.isBlank(indDatosEconomicos) || indDatosEconomicos.equals(Constantes.CTE_SI))
			{
				if(detalle.getDatosEconomicos() != null && detalle.getDatosEconomicos().size() > 0)
					this.agregarElementos(codProducto, detalle.getDatosEconomicos());
			}
			
			// Agregar intereses
			if(StringUtils.isBlank(indIntereses) || indIntereses.equals(Constantes.CTE_SI))
			{
				if(detalle.getIntereses() != null && detalle.getIntereses().size() > 0)
					this.agregarElementos(codProducto, detalle.getIntereses());
			}
			
			// Agregar diferenciales
			if(StringUtils.isBlank(indDiferencialesTechosSuelos) || indDiferencialesTechosSuelos.equals(Constantes.CTE_SI))
			{
				if(detalle.getDiferencialesTechoSuelo() != null && detalle.getDiferencialesTechoSuelo().size() > 0)
					this.agregarElementos(codProducto, detalle.getDiferencialesTechoSuelo());
			}
			
			// Agregar redondeos
			if(StringUtils.isBlank(indRedondeos) || indRedondeos.equals(Constantes.CTE_SI))
			{
				if(detalle.getRedondeos() != null && detalle.getRedondeos().size() > 0)
					this.agregarElementos(codProducto, detalle.getRedondeos());
			}
			
			// Agregar tipos de referencia
			if(StringUtils.isBlank(indTiposReferencia) || indTiposReferencia.equals(Constantes.CTE_SI))
			{
				if(detalle.getTiposReferencia() != null && detalle.getTiposReferencia().size() > 0)
					this.agregarElementos(codProducto, detalle.getTiposReferencia());
			}
			
			// Agregar niveles de un subproducto
			if(StringUtils.isBlank(indNivelesSubProducto) || indNivelesSubProducto.equals(Constantes.CTE_SI))
			{
				if(detalle.getNivelesSubProducto() != null && detalle.getNivelesSubProducto().size() > 0)
					this.agregarElementos(codProducto, detalle.getNivelesSubProducto());
			}
			
		}
		
	}
	
	
	/**
	 * Metodo que dada una lista de TOs pertenecientes al detalle de un elemento, agrega al 
	 * fichero de salida cada una de las propiedades de cada uno de los TOs de la lista.
	 * Estos TOs seran comisiones, datos economicos, intereses, diferenciales, etc.
	 * 
	 * @param idSubProducto id del subproducto al que pertenecen los TOs recibidos
	 * @param elementos lista de TOs a añadir al fichero
	 */
	private void agregarElementos(String idSubProducto, List<? extends DefaultTO> elementos)
	{
		
		String out = "";
		
		Integer secuencia = 1;
		
		try
		{
			for (DefaultTO elemento : elementos)
			{
				
				List<Method> getters = this.getGetters(elemento.getClass());
	
				// Cada campo del contexto representa una nueva fila del fichero de valores
				// Cada campo del contexto tendra un metodo get correspondiente --> se 
				// recorren los metodos get para obtener todos los campos y sus valores
				for (Method metodo : getters)
				{
					out="";
					
					
					// Solo se escribe el campo si tiene valor
					Object valor = null;
					String valorStr = "";
	
					try
					{
						valor = metodo.invoke(elemento);
					}
					catch (Throwable e)
					{
						logger.error("Error invocando al metodo " + metodo.getName());
						throw new RuntimeException(e);
					}
					
					if (valor != null)
					{
						valorStr = valor.toString();
					
						// Familia
						out += StringUtils.rightPad(Constantes.FAMILIA,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_1_FAMILIA);
		
						// Codigo producto
						out += StringUtils.rightPad(idSubProducto,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_2_CODIGO_PRODUCTO);
		
						// Codigo valor
						// Eliminar el get y coger el nombre del campo
						String codValor = metodo.getName().substring(3).split("_")[0]; 
						out += StringUtils.rightPad(codValor,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_3_CODIGO_VALOR);
		
						// Canal
						out += StringUtils.rightPad(Constantes.CANAL_DEFAULT,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_4_CANAL);
		
						// Idioma
						out += StringUtils.rightPad(Constantes.IDIOMA_DEFAULT,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_5_IDIOMA);
		
						// Secuencia
						out += StringUtils.rightPad(StringUtils.leftPad(secuencia.toString(), 7, "0"),
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_6_SECUENCIA);
		
						// Operacion
						out += StringUtils.rightPad(Constantes.OPERACION_DEFAULT,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_7_OPERACION);
		
						// Tipo valor
						String tipoValor = this.getTipoValor(metodo, valorStr);
						out += StringUtils.rightPad(tipoValor,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_8_TIPO_VALOR);
		
						// Valor
						//TODO format valor (fecha, numero)
						String valorFormateado = this.formatValor(valorStr, tipoValor);
						out += StringUtils.rightPad(valorFormateado,
								Constantes.FICHERO_VALORES_LONGITUD_CAMPO_9_VALOR);
		
						//out += "\n";
						//escribir a fichero
						bw.write(out);
						bw.newLine();
					}
				}
	
				secuencia++;
	
			}
		}
		catch(IOException e)
		{
			
		}

	}
	
	
	
	/**
	 * Metodo que obtiene la lista de getters de la clase que se le pasa 
	 * por parametro.
	 * 
	 * @param clase clase para la que se obtendra el listado de metodos get
	 * @return lista de metodos get de la clase recibida
	 */
	private List<Method> getGetters(Class clase)
	{
		
		Method[] metodos = clase.getDeclaredMethods();
		List<Method> getters = new ArrayList<Method>();
		
		for(int i=0; i<metodos.length; i++)
		{
			Method metodo = metodos[i];
			
			if(metodo.getName().startsWith("get"))
			{
				getters.add(metodo);
			}		
		}

		return getters;
		
	}
	
	
	/**
	 * Metodo que obtiene el tipo de valor devuelto por el metodo que se le
	 * pasa por parametro. Este tipo puede ser numerico (N), alfanumerico (A)
	 * o fecha (F).
	 * 
	 * @param metodo
	 * @return tipo de valor devuelto por el metodo que se le pasa por parametro
	 */
	private String getTipoValor(Method metodo, String valor)
	{
		Class<?> tipoDevuelto = metodo.getReturnType();
		String tipoValor = Constantes.TipoValor.A.toString(); // Por defecto: alfanumerico
		
		/*20141015 Se añaden trazas para encontrar el problema esporádico de los numéricos*/
		
		logger.debug("TRAZA ANPM_300 en ProductoCustomWriter.getTipoValor() antes de Util.grabarIncidencia()");
		
		
		util.grabarIncidencia("TRAZA ANPM_300 metodo.getName() == ".concat(metodo.getName()));
		util.grabarIncidencia("TRAZA ANPM_300 metodo.getReturnType().getName() == ".concat(tipoDevuelto.getName()));
		
		util.grabarIncidencia("TRAZA ANPM_300 Integer.class.getName() == ".concat(Integer.class.getName()));
		util.grabarIncidencia("TRAZA ANPM_300 BigDecimal.class.getName() == ".concat(BigDecimal.class.getName()));
		
		if (Integer.class.getName().equals(tipoDevuelto.getName()) ||
		   (BigDecimal.class.getName().equals(tipoDevuelto.getName())))
		{
			//util.grabarIncidencia("TRAZA ANPM_300 ENTRA EN if Integer.class.equals(tipoDevuelto) || (BigDecimal.class.equals(tipoDevuelto)");
			util.grabarIncidencia("if Integer.class.getName().equals(tipoDevuelto.getName() || BigDecimal.class.getName().equals(tipoDevuelto.getName()");
			tipoValor = Constantes.TipoValor.N.toString();
		}
				
		if (String.class.equals(tipoDevuelto))
		{
			
			// Formato fecha
			String mascaraFecha = "dd-MM-yyyy";
			
			SimpleDateFormat s1 = new SimpleDateFormat(mascaraFecha);
			try
			{
				s1.parse(valor);
				tipoValor = Constantes.TipoValor.F.toString(); 
			}
			catch(ParseException e)
			{
				// No es una fecha o no tiene el formato adecuado.
				// Se devuelve como alfanumerico
			}
			
		}
		util.grabarIncidencia("TRAZA ANPM_300 tipoValor == ".concat(tipoValor));
		return tipoValor;
	}

	
	/**
	 * Metodo que da formato al valor que se le pasa por parametro, en funcion
	 * del tipo de valor del que se trate:
	 * 
	 *   - Valores tipo N: 21v10 (21 digitos para la parte entera y 10 para la 
	 *     decimal, sin separador entre ambas partes)
	 * 
	 *   - Valores tipo A: no se tratan
	 * 
	 *   - Valores tipo F: los formatos aceptados son dd-MM-yyyy / ddMMyyyy. Si
	 *     el valor de entrada no tiene ninguno de estos formatos, no se procesa
	 * 
	 * @param valor valor al que se le va a dar formato
	 * @param tipoValor tipo del valor a formatear (N, A, F)
	 * @return
	 */
	public String formatValor(String valor, String tipoValor)
	{
		
		String valorFormateado = valor;
		
		// Fecha. Formato entrada: dd-mm-yyyy / formato salida: ddmmyyyy
		if(tipoValor.equals("F"))
		{
			
			String mascaraFechaEntrada = "dd-MM-yyyy";
			String mascaraFechaSalida = "ddMMyyyy";
			
			SimpleDateFormat s1 = new SimpleDateFormat(mascaraFechaEntrada);
			SimpleDateFormat s2 = new SimpleDateFormat(mascaraFechaSalida);
			
			try
			{
				Date f1 = s1.parse(valor);
				valorFormateado = s2.format(f1);
				 
			}
			catch(ParseException e)
			{
				// No es una fecha o no tiene el formato adecuado.
			}				
		}
		

		// Numero. Formato: 21v10 (31 digitos, de los cuales 10 son decimales)		
		if(tipoValor.equals("N"))
		{
	
			String[] partes;
			String parteEntera;
			String parteDecimal;

			// Obtener parte entera y decimal del dato numerico
			if(valor.contains("E"))
			{
				double d = Double.parseDouble(valor);  
				NumberFormat formatter = new DecimalFormat("#####################.##########"); //21.10  

				partes = formatter.format(d).split(",");  
				 
			}
			else
			{
				// Notacion no cientifica (xxxx, xxxx.xxxx)
				partes = valor.split("\\.");	
			}
			
			
			// Obtener valor formateado
			parteEntera = partes[0];
			parteDecimal = "";
			if(partes.length > 1)
				parteDecimal = partes[1];
				
			if(parteEntera.length() > 21)
			{
				valorFormateado = "ERROR - PARTE ENTERA > 21      ";
			}
			else 
			{
				parteEntera = StringUtils.leftPad(parteEntera, 21, "0");
				parteDecimal = StringUtils.rightPad(parteDecimal, 10, "0");

				valorFormateado = parteEntera + parteDecimal;
			}
			
		}
		
		return valorFormateado;			
	}	
	
	
	
	/**
	 * @return the resource
	 */
	public CGFileResource getResource()
	{
		return resource;
	}

	/**
	 * @param resource the resource to set
	 */
	public void setResource(CGFileResource resource)
	{
		this.resource = resource;
	}


	/**
	 * @return the util
	 */
	public final Util getUtil()
	{
		return util;
	}


	/**
	 * @param util the util to set
	 */
	public final void setUtil(Util util)
	{
		this.util = util;
	}


}
