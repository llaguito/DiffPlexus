
/**
 * Asingna un nuevo numero de version a la versión 0 
 * 
 * Transaccion: 
 * Código de operación: ANPM_306
 * 
 */
package es.caixagalicia.anpm.prestamos.sindicados.servicios.fachada;

import java.math.BigDecimal;
import java.sql.Date;
import java.util.List;

import org.apache.commons.lang.StringUtils;






import es.caixagalicia.anpm.prestamos.sindicados.ConstantesSindicados;
import es.caixagalicia.anpm.prestamos.sindicados.SindicadosC;
import es.caixagalicia.anpm.prestamos.sindicados.SindicadosEng;
import es.caixagalicia.anpm.prestamos.sindicados.Utilidades;
import es.caixagalicia.anpm.prestamos.sindicados.persistencia.condeconomicas.CondicionesInteresPactadasC;
import es.caixagalicia.anpm.prestamos.sindicados.persistencia.condeconomicas.CondicionesInteresPactadasEng;
import es.caixagalicia.anpm.prestamos.sindicados.persistencia.tramos.TramoC;
import es.caixagalicia.anpm.prestamos.sindicados.persistencia.tramos.TramoEng;
import es.caixagalicia.anpm.prestamos.sindicados.servicios.aplicacion.GestionSindicados;
import es.caixagalicia.anpm.prestamos.sindicados.servicios.aplicacion.GestionTramos;
import es.caixagalicia.anpm.prestamos.sindicados.servicios.fachada.contexto.ContextoSindicados;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.ResultadoDatosSolicitudVO;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.fechas.DateHelper;
import es.caixagalicia.ifrt.log.LogHelper;

public class FinalizarSolicitudMatrizSrv extends ServicioNegocio{
		

	private static final String CTE_NUC_EXPEDIENTE = "NUC_EXP_MATRIZ";
	
	private SindicadosEng daoMatriz = new SindicadosEng();
	private TramoEng daoTramos = new TramoEng();
	private CondicionesInteresPactadasEng daoCondiciones = new CondicionesInteresPactadasEng();
	
	/**
	 * Log de la clase.
	 */
	private static final LogHelper LOGGER = LogHelper.getLog(FinalizarSolicitudMatrizSrv.class);
	
	
	/**
	 * Constructor sin parametros
	 */
	public FinalizarSolicitudMatrizSrv(){
		super();
	}
	
	public IContexto[] ejecutar(IContextoEjecucion contexto, IDatosEntradaTx datosEntrada){
		
	
		if (LOGGER.isDebugEnabled()){
			LOGGER.debug("INICIO SNANPM306: Finalizar solicitud.");						
		}
		
				
		contexto.setDiarioElectronico(new DiarioElectronico(
				Constantes.CTE_OPERACION_AC,
				Integer.valueOf(0),
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                Constantes.CTE_STRING_EMPTY,
                Constantes.CTE_STRING_EMPTY,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                Integer.valueOf(0)));
		
		if (LOGGER.isDebugEnabled()){
			LOGGER.debug("Obtenemos los parametros de entrada");
		}
		
		// Valores para el contexto de error
		BigDecimal error = BigDecimal.ZERO;
		String descripcion = "";
		ResultadoDatosSolicitudVO resultado = null;
		
		final BigDecimal nucExpediente = datosEntrada.getDecimal(CTE_NUC_EXPEDIENTE);	

		GestionSindicados gs = new GestionSindicados();
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		// Obtenemos la ultima version completa (con numero de solicitud)
		DatosSolicitudC solicitudCompleta = gds.getUltimaVersionCompleta(nucExpediente);
		BigDecimal numeroSolicitud = null;
		
		// Obtenemos la ultima version ( numero de solicitud = 0)
		DatosSolicitudC solicitudNueva = gds.getUltimaVersion(nucExpediente);
		BigDecimal oficina =  solicitudNueva.getDatosSolicitudKey().getOficinaSolicitud();
		BigDecimal digito = solicitudNueva.getDigitoSolicitud();
	
		
		if (!validarImportes(solicitudNueva))			
		{
			error = BigDecimal.valueOf(2);
			descripcion = "La suma de los tramos debería ser igual al matriz.";
		}

			// Si no la hay, hay qeu obtener el numero de solicitud y el digito
			if (null == solicitudCompleta)
			{
				numeroSolicitud =  gds.getSiguienteNumeroSolicitud(solicitudNueva.getDatosSolicitudKey().getOficinaSolicitud());
				digito = gs.digitoSolicitud(numeroSolicitud, contexto, oficina);
				solicitudNueva.setFechaSolicitud(DateUtils.toSQLDate(DateUtils.dateNow()));
			//	solicitudNueva.setDigitoSolicitud(digito);
			}
			
			else
			{					
				numeroSolicitud = solicitudCompleta.getDatosSolicitudKey().getNumSolicitud();
				// Si ya hay una versión completa hay que comprobar si hay qeu reabrir tareas.
				// -Si la solicitud está sin resolver, pero la anterior estaba concedida hay que comprobar si corresponde abrir tareas.  Esto es porque
				// al modificar matriz o tramo ya se cambia es estado de la solicitud a Pendiente de resolver si es necesario.
				// -Si la solicitud ya está concedida hay que comprobar si hay qeu abrir tareas.
				if ((0==solicitudNueva.getEstadoSolicitud().compareTo(Constantes.ESTADO_SOL_SIN_RESOLVER)
						&& 0== solicitudCompleta.getEstadoSolicitud().compareTo(Constantes.ESTADO_SOL_CONCEDIDA))
						|| 0==solicitudNueva.getEstadoSolicitud().compareTo(Constantes.ESTADO_SOL_CONCEDIDA))
				{
					reabrirTareas(solicitudCompleta, solicitudNueva, nucExpediente);
				}
			}
			resultado = gs.finalizarSolicitudSindicados(solicitudNueva, numeroSolicitud, digito);
		
			
			if (resultado == null)
			{
				error = BigDecimal.ONE;
				descripcion = " Se ha producido un error y la solicitud no se ha finalizado correctamente";
			}

		
		
		IContexto[] salida = new IContexto[1];
		final IContexto contextoSalida = ContextoSindicados.rellenarDatosContextoAltaMod(resultado, error, descripcion);		
		
		salida[0] = contextoSalida;		
		
		
		if (LOGGER.isDebugEnabled())
		{
			LOGGER.debug("FIN SNANPM306: Finalizar solicitud.");						
		}
		
		return salida;
	}

	/**
     * Consulta del estado de una tarea del expediente
     * @param ctxEjecucion
     * @param nucExp
     * @param codTarea
     * @return String -> Estado tarea expediente
     */
     private String comprobarEstadoTarea(final BigDecimal nucExp, final BigDecimal codTarea)
     {                      
           String estado = Constantes.CADENA_VACIA;
           String error = Constantes.CADENA_VACIA;
           
           IContextoEjecucion ctxEjecucion = ServicioNegocio.getContexto();
           
           IDatosEntradaTx datosEntrada = ServicioNegocio.getPrograma(ctxEjecucion, new Integer(502), new Integer(274));
           
           datosEntrada.addCampo("NUC", nucExp);
           datosEntrada.addCampo("CODIGO_PROCESO", codTarea);
           
           IContexto[] datosSalida = ServicioNegocio.invocarServicio(ctxEjecucion, datosEntrada);
           
           if (null != datosSalida && 0 < datosSalida.length)
           {
                 estado = (datosSalida[0].getString("EEXPN003030"));
                 error = (datosSalida[0].getString("EEXPN003080"));                 
           }
           
           // Si el estado de la tarea es vacio y nos devuelve un 3- en el campo del error (es decir que no esta activa y nunca se ejecuto) 
           // o si el estado de la tarea es vacio (es decir que no esta activa la tarea) 
           // marcamos el estado con un -
           if (("3-".equals(error.substring(0,2)) && Constantes.CADENA_VACIA.equals(estado.trim()))
                       || Constantes.CADENA_VACIA.equals(estado.trim()))
           {
                 estado = Constantes.CTE_STRING_GUION;
           }
           
           return estado;
     }	
     
     /**
      * Valida qeu la suma de los importes de tramos sea igual al importe de matriz
      * @param solicitud
      * @return
      */
     private boolean validarImportes(DatosSolicitudC solicitud)
     {

    	 	boolean importesValidos = Boolean.TRUE;
			BigDecimal importeTotalTramos = BigDecimal.ZERO;
			BigDecimal importeFormalizarTramos = BigDecimal.ZERO;
			BigDecimal importeMaxTramos = BigDecimal.ZERO;
			final List<TramoC> tramos = GestionTramos.getUltimaVersionTramos(solicitud.getDatosSolicitudKey().getNucExpediente());
			
			if (null != tramos)
			{
				BigDecimal impTotalTramo = BigDecimal.ZERO;
				BigDecimal impFormalizarTramo = BigDecimal.ZERO;
				BigDecimal impMaxTramo = BigDecimal.ZERO;
				for (TramoC tramoC : tramos)
				{
					if (GestionTramos.esTramoVigente(tramoC.getEstadoTramo()))
					{
						// Suma de importes totales
						if (null != tramoC.getBidImporteTotalTramo())
						{
							impTotalTramo = tramoC.getBidImporteTotalTramo();
							// Contravalorar a moneda matriz, cuando matriz y tramo en distinta moneda
							if (!StringUtils.equals(tramoC.getStrMoneda(), solicitud.getMonedaImporteTotal()))
							{
								impTotalTramo = UtilidadesTramitacion.calcularContravalor(
										tramoC.getStrMoneda(),
										tramoC.getBidImporteTotalTramo(),
										solicitud.getMonedaImporteTotal());					
							}
							
							importeTotalTramos = importeTotalTramos.add(impTotalTramo);
						}
						// Suma de importes a formalizar
						if (null != tramoC.getBidImporteFormalizar())
						{
							impFormalizarTramo = tramoC.getBidImporteFormalizar();
							// Contravalorar a moneda matriz, cuando matriz y tramo en distinta moneda
							if (StringUtils.isNotBlank(solicitud.getMonedaImporteTotal())
									&& !StringUtils.equals(tramoC.getStrMoneda(), solicitud.getMonedaImporteTotal()))
							{
								impFormalizarTramo = UtilidadesTramitacion.calcularContravalor(
										tramoC.getStrMoneda(),
										tramoC.getBidImporteFormalizar(),
										solicitud.getMonedaImporteTotal());					
							}
								
							importeFormalizarTramos = importeFormalizarTramos.add(impFormalizarTramo);
						}
						// Suma de importes maximos
						if (null != tramoC.getBidImporteMaxParticipacion())
						{
							impMaxTramo = tramoC.getBidImporteMaxParticipacion();
							// Contravalorar a moneda matriz, cuando matriz y tramo en distinta moneda
							if (StringUtils.isNotBlank(solicitud.getMonedaImporteTotal())
									&& !StringUtils.equals(tramoC.getStrMoneda(), solicitud.getMonedaImporteTotal()))
							{
								impMaxTramo = UtilidadesTramitacion.calcularContravalor(
										tramoC.getStrMoneda(),
										tramoC.getBidImporteMaxParticipacion(),
										solicitud.getMonedaImporteTotal());					
							}
								
							importeMaxTramos = importeMaxTramos.add(impMaxTramo);
						}
					
					}
															
				}		
			}				
			
			
			// Validamos qeu la suma de tramos sea igual al matriz. Para cada importe.
			if (importeTotalTramos.compareTo(BigDecimal.ZERO) > 0)
			{
				final BigDecimal impTotalMatriz = solicitud.getImporteTotal();
				
				if (null != impTotalMatriz && importeTotalTramos.compareTo(impTotalMatriz) != 0)
				{
					//ServicioNegocio.rollback(ConstantesSindicados.ERROR_IMP_TOT, null,null, null);
					importesValidos = Boolean.FALSE;
				}			
			}
			
			if (importeFormalizarTramos.compareTo(BigDecimal.ZERO) > 0)
			{			
				final BigDecimal impFormalizarMatriz = solicitud.getImporteSolicitado();
				
				if (null != impFormalizarMatriz 
						&& impFormalizarMatriz.compareTo(BigDecimal.ZERO) > 0  
						&& importeFormalizarTramos.compareTo(impFormalizarMatriz) != 0)
				{
					//ServicioNegocio.rollback(ConstantesSindicados.ERROR_IMP_PART, null,null, null);
					importesValidos = Boolean.FALSE;
				}				
			}
			
			if (importeMaxTramos.compareTo(BigDecimal.ZERO) > 0)
			{			
				final BigDecimal impMaxMatriz = GestionSindicados.getImporteConcedido(solicitud);
			
				if (null != impMaxMatriz 
						&& impMaxMatriz.compareTo(BigDecimal.ZERO) > 0  
						&& importeMaxTramos.compareTo(impMaxMatriz) != 0)
				{
					//ServicioNegocio.rollback(ConstantesSindicados.ERROR_IMP_PART, null,null, null);
					importesValidos = Boolean.FALSE;
				}				
			}
			
			
			return importesValidos;
		 
     }
     
     
     /**
      * Cuando la solicitud estaba concedida y se hizo una modificacion qeu implica reabrir tareas
      * @param solicitudCompleta
      * @param solicitudNueva
      * @param nucExpediente
      */
     private void reabrirTareas(DatosSolicitudC solicitudCompleta, DatosSolicitudC solicitudNueva,  BigDecimal nucExpediente)
     {

    	 BigDecimal importeConcedido = GestionSindicados.getImporteConcedido(solicitudCompleta);   	 
     	 BigDecimal nuevoimporteFormalizar = solicitudNueva.getImporteSolicitado();
			
		 String	mndaImprteTtlAnts = solicitudCompleta.getMonedaImporteTotal();
		 String	mndaImprteTtlNva = solicitudNueva.getMonedaImporteTotal();
		 final BigDecimal numeroVersionActual = solicitudNueva.getDatosSolicitudKey().getVersionSolicitud();
		 SindicadosC mtrzVrsnAntrr = daoMatriz.buscarVersionAnterior(solicitudNueva.getDatosSolicitudKey().getOficinaSolicitud(), null,
					numeroVersionActual, nucExpediente);
		 BigDecimal numeroVersionAnterior = mtrzVrsnAntrr.getSindicadosKey().getBidVersion();
		 IContextoEjecucion contexto = ServicioNegocio.getContexto();
		
		 GestionSindicados gs = new GestionSindicados();
		 SindicadosC solicitudMatrizNueva = gs.getSindicadoPorVersion(nucExpediente, numeroVersionActual);
		 SindicadosC solicitudMatrizAnterior = gs.getSindicadoPorVersion(nucExpediente, numeroVersionAnterior);
		 Date fechaUltimoVctoMatriz = solicitudMatrizNueva.getFechaUltimoVcto();
		 Date fechaUltimoVctoMatrizAnterior = solicitudMatrizAnterior.getFechaUltimoVcto();

		// Matriz: 
		// Si se modifica el importe a formalizar por encima del concedido -> Reabrimos
		// Si se modfica la moneda -> Reabrimos
		// Si se modifican plazos al alza -> Reabrimos
		if ((null != importeConcedido && null != nuevoimporteFormalizar && nuevoimporteFormalizar.compareTo(importeConcedido) > 0)					
			 || (StringUtils.isNotBlank(mndaImprteTtlAnts) && StringUtils.isNotBlank(mndaImprteTtlNva) && !StringUtils.equals(mndaImprteTtlAnts, mndaImprteTtlNva))
			 || fechaUltimoVctoMatriz.compareTo(fechaUltimoVctoMatrizAnterior) > 0)
		{
			
			// Si la solicitud está en modo oferta se reabre tambien la tarea de Envio a Análisis
			// Comprobar si expediente en modo oferta
			// Para ello se mira si no tiene titulares vinculados			
			final IContexto[] titularesExpediente = Utilidades.recuperarTitularesExpediente(contexto, nucExpediente);
							
			if (UtilidadesTramitacion.isBlankOrNull(titularesExpediente))
			{
				reabrirTareaEnvioAnalisis(contexto, nucExpediente);
			}
			
			reabrirTareaSeleccionarComite(contexto, nucExpediente);
			reabrirTareaCrearInforme(contexto, nucExpediente);
			reabrirTareaResolucion(contexto, nucExpediente, solicitudNueva);
			reabrirTareaEnvioValidacionBO(contexto, nucExpediente);
		}
		
		// Tramos
		// Si se modifica el importe a formalizar por encima del concedido -> Reabrimos
		// Si se modfica la moneda -> Reabrimos
		// Si se modifican plazos al alza -> Reabrimos
		else
		{
			Boolean reabrirTareas = false;

			final List<TramoC> lstTramos = daoTramos.getUltimaVersionTramos(nucExpediente);	

			BigDecimal importeTramoConcedido = null;				
			BigDecimal nuevoImporteFormalizarTramo = null;			
				
			for (TramoC tramo : lstTramos)
			{
				
				importeTramoConcedido = tramo.getBidImporteMaxParticipacion();					
				nuevoImporteFormalizarTramo = tramo.getBidImporteFormalizar();	
					
				// Si se modifica el importe a formalizar al alza, por encima del maximo -> reabrimos
				if (null != nuevoImporteFormalizarTramo && null != importeTramoConcedido  &&
							nuevoImporteFormalizarTramo.compareTo(importeTramoConcedido) > 0)
				{
					reabrirTareas = true;
					break;
				}
				
				// Si no se modficó el importe comprobamos la moneda. Si se modifica la moneda -> Reabrimos
				if (!reabrirTareas)
				{
					TramoC tramoVersionAnterior = GestionTramos.getTramoAnterior(nucExpediente, tramo.getTramoKey().getBidTramo(), numeroVersionAnterior);
					if(null != tramoVersionAnterior && tramoVersionAnterior.getStrMoneda().compareTo(tramo.getStrMoneda()) != 0)
					{
						reabrirTareas = true;
						break;
					}
				}
				// Comprobamos la fecha de vcto final. Si se modifican plazos al alza -> Reabrimos
				if (!reabrirTareas)
				{
					TramoC tramoVersionAnterior = GestionTramos.getTramoAnterior(nucExpediente, 
							tramo.getTramoKey().getBidTramo(), numeroVersionAnterior);
					Date fechaUltimoVcto = DateHelper.stringASqlDate(tramo.getDatFechaUltimoPago(), DateHelper.FORMATO_DD_MM_YYYY_GUION);
					if (null != tramoVersionAnterior)
					{
						Date fechaUltimoVctoAnterior = DateHelper.stringASqlDate(tramoVersionAnterior.getDatFechaUltimoPago(), DateHelper.FORMATO_DD_MM_YYYY_GUION);
						if (fechaUltimoVcto.compareTo(fechaUltimoVctoAnterior) > 0)
						{
							reabrirTareas = true;
							break;
						}
					}
				}
				
	
			}
			// Condiciones de interés.
			// Si se cambia el tipo de interés fijo a variable o viceversa -> Reabrimos
			// Si es interés fijo y se reduce el % de interes -> Reabrimos
			// Si es interés variable y se reduce el diferencial -> Reabrimos		
			if (!reabrirTareas)
				{
					
					List<CondicionesInteresPactadasC> lstCondiciones = null;
					CondicionesInteresPactadasC cndcnAntrr = null;
					for (TramoC tramo : lstTramos)
					{
						lstCondiciones = daoCondiciones.getCondicionesPorVersion(nucExpediente, tramo.getTramoKey().getBidTramo(), numeroVersionActual);
												
						for (CondicionesInteresPactadasC condicion : lstCondiciones)
						{
							cndcnAntrr = daoCondiciones.getCondicionInteresPactada(tramo.getTramoKey().getBidNucExpedienteTramo(), numeroVersionAnterior, 
									condicion.getCondicionesInteresPactadasKey().getBidIdTipoIntereses(), 
									condicion.getCondicionesInteresPactadasKey().getBidIdNumCondicion(), 
									condicion.getCondicionesInteresPactadasKey().getBidIdTipoCondicion(), 
									condicion.getCondicionesInteresPactadasKey().getBidIdOrden());
							
							if (null != cndcnAntrr)
							{

								if ((condicion.getBidTipoInteres().compareTo(cndcnAntrr.getBidTipoInteres()) != 0)
										|| (condicion.getBidTipoInteres().intValue() == 0 && condicion.getBidInteres().compareTo(cndcnAntrr.getBidInteres()) < 0)
										|| (condicion.getBidDiferencialEstandar().compareTo(cndcnAntrr.getBidDiferencialEstandar()) < 0))
								{
									reabrirTareas = true;
									break;
								}							
							}						
						}
						
						if (reabrirTareas)
						{
							break;
						}
					}				
				}
			
				if (reabrirTareas)
				{
					reabrirTareaSeleccionarComite(contexto, nucExpediente);
					reabrirTareaCrearInforme(contexto, nucExpediente);
					reabrirTareaResolucion(contexto, nucExpediente, solicitudNueva);	
					reabrirTareaEnvioValidacionBO(contexto, nucExpediente);
				}				
			}			

     }
	
     private void reabrirTareaEnvioAnalisis(IContextoEjecucion contexto, final BigDecimal nucExpediente)
     {
    	 String strEstdoTrea = comprobarEstadoTarea(nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_ENVIO_ANALISIS);
		
    	 if (StringUtils.isNotBlank(strEstdoTrea)
    			 && !StringUtils.equals(strEstdoTrea, Constantes.CTE_STRING_GUION)
    			 && !StringUtils.equals(strEstdoTrea, Constantes.CTE_STR_N))
    	 {	
    		 Utilidades.modificarEstadoTareaExpediente(contexto, nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_ENVIO_ANALISIS, ConstantesSindicados.ESTADO_TAREA_REABRIR);
    	 }    	 
     }
     
     private void reabrirTareaSeleccionarComite(IContextoEjecucion contexto, final BigDecimal nucExpediente)
     {
    	String strEstdoTrea = comprobarEstadoTarea(nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_SELECCIONAR_COMITE);
		
		if (StringUtils.isNotBlank(strEstdoTrea)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STRING_GUION)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STR_N))
		{
			Utilidades.modificarEstadoTareaExpediente(contexto, nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_SELECCIONAR_COMITE, ConstantesSindicados.ESTADO_TAREA_REABRIR);
		}   	 
     }
     
     private void reabrirTareaCrearInforme(IContextoEjecucion contexto, final BigDecimal nucExpediente)
     {
    	 String strEstdoTrea = comprobarEstadoTarea(nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_CREAR_INFORME);
		
		if (StringUtils.isNotBlank(strEstdoTrea)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STRING_GUION)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STR_N))
		{
			Utilidades.modificarEstadoTareaExpediente(contexto, nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_CREAR_INFORME, ConstantesSindicados.ESTADO_TAREA_REABRIR);
		}   	 
     }
     
     private void reabrirTareaResolucion(IContextoEjecucion contexto, final BigDecimal nucExpediente, DatosSolicitudC solicitudNuevaVersion)
     {
    	String strEstdoTrea = comprobarEstadoTarea(nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_RESOLUCION);
		
		if (StringUtils.isNotBlank(strEstdoTrea)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STRING_GUION)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STR_N))
		{
			Utilidades.modificarEstadoTareaExpediente(contexto, nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_RESOLUCION, ConstantesSindicados.ESTADO_TAREA_REABRIR);
		} 
		
		// Ponemos el estado de la solicitud como Pendiente de resolucion
		solicitudNuevaVersion.setEstadoSolicitud(Constantes.ESTADO_SOL_SIN_RESOLVER);
		solicitudNuevaVersion.persist();
		
     }
     
     
     private void reabrirTareaEnvioValidacionBO(IContextoEjecucion contexto, final BigDecimal nucExpediente) 
     {
    	String strEstdoTrea = comprobarEstadoTarea(nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_ENVIO_VALIDACION_BO);
		
		if (StringUtils.isNotBlank(strEstdoTrea)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STRING_GUION)
				&& !StringUtils.equals(strEstdoTrea, Constantes.CTE_STR_N))
		{
			Utilidades.modificarEstadoTareaExpediente(contexto, nucExpediente, ConstantesSindicados.CTE_CODIGO_PROCESO_ENVIO_VALIDACION_BO, ConstantesSindicados.ESTADO_TAREA_REABRIR);
		}   	 
     }
     private void reabrirTareasOld(DatosSolicitudC solicitudCompleta, DatosSolicitudC solicitudNueva,  BigDecimal nucExpediente)
     {
			
  //  	 	DatosSolicitudC solicitudConcedida = GestionSindicados.getDatosSolicitudUltimaConcesion(solicitudCompleta.getDatosSolicitudKey().getOficinaSolicitud(),
  //  	 			                               solicitudCompleta.getDatosSolicitudKey().getNumSolicitud(), nucExpediente);
    	 			
    	    BigDecimal imprtPrtcpcnAnts = solicitudCompleta.getImporteSolicitado();
 /*   	 	if (null!=solicitudConcedida)
    	 	{
    	 		imprtPrtcpcnAnts = solicitudConcedida.getImporteSolicitado();
    	 	}
*/ 	 	
    	 	BigDecimal imprtPrtcpcnNva = solicitudNueva.getImporteSolicitado();
			
			String	mndaImprteTtlAnts = solicitudCompleta.getMonedaImporteTotal();
			String	mndaImprteTtlNva = solicitudNueva.getMonedaImporteTotal();
			IContextoEjecucion contexto = ServicioNegocio.getContexto();
						
			// Si se modifica el importe de participacion al alza o las monedas del matriz, implica reabrir tarea
			if ((null != imprtPrtcpcnAnts && null != imprtPrtcpcnNva && imprtPrtcpcnNva.compareTo(imprtPrtcpcnAnts) > 0)					
					|| (StringUtils.isNotBlank(mndaImprteTtlAnts) && StringUtils.isNotBlank(mndaImprteTtlNva) && !StringUtils.equals(mndaImprteTtlAnts, mndaImprteTtlNva)))
			{
				// Comprobar si expediente en modo oferta
				// Para ello se mira si no tiene titulares vinculados			
				final IContexto[] titularesExpediente = Utilidades.recuperarTitularesExpediente(contexto, nucExpediente);
								
				if (UtilidadesTramitacion.isBlankOrNull(titularesExpediente))
				{
					reabrirTareaEnvioAnalisis(contexto, nucExpediente);
				}
				
				reabrirTareaSeleccionarComite(contexto, nucExpediente);
				reabrirTareaCrearInforme(contexto, nucExpediente);
				reabrirTareaResolucion(contexto, nucExpediente, solicitudNueva);
				reabrirTareaEnvioValidacionBO(contexto, nucExpediente);
			}
			else
			{
				Boolean reabrirTareas = false;
				
				final SindicadosC mtrzIncmplta = daoMatriz.getUltimaVersionIncompleta(nucExpediente);
				SindicadosC mtrzVrsnAntrr = daoMatriz.buscarVersionAnterior(mtrzIncmplta.getSindicadosKey().getBidOficina(), null, mtrzIncmplta.getSindicadosKey().getBidVersion(), nucExpediente);
				
				// Si se modifica el importe de participacion al alza o las monedas del tramo, implica reabrir tarea
				final List<TramoC> lstTrmsVrsnAntrr = daoTramos.getTramosPorVersion(nucExpediente, mtrzVrsnAntrr.getSindicadosKey().getBidVersion());						
	
				TramoC tramoIncmplto = null;
				
			//	BigDecimal bidImprtMxPrtcpcnAntrr = null;
				BigDecimal bidImprtTtlAntrr = null;
			//	BigDecimal bidImprtFrmlzrAntrr = null;
	
				BigDecimal bidImprtMxPrtcpcnInCmplto = null;
				BigDecimal bidImprtTtlInCmplto = null;
				BigDecimal bidImprtFrmlzrInCmplto = null;			
				
				for (TramoC trmoVrsnAntrr : lstTrmsVrsnAntrr)
				{
			//		bidImprtMxPrtcpcnAntrr = trmoVrsnAntrr.getBidImporteMaxParticipacion();
					bidImprtTtlAntrr = trmoVrsnAntrr.getBidImporteTotalTramo();
			//		bidImprtFrmlzrAntrr = trmoVrsnAntrr.getBidImporteFormalizar();
					
					tramoIncmplto = GestionTramos.getUltimaVersionTramo(nucExpediente, trmoVrsnAntrr.getTramoKey().getBidTramo());
					
					bidImprtMxPrtcpcnInCmplto = tramoIncmplto.getBidImporteMaxParticipacion();
					bidImprtTtlInCmplto = tramoIncmplto.getBidImporteTotalTramo();
					bidImprtFrmlzrInCmplto = tramoIncmplto.getBidImporteFormalizar();	
					
					// Si se modifica el importe a formalizar al alza, por encima del maximo -> reabrimos
					if (null != bidImprtFrmlzrInCmplto && null != bidImprtMxPrtcpcnInCmplto  && bidImprtFrmlzrInCmplto.compareTo(bidImprtMxPrtcpcnInCmplto) > 0)
					{
						reabrirTareas = true;
						break;
					}
					// Si se modifica el importe Total del tramo al alza -> creo que no deberia abrirse
					if (null != bidImprtTtlInCmplto && null != bidImprtTtlAntrr  && bidImprtTtlInCmplto.compareTo(bidImprtTtlAntrr) > 0)
					{
						
					}
						
	
				}
				
				// Si se reduce a la baja el tipo de interes para el caso de fijo, o si se reduce a la baja el diferencial para los variables, o si cambia de fijo a variable o viceversa
				// implica reabrir tarea			
				if (!reabrirTareas)
				{
					final BigDecimal vrsnFnlSlctd = solicitudNueva.getDatosSolicitudKey().getVersionSolicitud();
					final List<TramoC> lstTramos = daoTramos.getTramosPorVersion(nucExpediente, vrsnFnlSlctd);
					
					List<CondicionesInteresPactadasC> lstCondiciones = null;
					CondicionesInteresPactadasC cndcnAntrr = null;
					for (TramoC tramo : lstTramos)
					{
						lstCondiciones = daoCondiciones.getCondicionesPorVersion(nucExpediente, tramo.getTramoKey().getBidTramo(), vrsnFnlSlctd);
						
						mtrzVrsnAntrr = daoMatriz.buscarVersionAnterior(solicitudNueva.getDatosSolicitudKey().getOficinaSolicitud(), null, vrsnFnlSlctd, nucExpediente);
						
						for (CondicionesInteresPactadasC condicion : lstCondiciones)
						{
							cndcnAntrr = daoCondiciones.getCondicionInteresPactada(tramo.getTramoKey().getBidNucExpedienteTramo(), mtrzVrsnAntrr.getSindicadosKey().getBidVersion(), 
									condicion.getCondicionesInteresPactadasKey().getBidIdTipoIntereses(), 
									condicion.getCondicionesInteresPactadasKey().getBidIdNumCondicion(), 
									condicion.getCondicionesInteresPactadasKey().getBidIdTipoCondicion(), 
									condicion.getCondicionesInteresPactadasKey().getBidIdOrden());
							
							if (null != cndcnAntrr)
							{
								if ((condicion.getBidTipoInteres().compareTo(cndcnAntrr.getBidTipoInteres()) != 0)
										|| (condicion.getBidTipoInteres().intValue() == 0 && condicion.getBidInteres().compareTo(cndcnAntrr.getBidInteres()) < 0)
										|| (condicion.getBidDiferencialEstandar().compareTo(cndcnAntrr.getBidDiferencialEstandar()) < 0))
								{
									reabrirTareas = true;
									break;
								}							
							}						
						}
						
						if (reabrirTareas)
						{
							break;
						}
					}				
				}
			
				if (reabrirTareas)
				{
					reabrirTareaSeleccionarComite(contexto, nucExpediente);
					reabrirTareaCrearInforme(contexto, nucExpediente);
					reabrirTareaResolucion(contexto, nucExpediente, solicitudNueva);	
					reabrirTareaEnvioValidacionBO(contexto, nucExpediente);
				}				
			}			

     }
 
}