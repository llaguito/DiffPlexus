/**
 * 
 */
package es.caixagalicia.anpm.prestamos.catalogo.servicios.fachada;

import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Time;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

import es.caixagalicia.anpm.prestamos.catalogo.persistencia.busqueda.BusquedaProductoObj;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.busqueda.VersionObj;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.busqueda.VersionSubpObj;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.interes.InteresC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.ProductoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.SubProductoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.version.VersionesC;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionInteres;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionProducto;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionSubProducto;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionVersiones;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.fachada.contextos.ContextosBusquedaProducto;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.fachada.contextos.ContextosProducto;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Utilidades;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.log.LogHelper;

/**
 * @author U7336
 *
 */
public class BusquedaProductoSrv extends ServicioNegocio
{

	private static final int CTE_POSICION_TIRA_ID_PRODUCTO 				= 0; // Optativo
	private static final int CTE_POSICION_TIRA_DESCRIPCION_PRODUCTO 	= 1; // Optativo
	private static final int CTE_POSICION_TIRA_TIPO_FINANCIACION 		= 2; // Optativo
	private static final int CTE_POSICION_TIRA_DESTINO 					= 3; // Optativo
	private static final int CTE_POSICION_TIRA_SUBDESTINO 				= 4; // Optativo
	private static final int CTE_POSICION_TIRA_SECTOR 					= 5; // Optativo
	//private static final int CTE_POSICION_TIRA_COLECTIVO 				= 6; // Optativo
	private static final int CTE_POSICION_TIRA_CANAL 					= 7; // Optativo
	private static final int CTE_POSICION_TIRA_MONEDA 					= 8; // Optativo
	private static final int CTE_POSICION_TIRA_FECHA_DESDE 				= 9; // Optativo
	private static final int CTE_POSICION_TIRA_FECHA_HASTA 				= 10; // Optativo
	private static final int CTE_POSICION_TIRA_OPERACION 				= 11; // Optativo
	private static final int CTE_POSICION_TIRA_PASADAS	 				= 12; // Optativo
	
	private static final int CTE_POSICION_TIRA_GRUPO_DESTINO	 		= 13; // Optativo
	private static final int CTE_POSICION_TIRA_GRUPO_SECTOR	 			= 14; // Optativo
	private static final int CTE_POSICION_TIRA_CARTERA	 		    	= 15; // Optativo
	private static final int CTE_POSICION_TIRA_TITULARIDAD 		    	= 16; // Optativo
	
	/**
	 * Log de la clase.
	 */
	private static final LogHelper LOGGER = LogHelper.getLog(BusquedaProductoSrv.class);
	
	/**
	 * 
	 */
	public BusquedaProductoSrv()
	{
		super();
		// TODO Auto-generated constructor stub
	}

	/* (non-Javadoc)
	 * @see es.caixagalicia.ifrt.core.ServicioNegocio#ejecutar(es.caixagalicia.ifrt.core.IContextoEjecucion, es.caixagalicia.ifrt.core.IDatosEntradaTx)
	 */
	@Override
	public IContexto[] ejecutar(IContextoEjecucion contexto, IDatosEntradaTx datosEntrada)
	{
		// TODO Auto-generated method stub
		final long lInicio = System.currentTimeMillis();
		if (LOGGER.isDebugEnabled())
		{
			LOGGER.debug("INICIO SNANPM042: Busqueda de Productos");
		}
		
		contexto.setDiarioElectronico(new DiarioElectronico(
				Constantes.CTE_OPERACION_AC,
				Integer.valueOf(0),
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                Constantes.CTE_STRING_EMPTY,
                Constantes.CTE_STRING_EMPTY,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                Integer.valueOf(0)));

		if (LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Obtenemos los parametros de entrada");
			LOGGER.debug("");
			LOGGER.debug("");
			LOGGER.debug("----------------------------------------------------------------------------------");
			LOGGER.debug("");
			LOGGER.debug("USUARIO APLICACIÓN");
			LOGGER.debug(contexto.getUsuario());
			LOGGER.debug("");
			LOGGER.debug("");
			LOGGER.debug("");
			LOGGER.debug("");
			LOGGER.debug("-----------------------------------------------------------------------------------");
		}
		
		
		//contexto.getUsuario();
		
		
		BigDecimal bidIdProducto = datosEntrada.getDecimal(CTE_POSICION_TIRA_ID_PRODUCTO); // opcional
		Integer idprod = null;
		if(bidIdProducto!=null)	idprod = new Integer(bidIdProducto.intValue());
		
		String descripcion = datosEntrada.getString(CTE_POSICION_TIRA_DESCRIPCION_PRODUCTO); // opcional
		if(Utilidades.isBlankOrNull(descripcion))	descripcion = "";
		
		String tipoFinan = datosEntrada.getString(CTE_POSICION_TIRA_TIPO_FINANCIACION); // opcional
		String destino = datosEntrada.getString(CTE_POSICION_TIRA_DESTINO); // opcional
		
		String subdestino ="";
		String subd= datosEntrada.getString(CTE_POSICION_TIRA_SUBDESTINO); // opcional
		if(!Utilidades.isBlankOrNull(subd))	subdestino = subd.trim();
		
		String sSector = datosEntrada.getString(CTE_POSICION_TIRA_SECTOR); // opcional
		Integer sector = null;
		if(!Utilidades.isBlankOrNull(sSector))	sector = new Integer(sSector);
		
		String scanal = datosEntrada.getString(CTE_POSICION_TIRA_CANAL); // opcional
		Integer canal = null;
		if(!Utilidades.isBlankOrNull(scanal))	canal = new Integer(scanal.trim());
		
		String moneda = ""; // opcional
		String mon = datosEntrada.getString(CTE_POSICION_TIRA_MONEDA);
		if(!Utilidades.isBlankOrNull(mon))	moneda = mon.trim();
		
		String fechaDesde = datosEntrada.getString(CTE_POSICION_TIRA_FECHA_DESDE); // opcional
		String fechaHasta = datosEntrada.getString(CTE_POSICION_TIRA_FECHA_HASTA); // opcional
		
		
		String operacion = datosEntrada.getString(CTE_POSICION_TIRA_OPERACION);
		
		BigDecimal pasadas = datosEntrada.getDecimal(CTE_POSICION_TIRA_PASADAS); // opcional
		Integer iPasadas = null;
		if(pasadas!=null)	iPasadas = new Integer(pasadas.intValue());
		else				iPasadas = new Integer(0);

		String grupoDestino = datosEntrada.getString(CTE_POSICION_TIRA_GRUPO_DESTINO); // OPCIONAL
		String grupoSector = datosEntrada.getString(CTE_POSICION_TIRA_GRUPO_SECTOR); // OPCIONAL
		
		String cartera = datosEntrada.getString(CTE_POSICION_TIRA_CARTERA); // opcional
		
		//Nuevo criterio de búsqueda
		String titularidad = ""; 	// opcional	
		
		String versionActualStr = ServicioNegocio.getContexto().getVersionActual();
		BigDecimal versionActualBid = new BigDecimal(versionActualStr);
		
		if (0 >= new BigDecimal(2).compareTo(versionActualBid))
		{			
			titularidad = datosEntrada.getString(CTE_POSICION_TIRA_TITULARIDAD);
		}
		
		//filtramos todas las búsquedas de productos por la entidad a la que pertenece el terminal desde el que se busca
		String oficinaTerminal = contexto.getOficina();
		String entidad = UtilidadesComun.obtenerEntidadCentro(oficinaTerminal);
		
		String terminal = contexto.getTerminal();

		if (Constantes.CTE_TERMINAL_BATCH.equals(terminal)) {
			entidad = "";
		}
		else {

			//para determinados usuarios no se va a filtrar por entidad (para que puedan revisar incidencias de una entidad a pesar de pertenecer a otra)
			// Llamada a ambitos
			Boolean cumpleAmbito = Utilidades.esCumpleAmbitos(
					ConstantesComun.CTE_AMBIT_PROD_ENT_ID_APL,
					ConstantesComun.CTE_AMBIT_PROD_ENT_TIPO_ENTIDAD,
					ConstantesComun.CTE_AMBIT_PROD_ENT_ENTIDAD_TODASENT,
					null, //centro: no aplica, el ámbito se mira por usuario
					contexto.getUsuario()
					);
		
			if (cumpleAmbito)
			{	
				entidad = "";
			}
		}
		
		IContexto[] contextoSalida;
		
		if(Utilidades.isBlankOrNull(operacion)) {
			contextoSalida = getBusquedaProductoCopiar(idprod, descripcion, entidad);
		}else {
//			if(idprod!= null && idprod.equals(new Integer(007))) {
//				contextoSalida = getBusquedaProductoSQL(idprod,descripcion, tipoFinan, destino, subdestino, 
//						sector, canal, moneda, fechaDesde, fechaHasta, iPasadas);
//				
//			}else {
				contextoSalida = getBusquedaProducto(idprod,descripcion, tipoFinan, destino, subdestino, 
						sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad, entidad );						
			//}			
		}

		if (LOGGER.isDebugEnabled())
		{
			LOGGER.debug("FIN SNANPM042: busqueda producto. " +
					"***********             Tiempo total: " + (System.currentTimeMillis() - lInicio) + "ms                   ***********");
		}
		return contextoSalida;		
	}
	
	public IContexto[] getBusquedaProductoCopiar(Integer idprod, String descripcion, String entidad) {
		GestionProducto gprod = new GestionProducto();
		
		List<ProductoC> productos = gprod.buscarProductos(idprod, descripcion, entidad);
		
		// debemos generar el contexto de salida 
		// tras la busqueda tendremos una lista de  productoC con sus datos
				
		final IContexto[] contextoSalida = ContextosProducto.rellenarDatosContexto(productos);
		
		if (LOGGER.isDebugEnabled())
		{			
				LOGGER.debug("Se ha buscado el producto corerctamente");
		}
		return contextoSalida;
	}
	
	@SuppressWarnings("unchecked")
	public IContexto[] getBusquedaProducto(Integer idprod, String descripcion, String tipoFinan, 
			String destino, String subdestino, Integer sector, Integer canal, String moneda, 
			String fechaDesde, String fechaHasta, Integer iPasadas, String grupoDestino, String grupoSector, 
			String cartera, String titularidad, String entidad) {
	
		GestionProducto gprod = new GestionProducto();
		Vector<BusquedaProductoObj> salida = new Vector<BusquedaProductoObj>();
		
		if(Utilidades.isBlankOrNull(idprod) && Utilidades.isBlankOrNull(descripcion))
		{
			if(Utilidades.isBlankOrNull(tipoFinan) && Utilidades.isBlankOrNull(destino) &&
					Utilidades.isBlankOrNull(subdestino) && sector==null
					&& Utilidades.isBlankOrNull(grupoDestino) && Utilidades.isBlankOrNull(grupoSector)
					&& canal==null && Utilidades.isBlankOrNull(moneda) && Utilidades.isBlankOrNull(cartera)
					&& Utilidades.isBlankOrNull(titularidad)) 
			{
				List<Object> list2 = null;
				//Todos los productos y subproductos que tengan version
				List<Object> list = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				list2 = gprod.buscarProductoSQLNoOfiDateco(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);				
				
				List<VersionSubpObj> lista = eliminarDatosRepetidos(list, list2, VersionSubpObj.TODO);
				

				list = gprod.buscarProductosSQLSinDatEco(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				list2 = gprod.buscarProductoSQLSinDatEcoNoOfi(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				lista.addAll(eliminarDatosRepetidos(list, list2, VersionSubpObj.SINDATECO));
				
				
				
				list = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				list2 = gprod.buscarProductoSQLSinInteresNoOficina(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				lista.addAll(eliminarDatosRepetidos(list, list2, VersionSubpObj.SININT));
				
				
				
				list = gprod.buscarProductoSQLSinDatEcoNiInteres(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				lista.addAll(borrarDatosIncoherentes(VersionSubpObj.getList(list, VersionSubpObj.NADA)));
				
				Collections.sort(lista, new VersionSubpObj());
				
				construyeSalida(lista, salida);
				
				List<ProductoC> productos = gprod.buscarProductoSinSubproductos(entidad);
				for(int i=0; i<productos.size(); i++) {
					ProductoC tmp = productos.get(i);
					salida.add(getProducto(tmp));
				}
				
				Collections.sort(salida, new BusquedaProductoObj());

				
			}else {
				
				if(Utilidades.isBlankOrNull(destino)&&Utilidades.isBlankOrNull(sector) 
						&& Utilidades.isBlankOrNull(grupoDestino) && Utilidades.isBlankOrNull(grupoSector) &&
						Utilidades.isBlankOrNull(canal)&&Utilidades.isBlankOrNull(moneda)
						&& Utilidades.isBlankOrNull(cartera) && Utilidades.isBlankOrNull(titularidad)) 
				{	// criterios pero sin destino o sector o canal o moneda o cartera
					List<Object> list2 = null;
					
					List<Object> list = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
					
					list2 = gprod.buscarProductoSQLNoOfiDateco(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);					
					
					List<VersionSubpObj> lista = eliminarDatosRepetidos(list, list2, VersionSubpObj.TODO);
					
					
					list = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
					
					list2 = gprod.buscarProductoSQLSinInteresNoOficina(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
					
					lista.addAll(eliminarDatosRepetidos(list, list2, VersionSubpObj.SININT));
										
					Collections.sort(lista, new VersionSubpObj());
					
					construyeSalida(lista, salida);
				}else 
				{			//criterios con destino o sector o canal o moneda o grupodestino o gruposector
					List<VersionSubpObj> list2 = null;
					
					List<VersionSubpObj> lista = gprod.buscarProductoSQLClausulas(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad,
							entidad);
					
					//List<VersionSubpObj> lista = VersionSubpObj.getList(list, VersionSubpObj.TODO);
					
					List<VersionSubpObj> list = gprod.buscarProductoSQLSinIntClausulas(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad,
							entidad);
					
					list2 = gprod.buscarProductoSQLSinIntClausulasNoOficina(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad,
							entidad);
					
					lista.addAll(eliminarDatosRepetidos(list, list2));
					
					Collections.sort(lista, new VersionSubpObj());
					
					construyeSalida(lista, salida);
				}
			}
		}
		else 
		{
			if(Utilidades.isBlankOrNull(tipoFinan) && Utilidades.isBlankOrNull(destino) &&
					Utilidades.isBlankOrNull(subdestino)&&sector==null
					&& Utilidades.isBlankOrNull(grupoDestino) && Utilidades.isBlankOrNull(grupoSector)
					&&canal==null&&Utilidades.isBlankOrNull(moneda) && Utilidades.isBlankOrNull(cartera)  && Utilidades.isBlankOrNull(titularidad)
			) {
						// Por idProducto o descripcion
				
//				if(idprod.equals(new Integer(660667))) {
//					GestionVersiones.actualizaVersionesComisiones();
//				}
				
				List<Object> list2 = null;
				
				List<Object> list = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				list2 = gprod.buscarProductoSQLNoOfiDateco(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				
				List<VersionSubpObj> lista = eliminarDatosRepetidos(list, list2, VersionSubpObj.TODO);
			
				
				list = gprod.buscarProductosSQLSinDatEco(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				list2 = gprod.buscarProductoSQLSinDatEcoNoOfi(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				lista.addAll(eliminarDatosRepetidos(list, list2, VersionSubpObj.SINDATECO));

				
				
				list = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				list2 = gprod.buscarProductoSQLSinInteresNoOficina(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				lista.addAll(eliminarDatosRepetidos(list, list2, VersionSubpObj.SININT));
				
				list = gprod.buscarProductoSQLSinDatEcoNiInteres(idprod, descripcion, tipoFinan, destino, 
						subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
				
				lista.addAll(borrarDatosIncoherentes(VersionSubpObj.getList(list, VersionSubpObj.NADA)));
				
				Collections.sort(lista, new VersionSubpObj());
				
				if(lista.size()!=0) {
					construyeSalida(lista, salida);
				}else {
					//no tiene subproductos
					List<ProductoC> productos = gprod.buscarProductos(idprod, descripcion, entidad);
					for(int i=0; i<productos.size(); i++) {
						ProductoC tmp = productos.get(i);
						salida.add(getProducto(tmp));
						List<VersionesC> vers = GestionVersiones.obtenerVersionesProductoVersionEnFechas(tmp.getProductoKey().getIdProducto(), 
								tmp.getProductoKey().getIdVersion(), fechaDesde, fechaHasta, iPasadas);
						for(int j=0; j<vers.size(); j++) {
							if(!vers.get(j).getVersionKey().getIdSubProducto().equals(new Integer(0))) {
								salida.add(getSubProducto(vers.get(j)));
							}
						}
					}
				}
	
			}else { 		// Por idProducto o descripcion o tipo finan y criterios sin destino o sector
				if(Utilidades.isBlankOrNull(destino)&&Utilidades.isBlankOrNull(sector) 
						&& Utilidades.isBlankOrNull(grupoDestino) && Utilidades.isBlankOrNull(grupoSector)&&
						Utilidades.isBlankOrNull(canal)&&Utilidades.isBlankOrNull(moneda)
						&& Utilidades.isBlankOrNull(cartera) && Utilidades.isBlankOrNull(cartera) && Utilidades.isBlankOrNull(titularidad)) {
					
					List<Object> list2;
					
					List<Object> list = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
					
					list2 = gprod.buscarProductoSQLNoOfiDateco(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
					
					List<VersionSubpObj> lista = eliminarDatosRepetidos(list, list2, VersionSubpObj.TODO);
					
					list = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
					
					list2 = gprod.buscarProductoSQLSinInteresNoOficina(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
					
					lista.addAll(eliminarDatosRepetidos(list, list2, VersionSubpObj.SININT));

					
					Collections.sort(lista, new VersionSubpObj());
					
					construyeSalida(lista, salida);
				}else {			// Por idProducto o descripcion y criterios con destino o sector o moneda o canal
					// o grupoDestino o grupoSector
					
//					List<Object> list = gprod.buscarProductoSQLDestinoTodo(idprod, descripcion, tipoFinan, destino, 
//							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas);
//					
//					List<VersionSubpObj> lista = VersionSubpObj.getList(list, VersionSubpObj.TODO);
//					
//					list = gprod.buscarProductoSQLSinInteresDestinoTodo(idprod, descripcion, tipoFinan, destino, 
//							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas);
//					
//					lista.addAll(VersionSubpObj.getList(list, VersionSubpObj.SININT));
//					
//					Collections.sort(lista, new VersionSubpObj());
//					
//					construyeSalida(lista, salida);
//---------------------------------------					
					List<VersionSubpObj> lista = gprod.buscarProductoSQLClausulas(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad,
							entidad);
					
					//List<VersionSubpObj> lista = VersionSubpObj.getList(list, VersionSubpObj.TODO);
					
					
					
					List<VersionSubpObj> list = gprod.buscarProductoSQLSinIntClausulas(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad,
							entidad);
					
					List<VersionSubpObj> list2 = gprod.buscarProductoSQLSinIntClausulasNoOficina(idprod, descripcion, tipoFinan, destino, 
							subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad,
							entidad);
					
					lista.addAll(eliminarDatosRepetidos(list, list2));
					
					Collections.sort(lista, new VersionSubpObj());
					
					construyeSalida(lista, salida);
//---------------------------------------						
				}				
			}
			
		}
		
		if (LOGGER.isDebugEnabled())
		{			
			LOGGER.debug("*************************************************************************************");	
			LOGGER.debug("************        Número de elementos ------->    "+salida.size());
			LOGGER.debug("************                                                     ********************");
			LOGGER.debug("************                                                     ********************");
			LOGGER.debug("************                                                     ********************");
			LOGGER.debug("************                                                     ********************");
			LOGGER.debug("************                                                     ********************");
			LOGGER.debug("************                                                     ********************");
			LOGGER.debug("*************************************************************************************");
		}
		
		final IContexto[] contextoSalida =ContextosBusquedaProducto.rellenarDatosContexto(salida);
		
		if (LOGGER.isDebugEnabled())
		{			
				LOGGER.debug("Se ha buscado el producto corerctamente");
		}
		return contextoSalida;
	}
	
	private List<VersionSubpObj> eliminarDatosRepetidos(List<Object> list,
			List<Object> list2, String tipo)
	{
		// TODO Auto-generated method stub
		List<VersionSubpObj> lista1 = VersionSubpObj.getList(list, tipo);
		
		//borramos datos repetidos en la lista original (list, lista1)
		List<VersionSubpObj> lista2 = VersionSubpObj.getList(list2, tipo);
		boolean encontrado = false;
		for(int i = lista2.size()-1; i>=0; i--) {
			VersionSubpObj tmp2 = lista2.get(i);
			for(int j=0; j<lista1.size() && encontrado == false; j++) {
				VersionSubpObj tmp1 = lista1.get(j);
				
				if(tmp2.getIdProducto().equals(tmp1.getIdProducto()) &&
						tmp2.getVersionG().equals(tmp1.getVersionG()) &&
						tmp2.getVersionProd().equals(tmp1.getVersionProd()) &&
						tmp2.getVersionSubp().equals(tmp1.getVersionSubp())) 
				{
					//borramos dato repetido
					lista2.remove(tmp2);
					encontrado = true;
				}
			}
		}
		
		//borramos datos repetidos de nivel de datos economicos de la lista2
		if(lista2.size()>1) {
			for(int i = lista2.size()-1; i>=0; i--) {
				if(i==lista2.size()-1) {
					//nada
				}else {
					VersionSubpObj tmp1 = lista2.get(i);
					VersionSubpObj tmp2 = lista2.get(i+1);
					if(tmp2.getIdProducto().equals(tmp1.getIdProducto()) &&
							tmp2.getVersionG().equals(tmp1.getVersionG()) &&
							tmp2.getVersionProd().equals(tmp1.getVersionProd()) &&
							tmp2.getVersionSubp().equals(tmp1.getVersionSubp()) &&
							tmp2.getVersionInt().equals(tmp1.getVersionInt())) 
					{
						//si tiene intereses, hay que borrar los de distinto nivel
						if(tmp1.getNivelInteres()!=null && tmp2.getNivelInteres()!=null) {
							if(!tmp2.getNivelInteres().equals(tmp1.getNivelInteres())) {
								//borramos dato repetido
								lista2.remove(tmp2);
							}
						}else {
							//borramos dato repetido
							lista2.remove(tmp2);
						}
					}
				}
			}
		}			
		
		//añadimos los datos de lista2 a la lista1
		if(lista2.size()>0) {
			lista1.addAll(lista2);
		}
		
		return  borrarDatosIncoherentes(lista1);
	}
	
	

	private List<VersionSubpObj> borrarDatosIncoherentes(
			List<VersionSubpObj> lista1)
	{
		// TODO Auto-generated method stub
		for(int i = lista1.size()-1; i>=0; i--) {
			VersionSubpObj tmp = lista1.get(i);
			if(!DateUtils.getSoloFecha(tmp.getDateFechaFin()).equals(DateUtils.getSoloFecha(Date.valueOf(DateUtils.CTE_DATELOWESTONLYDAY)))  
					&& tmp.getDateFechaInicio().after(tmp.getDateFechaFin())) {
				
				lista1.remove(i);
			}
		}
		return lista1;
	}

	private List<VersionSubpObj> eliminarDatosRepetidos(List<VersionSubpObj> lista1,
			List<VersionSubpObj> lista2)
	{
		// TODO Auto-generated method stub
		
		//borramos datos repetidos en la lista original (lista1)

		boolean encontrado = false;
		for(int i = lista2.size()-1; i>=0; i--) {
			VersionSubpObj tmp2 = lista2.get(i);
			for(int j=0; j<lista1.size() && encontrado == false; j++) {
				VersionSubpObj tmp1 = lista1.get(j);
				
				if(tmp2.getIdProducto().equals(tmp1.getIdProducto()) &&
						tmp2.getVersionG().equals(tmp1.getVersionG()) &&
						tmp2.getVersionProd().equals(tmp1.getVersionProd()) &&
						tmp2.getVersionSubp().equals(tmp1.getVersionSubp())) 
				{
					//borramos dato repetido
					lista2.remove(tmp2);
					encontrado = true;
				}
			}
		}
		
		//borramos datos repetidos de nivel de datos economicos de la lista2
		if(lista2.size()>1) {
			for(int i = lista2.size()-1; i>=0; i--) {
				if(i==lista2.size()-1) {
					//nada
				}else {
					VersionSubpObj tmp1 = lista2.get(i);
					VersionSubpObj tmp2 = lista2.get(i+1);
					if(tmp2.getIdProducto().equals(tmp1.getIdProducto()) &&
							tmp2.getVersionG().equals(tmp1.getVersionG()) &&
							tmp2.getVersionProd().equals(tmp1.getVersionProd()) &&
							tmp2.getVersionSubp().equals(tmp1.getVersionSubp()) &&
							tmp2.getVersionInt().equals(tmp1.getVersionInt())) 
					{
						//si tiene intereses, hay que borrar los de distinto nivel
						if(tmp1.getNivelInteres()!=null && tmp2.getNivelInteres()!=null) {
							if(!tmp2.getNivelInteres().equals(tmp1.getNivelInteres())) {
								//borramos dato repetido
								lista2.remove(tmp2);
							}
						}else {
							//borramos dato repetido
							lista2.remove(tmp2);
						}
					}
				}
			}
		}			
		
		//añadimos los datos de lista2 a la lista1
		if(lista2.size()>0) {
			lista1.addAll(lista2);
		}
		
		
		
		return borrarDatosIncoherentes(lista1);
	}

	/*public void construyeSalida(List<DatEcoC> datEco, Vector<BusquedaProductoObj> salida, Integer iPasadas) {
		GestionVersiones gvers = new GestionVersiones();
		Integer idProd = null;
		
		List<Integer> subBuenos = new Vector<Integer>();
		
		for(int i=0; i<datEco.size(); i++) {	
			DatEcoC datEcoTMP = datEco.get(i);
			
			List<VersionesC> versiones = gvers.obtenerVersionesDatosEco(datEcoTMP.getDatEcoKey().getIdProducto(), 
					datEcoTMP.getDatEcoKey().getIdSubProducto(), datEcoTMP.getDatEcoKey().getVersion(), 
					iPasadas, datEcoTMP.getDatEcoKey().getCodColectivo());
						
			if(datEcoTMP.getDatEcoKey().getIdSubProducto().equals(Constantes.CTE_CERO)) {
				//nada, porque es cero... aunque igual deberian ser todos...
				//si son todos, tengo que coger el producto y todos los subproductos en todas sus versiones
				List<VersionesC> versiones = gvers.obtenerVersionesDatosEco(datEcoTMP.getDatEcoKey().getIdProducto(), 
						datEcoTMP.getDatEcoKey().getIdSubProducto(), datEcoTMP.getDatEcoKey().getVersion(), 
						iPasadas, datEcoTMP.getDatEcoKey().getCodColectivo());
				
				//ProductoC prod = GestionProducto.obtenerProductoVersion(versiones.get(0).getVersionKey().getIdProducto(), versiones.get(0).getAn01tb01());
				salida.add(getProducto(versiones.get(0)));
				
				Falta añadir los subproductos...
				
				
								
				
			}else {
				if(Utilidades.isBlankOrNull(idProd)) {
					idProd = versiones.get(0).getVersionKey().getIdProducto();
					//ahora una get linea de producto y set en la salida
					salida.add(getProducto(versiones.get(0)));
				}else if(!idProd.equals(versiones.get(0).getVersionKey().getIdProducto())){
					idProd = versiones.get(0).getVersionKey().getIdProducto();
					//ahora una get linea de producto y set en la salida
					salida.add(getProducto(versiones.get(0)));
				}else {
					
				}

				//sigo con los subproductos mientras no cambie el idProd
				for(int j=0; j<versiones.size(); j++) {
					if(idProd.equals(versiones.get(j).getVersionKey().getIdProducto())) 
					{
						//linea de subproducto con sus datos
						VersionesC versTMP = versiones.get(j);
						if(!versTMP.getVersionKey().getIdSubProducto().equals(new Integer(0)))
							salida.add(getSubProducto(versiones.get(j), datEcoTMP));
					}else{
						//linea de producto
						salida.add(getProducto(versiones.get(j)));
						idProd = versiones.get(j).getVersionKey().getIdProducto();
						//linea de subproducto con sus datos
						VersionesC versTMP = versiones.get(j);
						if(!versTMP.getVersionKey().getIdSubProducto().equals(new Integer(0)))
							salida.add(getSubProducto(versiones.get(j), datEcoTMP));
					}
				}				
			}
			
		}
	}*/
	
	/*public void construyeSalida(ProductoC prod, List<DatEcoC> datEco, Vector<BusquedaProductoObj> salida, 
			String fechaDesde, String fechaHasta, Integer iPasadas) {
		GestionVersiones gvers = new GestionVersiones();
		Integer idProd = null;
		
		for(int i=0; i<datEco.size(); i++) {	
			DatEcoC datEcoTMP = datEco.get(i);
			if(datEcoTMP.getDatEcoKey().getIdSubProducto().equals(Constantes.CTE_CERO)) {
				//nada, porque es cero... aunque igual deberian ser todos...
				//si son todos, tengo que coger el producto y todos los subproductos en todas sus versiones
				List<VersionesC> versiones = gvers.obtenerVersionesDatosEco(datEcoTMP.getDatEcoKey().getIdProducto(), 
						datEcoTMP.getDatEcoKey().getIdSubProducto(), datEcoTMP.getDatEcoKey().getVersion(), 
						iPasadas, datEcoTMP.getDatEcoKey().getCodColectivo());
				
				//ProductoC prod = GestionProducto.obtenerProductoVersion(versiones.get(0).getVersionKey().getIdProducto(), versiones.get(0).getAn01tb01());
				salida.add(getProducto(prod));
				
				List<VersionesC> vers = GestionVersiones.obtenerVersionesProductoVersionEnFechas(prod.getProductoKey().getIdProducto(), 
						prod.getProductoKey().getIdVersion(), fechaDesde, fechaHasta, iPasadas);
				for(int j=0; j<vers.size(); j++) {
					if(!vers.get(j).getVersionKey().getIdSubProducto().equals(new Integer(0))) {
						salida.add(getSubProducto(vers.get(j)));
					}
				}

			}else {
			
				List<VersionesC> versiones = gvers.obtenerVersionesDatosEco(datEcoTMP.getDatEcoKey().getIdProducto(), 
										datEcoTMP.getDatEcoKey().getIdSubProducto(), datEcoTMP.getDatEcoKey().getVersion(), 
										iPasadas, datEcoTMP.getDatEcoKey().getCodColectivo());
				
				if(Utilidades.isBlankOrNull(idProd)) {
					idProd = versiones.get(0).getVersionKey().getIdProducto();
					//ahora una get linea de producto y set en la salida
					salida.add(getProducto(versiones.get(0)));
				}else if(!idProd.equals(versiones.get(0).getVersionKey().getIdProducto())){
					idProd = versiones.get(0).getVersionKey().getIdProducto();
					//ahora una get linea de producto y set en la salida
					salida.add(getProducto(versiones.get(0)));
				}

				//sigo con los subproductos mientras no cambie el idProd
				for(int j=0; j<versiones.size(); j++) {
					if(idProd.equals(versiones.get(j).getVersionKey().getIdProducto())) 
					{
						//linea de subproducto con sus datos
						VersionesC versTMP = versiones.get(j);
						if(!versTMP.getVersionKey().getIdSubProducto().equals(new Integer(0)))
							salida.add(getSubProducto(versiones.get(j), datEcoTMP));
					}else{
						//linea de producto
						salida.add(getProducto(versiones.get(j)));
						idProd = versiones.get(j).getVersionKey().getIdProducto();
						//linea de subproducto con sus datos
						VersionesC versTMP = versiones.get(j);
						if(!versTMP.getVersionKey().getIdSubProducto().equals(new Integer(0)))
							salida.add(getSubProducto(versiones.get(j), datEcoTMP));
					}
				}				
			}
			
		}
	}*/
	
	private BusquedaProductoObj getProducto(ProductoC prod) {
		//ProductoC prod = GestionProducto.obtenerProductoVersion(version.getVersionKey().getIdProducto(), version.getAn01tb01());
		BusquedaProductoObj obj = new BusquedaProductoObj();
		obj.setTipo(new Integer(1));
		obj.setIdProducto(prod.getProductoKey().getIdProducto());
		obj.setDescripcion(prod.getDescripcion());
		obj.setIdVersion(prod.getProductoKey().getIdVersion());
		return obj;
	}

	private BusquedaProductoObj getProducto(VersionObj version) {
		BusquedaProductoObj obj = new BusquedaProductoObj();
		obj.setTipo(new Integer(1));
		obj.setIdProducto(version.getVersionSubP().getIdProducto());
		obj.setDescripcion(version.getVersionSubP().getDescProd());
		obj.setIdVersion(version.getVersionSubP().getVersionProd());
		return obj;
	}
	
	public BusquedaProductoObj getSubProducto(VersionesC version) {
		GestionInteres gint = new GestionInteres();
		//GestionSubProducto gsub = new GestionSubProducto();
		
		BusquedaProductoObj obj = new BusquedaProductoObj();
			
		SubProductoC subprod = GestionSubProducto.obtenerSubProductoVersion(version.getVersionKey().getIdProducto(), 
				version.getVersionKey().getIdSubProducto(), version.getAn02tb01());
		if(subprod==null) {
			if (LOGGER.isDebugEnabled())
			{			
					LOGGER.debug("***************************             error en null ");
			}
		}
		else 
		{
			int estado = GestionSubProducto.obtenerEstadoBusquedaVersionSubproducto(version);
			obj.setEstado(new Integer(estado));
			obj.setIdVersion(version.getVersionKey().getIdVersionGeneral());
			
			obj.setTipo(new Integer(2));
			
			obj.setIdProducto(subprod.getSubProductoKey().getIdProducto());
			obj.setIdSubProducto(subprod.getSubProductoKey().getIdSubproducto());
			obj.setIdVersion(version.getVersionKey().getIdVersionGeneral());
			
			obj.setDescripcion(subprod.getSubProductoKey().getIdSubproducto() + " - " + subprod.getDescripcion());
			obj.setFechaDesde(subprod.getFechaDesdeVigencia());
			obj.setFechaHasta(subprod.getFechaHastaVigencia());
			
			
			List<InteresC> intereses = gint.obtenerInteresTodosOrden(version.getVersionKey().getIdProducto(), 
					version.getVersionKey().getIdSubProducto(), version.getAn07tb01(),version.getVersionKey().getIdColectivo());
			
			getInteresStringC(intereses, obj);
		}
		return obj;
	}
	
	public BusquedaProductoObj getSubProducto(VersionObj version) {
		//GestionInteres gint = new GestionInteres();
		//GestionSubProducto gsub = new GestionSubProducto();
		
		BusquedaProductoObj obj = new BusquedaProductoObj();
		
		int estado = GestionSubProducto.obtenerEstadoBusquedaVersionSubproducto(version);
		obj.setEstado(new Integer(estado));
		obj.setIdVersion(version.getVersionSubP().getVersionG());
		
		obj.setTipo(new Integer(2));
		
		obj.setIdProducto(version.getVersionSubP().getIdProducto());
		obj.setIdSubProducto(version.getVersionSubP().getIdSub2());
		
		obj.setDescripcion(version.getVersionSubP().getDescSub() );
		
		obj.setFechaDesde(version.getVersionSubP().getDateFechaInicio());
		
		obj.setFechaHasta(version.getVersionSubP().getDateFechaFin());
		
		obj.setFechaHastaSubp(version.getVersionSubP().getDateFechaFinSubp());
		
		obj.setDestino(version.getVersionSubP().getDestino());
		obj.setPlazoTotal(version.getVersionSubP().getPlazoEco());
		
		getInteresString(version.getIntereses(), obj);
		
		return obj;
	}
	
	//sin usar
//	public BusquedaProductoObj getSubProducto(VersionesC version, DatEcoC datEcoTMP) {
//		GestionInteres gint = new GestionInteres();
//		//GestionSubProducto gsub = new GestionSubProducto();
//		
//		BusquedaProductoObj obj = new BusquedaProductoObj();
//			
//		SubProductoC subprod = GestionSubProducto.obtenerSubProductoVersion(version.getVersionKey().getIdProducto(), 
//				version.getVersionKey().getIdSubProducto(), version.getAn02tb01());
//		
//		SubProductoVO subVO = new SubProductoVO();
//		subVO.setDatos(subprod);
//		subVO.setFechaDesdeVersion(version.getFechaInicio());
//		subVO.setFechaHastaVersion(version.getFechaFin());
//		subVO.setHoraDesdeVersion(version.getHoraIncio());
//		subVO.setHoraHastaVersion(version.getHoraFin());
//		subVO.setVersionGeneralTrabajo(version.getVersionKey().getIdVersionGeneral());
//		
//		int estado = GestionSubProducto.obtenerEstadoBusquedaVersionSubproducto(version);
//		obj.setEstado(new Integer(estado));
//		obj.setIdVersion(version.getVersionKey().getIdVersionGeneral());
//		
//		obj.setTipo(new Integer(2));
//		obj.setIdProducto(subprod.getSubProductoKey().getIdProducto());
//		obj.setIdSubProducto(subprod.getSubProductoKey().getIdSubproducto());
//		obj.setIdVersion(version.getVersionKey().getIdVersionGeneral());
//		
//		obj.setDescripcion(subprod.getSubProductoKey().getIdSubproducto() + " - " + subprod.getDescripcion());
//		obj.setFechaDesde(subprod.getFechaDesdeVigencia());
//		obj.setFechaHasta(subprod.getFechaHastaVigencia());
//		
//		
//		List<InteresC> intereses = gint.obtenerInteresTodosOrden(version.getVersionKey().getIdProducto(), 
//				version.getVersionKey().getIdSubProducto(), version.getAn07tb01(),null);
//		
//		getInteresStringC(intereses, obj);
//		
//		String destino = getDestinoString(datEcoTMP);
//		obj.setDestino(destino);
//		
//		Integer splazo = getPlazo(datEcoTMP);
//		obj.setPlazoTotal(splazo);
//
//		return obj;
//	}
	
//	
//	/**
//	 * @param version
//	 * @return
//	 */
//	private Integer getPlazo(DatEcoC dat)
//	{
//		// TODO Auto-generated method stub
//		return dat.getPlazo();
//	}
//
//	/**
//	 * @param version
//	 * @return
//	 */
//	private String getDestinoString(DatEcoC datEco)
//	{
//		// TODO Auto-generated method stub
//		//OBTENER PRIMERO LOS DATOS ECONOMICOS Y SACAR EL DESTINO PARA LUEGO SACAR LA DESCRIPCION EN LAS CLAUSULAS
//		String destino = null;
//	
//		GestionClausulasRestringuidas gclausulas = new GestionClausulasRestringuidas();
//		ParametrosC param = gclausulas.obtenerDestinoBusquedaProducto(datEco.getDestinoDefecto());
//		if(param != null){
//			destino = param.getCG320030();
//		}
//		return destino;
//	}
	
	/**
	 * @param intereses
	 * @return
	 */
	private String getInteresString(List<VersionSubpObj> intereses, BusquedaProductoObj obj)
	{
		// TODO Auto-generated method stub
		int num = intereses.size();
		
		switch(num) {
			case 0:	obj.setInteresDesc("sin interes");
				break;
			case 1:				
				if(!Utilidades.isBlankOrNull(intereses.get(0).getTipoInteres())) {
					if(intereses.get(0).getTipoInteres().equals("00")) {
						obj.setInteresDesc("Fijo");
					}else if(intereses.get(0).getTipoInteres().equals("01")) {
						obj.setInteresDesc("Fijo campañas");
					}else if(intereses.get(0).getTipoInteres().equals("02")) {
						obj.setInteresDesc("Variable");
					}else {
						obj.setInteresDesc("Sin interes");
					}
				}else {
					obj.setInteresDesc("Sin interes");
				}
					
				break;
				
			case 2:
				if(!Utilidades.isBlankOrNull(intereses.get(0).getTipoInteres()) && !Utilidades.isBlankOrNull(intereses.get(1).getTipoInteres())) {
					
					if(intereses.get(0).getTipoInteres().equals("00") && intereses.get(1).getTipoInteres().equals("02"))
					{
						obj.setInteresDesc("Variable, inicial fijo");
					}
					else
					{
						VersionSubpObj mayor = getInteresMayorPlazoSp(intereses);
						if(mayor.getTipoInteres().equals("00")) {
							obj.setInteresDesc("Fijo");
						}else if(mayor.getTipoInteres().equals("01")) {
							obj.setInteresDesc("Fijo campañas");
						}
						else if(mayor.getTipoInteres().equals("02"))
						{
							obj.setInteresDesc("Variable");
						}
						else if(mayor.getTipoInteres().equals("03"))
						{
							obj.setInteresDesc("Variable bonificable");
						}
						else if(mayor.getTipoInteres().equals("04"))
						{
							obj.setInteresDesc("Variable penalizable");
						}
						else if(mayor.getTipoInteres().equals("05"))
						{
							obj.setInteresDesc("Variable en campañas");
						}
						else{
							obj.setInteresDesc("Fijo referenciado");
						}	
					}
				}else {
					obj.setInteresDesc("Sin interes");
				}
				break;
			default:			
				VersionSubpObj mayor = getInteresMayorPlazoSp(intereses);
				if(mayor.getTipoInteres()!=null) {
				if(mayor.getTipoInteres().equals("00")) {
					obj.setInteresDesc("Fijo");
				}else if(mayor.getTipoInteres().equals("01")) {
					obj.setInteresDesc("Fijo campañas");
				}
				else if(mayor.getTipoInteres().equals("02"))
				{
					obj.setInteresDesc("Variable");
				}
				else if(mayor.getTipoInteres().equals("03"))
				{
					obj.setInteresDesc("Variable bonificable");
				}
				else if(mayor.getTipoInteres().equals("04"))
				{
					obj.setInteresDesc("Variable penalizable");
				}
				else if(mayor.getTipoInteres().equals("05"))
				{
					obj.setInteresDesc("Variable en campañas");
				}
				else{
					obj.setInteresDesc("Fijo referenciado");
				}
				}else {
					obj.setInteresDesc("Sin intereses");
				}
				
				break;
		}

		return obj.getInteresDesc();
	}
	
	/**
	 * @param intereses
	 * @return
	 */
	private String getInteresStringC(List<InteresC> intereses, BusquedaProductoObj obj)
	{
		// TODO Auto-generated method stub
		int num = intereses.size();
		
		switch(num) {
			case 0:	obj.setInteresDesc("sin interes");
				break;
			case 1:
				InteresC interes = intereses.get(0);

				if(interes.getTipo().equals("00")) {
					obj.setInteresDesc("fijo");
				}else if(interes.getTipo().equals("01")) {
					obj.setInteresDesc("fijo campañas");
				}else if(interes.getTipo().equals("02")) {
					obj.setInteresDesc("variable");
				}		
				break;
				
			case 2:
				InteresC interes1 = intereses.get(0);
				InteresC interes2 = intereses.get(1);

				if(interes1.getTipo().equals("00") && interes2.getTipo().equals("02"))
				{
					obj.setInteresDesc("Variable, inicial fijo");
				}
				else
				{
					InteresC mayor = getInteresMayorPlazo(intereses);
					if(mayor.getTipo().equals("00")) {
						obj.setInteresDesc("fijo");
					}else if(mayor.getTipo().equals("01")) {
						obj.setInteresDesc("fijo campañas");
					}
					else if(mayor.getTipo().equals("02"))
					{
						obj.setInteresDesc("Variable");
					}
					else if(mayor.getTipo().equals("03"))
					{
						obj.setInteresDesc("Variable bonificable");
					}
					else if(mayor.getTipo().equals("04"))
					{
						obj.setInteresDesc("Variable penalizable");
					}
					else if(mayor.getTipo().equals("05"))
					{
						obj.setInteresDesc("Variable en campañas");
					}
					else{
						obj.setInteresDesc("Fijo referenciado");
					}

				}
				break;
			default:			
				InteresC mayor = getInteresMayorPlazo(intereses);
				if(mayor.getTipo().equals("00")) {
					obj.setInteresDesc("fijo");
				}else if(mayor.getTipo().equals("01")) {
					obj.setInteresDesc("fijo campañas");
				}
				else if(mayor.getTipo().equals("02"))
				{
					obj.setInteresDesc("Variable");
				}
				else if(mayor.getTipo().equals("03"))
				{
					obj.setInteresDesc("Variable bonificable");
				}
				else if(mayor.getTipo().equals("04"))
				{
					obj.setInteresDesc("Variable penalizable");
				}
				else if(mayor.getTipo().equals("05"))
				{
					obj.setInteresDesc("Variable en campañas");
				}
				else{
					obj.setInteresDesc("Fijo referenciado");
				}
				break;
		}

		return obj.getInteresDesc();
	}
	
	
	
	private VersionSubpObj getInteresMayorPlazoSp (List<VersionSubpObj> intereses) {
		VersionSubpObj salida = intereses.get(0);
		Integer plazo=new Integer(0);
		for(int i=0; i< intereses.size(); i++) {
			VersionSubpObj tmp = intereses.get(i);
			Integer tmpPlazo = tmp.getPlazo();
			//
			if(tmpPlazo!= null && tmpPlazo.intValue() > plazo.intValue()) {
				plazo = tmpPlazo;
				salida = tmp;
			}
		}
		return salida;
	}
	
	private InteresC getInteresMayorPlazo (List<InteresC> intereses) {
		InteresC salida = intereses.get(0);
		Integer plazo=new Integer(0);
		for(int i=0; i< intereses.size(); i++) {
			InteresC tmp = intereses.get(i);
			Integer tmpPlazo = tmp.getPlazo();
			if(tmpPlazo.equals(new Integer(0))) {
				tmpPlazo = tmp.getPlazoHasta();
			}
			if(tmpPlazo.intValue() > plazo.intValue()) {
				plazo = tmpPlazo;
				salida = tmp;
			}
		}
		return salida;
	}
	
	private void construyeSalida(List<VersionSubpObj> datos, Vector<BusquedaProductoObj> salida) {
		Integer idProd=null, versProd=null, idSub=null, versSub=null, versGen=null;
		//List<VersionSubpObj>  listSub = new Vector<VersionSubpObj>();		
		List<VersionObj>  vers = new Vector<VersionObj>();
		VersionObj rama = new VersionObj();
		int contadorPasadas = 0;
		
		//quito colectivos....
		for(int  i=datos.size()-1; i>=0; i--) {
			VersionSubpObj subp = datos.get(i);
			if(!subp.getColectivo().equals(new Integer(0))) {
				datos.remove(i);
			}
		}		
		
		
		for(int i=0; i<datos.size(); i++) {

			VersionSubpObj subp = datos.get(i);
			if(i==0) {
				idProd = subp.getIdProducto(); // (Integer) tmp[0];
				idSub = subp.getIdSubprod1(); //(Integer) tmp[1];
				versProd = subp.getVersionProd(); //(Integer) tmp[4];
				versSub = subp.getVersionSubp(); //(Integer) tmp[5];				
				versGen = subp.getVersionG();
				//añado version a lista
				//añado interes
				
				rama.setVersionSubP(subp);
				rama.addInteres(subp);
				
				//vers.add(rama);
				//listSub.add();
				
			}else {
				if(idProd.equals(subp.getIdProducto())&&versProd.equals(subp.getVersionProd())) { //mismo producto
					if(idSub.equals( subp.getIdSubprod1()) && versSub.equals(subp.getVersionSubp()) && versGen.equals(subp.getVersionG())) 
					{ //mismo subproducto con misma versión
						if(contadorPasadas<Constantes.CTE_NUMERO_PASADAS+1) {
							//añado interes a la lista
							rama.addInteres(subp);
						}				
					}else if(idSub.equals( subp.getIdSubprod1())){ //mismo subproducto distinta version
						
//						if(!subp.getIndEnCurso().equals("00")) {
//							contadorPasadas = 0;
//						}
						
						if(contadorPasadas<Constantes.CTE_NUMERO_PASADAS) {
							//añado version anterior a la lista
							vers.add(rama);
							eliminaCeros(vers, rama);
							
							//construyo nueva rama con la version actual
							rama = new VersionObj();
							rama.setVersionSubP(subp);
							rama.addInteres(subp);			
							
							versSub = subp.getVersionSubp(); //(Integer) tmp[5];
							versGen = subp.getVersionG();
							
							Date fechaHoy = new Date(DateUtils.getSoloFecha(DateUtils.dateNow()).getTime());							
							Time horaHoy = DateUtils.getSoloHorario(DateUtils.dateNow());							
							if((DateUtils.isDateGreater(fechaHoy, subp.getDateFechaFin()) && !subp.getDateFechaFin().equals(
									new Date(DateUtils.parseDate(DateUtils.CTE_DATELOWESTONLYDAY, 
									DateUtils.FORMATO_FECHA_AMERICANO).getTime())))
									|| fechaHoy.equals(subp.getDateFechaFin()) && DateUtils.isDateGreater(horaHoy, subp.getTimeHoraFin())) 		
							{
								contadorPasadas ++;
							}
						}else {
							versSub = subp.getVersionSubp(); //(Integer) tmp[5];
							versGen = subp.getVersionG();
							contadorPasadas++;
						}						
					}else { //distinto subproducto
						
						contadorPasadas = 0;
						//añado subproducto a la lista
						vers.add(rama);	
						eliminaCeros(vers, rama);
						
						rama = new VersionObj();						
						rama.setVersionSubP(subp);
						rama.addInteres(subp);
						
						versProd = subp.getVersionProd(); //(Integer) tmp[4];
						versSub = subp.getVersionSubp(); //(Integer) tmp[5];
						idSub =  subp.getIdSubprod1();
						versGen = subp.getVersionG();
					}
				}else if(idProd.equals(subp.getIdProducto())) { //mismo producto distinta version
					
					contadorPasadas = 0;					
					//construyo rama de arbol producto-subproductos
					vers.add(rama);
					eliminaCeros(vers, rama);
					construyeRama(salida, vers);
					
					vers = new Vector<VersionObj>();
					rama = new VersionObj();
					rama.setVersionSubP(subp);
					rama.addInteres(subp);
					
					idProd = subp.getIdProducto(); //(Integer) tmp[0];
					idSub =  subp.getIdSubprod1(); //(Integer) tmp[1];
					
					versSub = subp.getVersionSubp(); //(Integer) tmp[5];
					versGen = subp.getVersionG();
					//añado subproducto a lista
					
				}else {	// distinto producto
					contadorPasadas = 0;
					//construyo rama de arbol producto-subproductos (quitando los ceros)
					//añado version a lista
					//añado interes
					vers.add(rama);
					eliminaCeros(vers, rama);
					construyeRama(salida, vers);
					vers = new Vector<VersionObj>();
					rama = new VersionObj();
					rama.setVersionSubP(subp);
					rama.addInteres(subp);					
					
					idProd = subp.getIdProducto(); //(Integer) tmp[0];
					idSub =  subp.getIdSubprod1(); //(Integer) tmp[1];
					
					versSub = subp.getVersionSubp(); //(Integer) tmp[5];
					versGen = subp.getVersionG();
				}
			}
		}
		if(datos.size()>0) {
			vers.add(rama);
			eliminaCeros(vers, rama);
			construyeRama(salida, vers);
		}
		
	}
	
	private void eliminaCeros(List<VersionObj> listaSubp, VersionObj rama) {
		if(rama.getVersionSubP() != null) {
			if(!rama.getVersionSubP().getIdSubprod1().equals(new Integer(0))) {
				listaSubp.remove(VersionObj.getCero(listaSubp, rama));
			}
		}
		
	}
	
	private void construyeRama(Vector<BusquedaProductoObj> salida, List<VersionObj> listaSubp) {		
		//añadir subproductos
		VersionObj tmp = null;
		if(listaSubp.size()>0) {
			tmp = listaSubp.get(0);
			//añadir un producto
			salida.add(getProducto(tmp));
			for(int i=0; i<listaSubp.size(); i++) {
				//añadir subproducto
				salida.add(getSubProducto(listaSubp.get(i)));
			}
		}
	}
}
