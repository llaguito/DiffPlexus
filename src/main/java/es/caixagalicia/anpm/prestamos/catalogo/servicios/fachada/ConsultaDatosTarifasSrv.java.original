package es.caixagalicia.anpm.prestamos.catalogo.servicios.fachada;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import es.caixagalicia.anpm.prestamos.catalogo.persistencia.tarifa.TarifaC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.tarifa.TarifaEng;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.version.VersionesC;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionVersiones;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Utilidades;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionConsultaDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.contextos.ContextoFactory;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.IRegistro;
import es.caixagalicia.ifrt.core.ServicioNegocio;


/**
 * @author V361749
 * CO: ANPM_473
 * CONTX: ANPMN473
 * TRANSX: ANS3
 * 
 * Servicio que consultara los datos de las tarifas de un producto.
 */

public class ConsultaDatosTarifasSrv extends ServicioNegocio 
{
	private static final String CTE_ENTRADA_COD_PRODUCTO 	= "COD_PRODUCTO";
	private static final String CTE_ENTRADA_COD_SUBPRODUCTO = "COD_SUBPRODUCTO";
	private static final String CTE_ENTRADA_ID_TARIFA 		= "ID_TARIFA";
	private static final String CTE_ENTRADA_FECHA_VALIDEZ 	= "FECHA_VALIDEZ";
	private static final String CTE_ENTRADA_COLECTIVO 		= "COLECTIVO";
	private static final String CTE_ENTRADA_PLAZO			= "PLAZO";
	private static final String CTE_ENTRADA_IMPORTE			= "IMPORTE";
	
	private static final String CTE_ID_TARIFA 				= "ID_TARIFA";
	private static final String CTE_COD_PRODUCTO 			= "COD_PRODUCTO";
	private static final String CTE_COD_SUBPRODUCTO 		= "COD_SUBPRODUCTO";
	
	private static final String CTE_PASO 					= "Paso";
	private static final String CTE_CODIGO_PRODUCTO			= "Codigo_producto";
	private static final String CTE_CODIGO_SUBPRODUCTO		= "Codigo_subproducto";
	private static final String CTE_COLECTIVO				= "Colectivo";
	private static final String CTE_VERSION_GENERAL			= "Version_general";
	private static final String CTE_VERSION_GENERAL443		= "VERSION_GENERAL";
	private static final String CTE_UNO 					= "1";
	private static final String CTE_CERO 					= "0";
	
	
	private static final int CUENTA_CONTABLE			 	= 507;
	private static final int CO_CONSULTA_PRECIOS_TARIFA	 	= 443;
	private static final int CO_CONSULTA_SERVICIO_048 		= 48;
	private static final int CO_CONSULTA_SERVICIO_458 		= 458;

	private static final BigDecimal CTE_PASO_CERO			= BigDecimal.ZERO;


	@Override
	public IContexto[] ejecutar(IContextoEjecucion contextoEjecucion, IDatosEntradaTx datosEntrada) 
	{
		// Inicializaciones variables
		IContexto[] resultado        = new IContexto[0];
		List<IContexto>listResultado = new ArrayList<IContexto>();
		IContexto[] anpm442			= null;
		IContexto ctxSubpro 		= null;
		BigDecimal codProducto 		= null;
		BigDecimal codSubproducto 	= null;
		BigDecimal idTarifa 		= null;
		String strFechaValidez 		= null;
		BigDecimal colectivo		= null;
		String tieneTarifas 		= "";
		BigDecimal versionGeneral 	= null;
		BigDecimal plazo			= null;
		BigDecimal importe			= null;
	
		// Establecemos el diario electrónico
		contextoEjecucion.setDiarioElectronico(new DiarioElectronico(DiarioElectronico.TIPO_CONSULTA));

		// Obtenemos las entradas
		codProducto 	= datosEntrada.getDecimal(CTE_ENTRADA_COD_PRODUCTO);
		codSubproducto 	= datosEntrada.getDecimal(CTE_ENTRADA_COD_SUBPRODUCTO);
		idTarifa 		= datosEntrada.getDecimal(CTE_ENTRADA_ID_TARIFA);
		strFechaValidez = datosEntrada.getString(CTE_ENTRADA_FECHA_VALIDEZ);
		colectivo 		= datosEntrada.getDecimal(CTE_ENTRADA_COLECTIVO);
		plazo 			= datosEntrada.getDecimal(CTE_ENTRADA_PLAZO);
		importe			= datosEntrada.getDecimal(CTE_ENTRADA_IMPORTE);
		

		// ***Lógica del servicio***

		if (null == colectivo) // en caso de que no informen el colectivo entonces se seteará a cero.
		{
			colectivo = BigDecimal.ZERO;
		}

		if (null != strFechaValidez && !Utilidades.isBlankOrNull(strFechaValidez)) // si la fecha viene informada en los campos de entrada
		{
			versionGeneral = GestionConsultaDatosSolicitud.obtenerVersionGeneralFecha(codProducto, codSubproducto, strFechaValidez);
		}
		else
		{
			versionGeneral = GestionConsultaDatosSolicitud.obtenerVersionGeneralOptimizada(codProducto, codSubproducto);
		}

		// Llamada al ANPM_048 para poder obtener el contexto ANPMN002 -> este contexto se obtiene en el  paso 0
		IContexto[] salida048 = invocacionServicio048(codProducto, codSubproducto, colectivo, versionGeneral, CTE_PASO_CERO); 
		ctxSubpro 		  = UtilidadesTramitacion.getContexto(salida048, "ANPMN002"); 
		tieneTarifas 	  = ctxSubpro.getString("ANPMN002670"); // comprobamos si el subproducto tiene tarifas

		if (CTE_UNO.equals(tieneTarifas)) //--> producto con tarifas
		{	
			if (null != idTarifa) // si la tarifa viene informada en los campos de entrada
			{
				IContexto[] resultado443 = invocacionServicio443(codProducto, codSubproducto, idTarifa, versionGeneral);
				IContexto[] nuevaSalida048 = sobreescribirValoresInteresYComision(salida048, resultado443);
				listResultado = rellenarContextoS(nuevaSalida048, colectivo, idTarifa, resultado443, tieneTarifas);

			}
			else // si la tarifa no viene informada
			{
				//consultar la tabla ANTATB01 llamando al ANPM_451 y devuelve --> ANPMN442
				anpm442 = Utilidades.obtenerTarifas(codProducto, codSubproducto, versionGeneral, null); 
				IContexto resultadoANPM442 = UtilidadesTramitacion.getContexto(anpm442, "ANPMN442");

				// por cada id de tarifa recuperado en el ANPM_442 llamamos al ANPM_443
				BigDecimal error = BigDecimal.ZERO;
				
				for(IRegistro reg442 : resultadoANPM442.getRegistro("ANPMN442010"))
				{
					IContexto[] resultado443 = invocacionServicio443(codProducto, codSubproducto, reg442.getBigDecimal("ANPMN442011"),
																		versionGeneral);
					// se hace una copia de la salida del 048 para sobreescribirla tantas veces como tarifas  
					// devuelva el 443
					//IContexto[] salida048bis = invocacionServicio048(codProducto, codSubproducto, colectivo, versionGeneral, CTE_PASO_CERO); 
					IContexto[] salida048bis = copy(salida048, error);
					
					if ((null == salida048bis) && (0 == BigDecimal.ONE.compareTo(error)))
					{
						// Error creando copia de la salida del ANPM_048
						ServicioNegocio.rollback(
							new Integer(13455), 
							new String[]{}, 
							new String[]{}, 
							new String[]{});
					}
					
					IContexto[] nuevaSalida048 = sobreescribirValoresInteresYComision(salida048bis, resultado443);
					
					listResultado.addAll(rellenarContextoS(nuevaSalida048, colectivo, reg442.getBigDecimal("ANPMN442011"), resultado443, tieneTarifas));
				}
			}
		}
		else  // en caso de que no necesite tarifa
		{	
			listResultado = rellenarContextoS(salida048, colectivo, idTarifa, null, tieneTarifas);
		} 
		
		// 20170110 Se filtra la lista resultante si el plazo y el importe vienen informados
		if ((null != importe) && (null != plazo))
		{
			listResultado = filtrarResultado (listResultado, importe, plazo);
		}
		
		resultado = listResultado.toArray(new IContexto[listResultado.size()]);
	  
		return resultado;
	}


	/**
	 * Método que llama al servicio ANPM_443
	 * @param producto
	 * @param subproducto
	 * @param tarifa
	 * @parama fecha 
	 * 
	 */
	private IContexto[] invocacionServicio443 (BigDecimal producto, BigDecimal subproducto, BigDecimal tarifa, BigDecimal versionGeneral)
	{
		String CTE_VALOR_ORIGEN = "ORIGEN_CONSULTA";
		BigDecimal origen = BigDecimal.ZERO;

		// invocación a servicio ANPM_443
		IContextoEjecucion contexto = ServicioNegocio.getContexto();
		IDatosEntradaTx parametros = ServicioNegocio.getPrograma(
				contexto, CUENTA_CONTABLE, CO_CONSULTA_PRECIOS_TARIFA);
		parametros.addCampo(CTE_ENTRADA_COD_PRODUCTO, producto);
		parametros.addCampo(CTE_ENTRADA_COD_SUBPRODUCTO, subproducto);
		parametros.addCampo(CTE_ENTRADA_ID_TARIFA, tarifa);
		parametros.addCampo(CTE_VERSION_GENERAL443, versionGeneral);
		parametros.addCampo(CTE_VALOR_ORIGEN, origen); // 0: simulacion 1: solicitud

		IContexto[] datosSalida = ServicioNegocio.invocarServicio(contexto, parametros);

		return datosSalida;
	}	

	
	/**
	 * Método que llama al servicio ANPM_048
	 * @param producto
	 * @param subproducto
	 * @param tarifa
	 * @parama paso 
	 * 
	 */
	private IContexto[] invocacionServicio048 (BigDecimal producto, BigDecimal subproducto, BigDecimal colectivo, BigDecimal versionGeneral, BigDecimal paso)
	{
		// invocación del servicio ANPM_048
		IContextoEjecucion contexto = ServicioNegocio.getContexto();
		IDatosEntradaTx entrada048 = getPrograma(contexto, CUENTA_CONTABLE, CO_CONSULTA_SERVICIO_048);
		entrada048.addCampo(CTE_CODIGO_PRODUCTO, producto);
		entrada048.addCampo(CTE_CODIGO_SUBPRODUCTO, subproducto);
		entrada048.addCampo(CTE_COLECTIVO, colectivo);
		entrada048.addCampo(CTE_VERSION_GENERAL, versionGeneral);
		entrada048.addCampo(CTE_PASO, paso);

		IContexto[] salida048 =  invocarServicio(contexto, entrada048);

		return salida048;
	}

	
	/**
	 * Método que llama al servicio ANPM_458
	 * 
	 * @param idTarifa
	 * @return descripción tarifa
	 */
	//private String invocacionServicio458 (BigDecimal idTarifa)
	private String invocacionServicio458 (BigDecimal producto, BigDecimal subProducto, BigDecimal idTarifa)
	{
		// Invocación del servicio ANPM_458
		IContextoEjecucion contexto = ServicioNegocio.getContexto();
		IDatosEntradaTx entrada458 = getPrograma(contexto, CUENTA_CONTABLE, CO_CONSULTA_SERVICIO_458);
		
		entrada458.addCampo(CTE_COD_PRODUCTO, producto);
		entrada458.addCampo(CTE_COD_SUBPRODUCTO, subProducto);
		entrada458.addCampo(CTE_ID_TARIFA, idTarifa);

		IContexto[] salida458 =  invocarServicio(contexto, entrada458);
		String strSalida458 = salida458[0].getString("ANPMN458020");

		return strSalida458;
	}


	/**
	 * Método que rellena un contexto ANPMN473 con los parámetros que se le pasan de entrada 
	 * 
	 * @param idProductoDev
	 * @param desProductoDev
	 * @param idSubProductoDev
	 * @param desSubProductoDev
	 * @param tarifa
	 * @param descripcionTarifa
	 * @param plazoMinimo
	 * @param plazoMaximo
	 * @param importeMinimo
	 * @param importeMaximo
	 * @param valorEstandar
	 * @param valorDesde
	 * @param valorHasta
	 * @param ordenTramo
	 * @param tipoTramo
	 * @param nivel
	 * @param idCondicion
	 * @param tipoCondicion
	 * @param colectivo
	 * @param descripcionTipo
	 * @return
	 */
	private IContexto rellenarSalida(BigDecimal idProductoDev, String desProductoDev, BigDecimal idSubProductoDev, String desSubProductoDev, BigDecimal tarifa,
			String descripcionTarifa, BigDecimal plazoMinimo, BigDecimal plazoMaximo, BigDecimal importeMinimo, BigDecimal importeMaximo,
			BigDecimal valorEstandar, BigDecimal valorDesde, BigDecimal valorHasta, BigDecimal ordenTramo, String tipoTramo, BigDecimal nivel,
			String idCondicion, String tipoCondicion, BigDecimal colectivo, String descripcionTipo, BigDecimal indPermiteFinanciarComision, 
			BigDecimal plazoCarenciaDesde, BigDecimal plazoCarenciaHasta)
	{
		IContexto resultado = ContextoFactory.getInstance().getContexto("ANPMN473");
		resultado.put("ANPMN473010", idProductoDev);
		resultado.put("ANPMN473020", desProductoDev); 	
		resultado.put("ANPMN473030", idSubProductoDev);
		resultado.put("ANPMN473040", desSubProductoDev);
		resultado.put("ANPMN473050", BigDecimal.ZERO); //(deprecated)
		resultado.put("ANPMN473060", descripcionTarifa);
		resultado.put("ANPMN473070", plazoMinimo);
		resultado.put("ANPMN473080", plazoMaximo);
		resultado.put("ANPMN473090", importeMinimo);
		resultado.put("ANPMN473100", importeMaximo);
		resultado.put("ANPMN473110", valorEstandar);
		resultado.put("ANPMN473120", valorDesde);
		resultado.put("ANPMN473130", valorHasta);
		resultado.put("ANPMN473140", ordenTramo);
		resultado.put("ANPMN473141", descripcionTipo);
		resultado.put("ANPMN473150", tipoTramo);
		resultado.put("ANPMN473160", nivel);
		resultado.put("ANPMN473170", idCondicion);
		resultado.put("ANPMN473180", tipoCondicion);
		resultado.put("ANPMN473190", colectivo);
		resultado.put("ANPMN473200", indPermiteFinanciarComision);
		resultado.put("ANPMN473210", tarifa);
		resultado.put("ANPMN473220", plazoCarenciaDesde);
		resultado.put("ANPMN473230", plazoCarenciaHasta);

		return resultado;
	}
	
	
	/**
	 * Método que recorre los contextos de salida del servicio ANPM_048 y los 
	 * transforma en contextos ANPMN473.
	 * 
	 * @param contextos de salida del servicio ANPM_048
	 * @param colectivo colectivo recibido como entrada
	 * @param idTarifa id de tarifa para la que se estan obteniendo los valores.
	 * @param salida443 contextos de salida del servicio ANPM_443.
	 * 
	 * @return array de contextos ANPMN473
	 * 
	 * */
	private List<IContexto> rellenarContextoS(IContexto[] contexto048, BigDecimal colectivo, 
			BigDecimal idTarifa, IContexto[] salida443, String tieneTarifas)
	{
		List<IContexto> lista473	= new ArrayList<IContexto>();

		BigDecimal valorEstandar 	= null;
		BigDecimal valorDesde    	= null;
		BigDecimal valorHasta    	= null;
		String idCondicion		    = "";
		BigDecimal ordenTramo	 	= null;
		String tipoTramo			= "";
		String tipoCondicion		= "";
		BigDecimal nivel			= null;
		BigDecimal plazoMinimo		= null;
		BigDecimal plazoMaximo		= null;
		BigDecimal importeMinimo 	= null;
		BigDecimal importeMaximo 	= null;
		BigDecimal idProductoDev	= null;
		String desProductoDev 		= "";
		BigDecimal idSubProductoDev = null;
		String desSubProductoDev 	= "";
		String descripcionTipo		= "";
		IContexto[] ctx014			= null;
		IContexto[] ctx015			= null;
		IContexto ctx013			= null;
		IContexto[] ctx005			= null;
		IContexto ctxSubpro 		= null;
		IContexto ctxProducto       = null;
		String descripcionTarifa    = "";
		BigDecimal idRelacion = null;
		BigDecimal indPermiteFinanciarComision = null;
		BigDecimal plazoCarenciaDesde = null;
		BigDecimal plazoCarenciaHasta = null;
		
		
		// Obtenemos los contextos del array de parámetros de entrada 048
		ctxProducto = UtilidadesTramitacion.getContexto(contexto048, "ANPMN001"); 
		ctxSubpro   = UtilidadesTramitacion.getContexto(contexto048, "ANPMN002"); 
		ctx005	    = UtilidadesTramitacion.getContextos(contexto048, "ANPMN005"); 
		ctx013      = UtilidadesTramitacion.getContexto(contexto048,  "ANPMN013");
		ctx014	    = UtilidadesTramitacion.getContextos(contexto048, "ANPMN014");
		ctx015	    = UtilidadesTramitacion.getContextos(contexto048, "ANPMN015");

		
		/*
		 * Datos comunes: 
		 * - Leidos de catalogo: producto, descripcion, subproducto, descripcion.
		 * - De entrada: tarifa, colectivo.
		 * - Obtenidos: descripcion tarifa.
		 */
		idProductoDev  	  = ctxProducto.getBigDecimal ("ANPMN001010");
		desProductoDev 	  = ctxProducto.getString	  ("ANPMN001030");
		idSubProductoDev  = ctxSubpro.getBigDecimal	  ("ANPMN002020");
		desSubProductoDev = ctxSubpro.getString		  ("ANPMN002040");
		
		if (null != idTarifa)
		{
			// 2016-08-08 - Llamar al servicio con producto, subproducto y tarifa
			//descripcionTarifa= invocacionServicio458(idTarifa);
			descripcionTarifa= invocacionServicio458(idProductoDev, idSubProductoDev, idTarifa);
			
		}

		
		/* Recorremos el contexto ANPMN014 (intereses). Cada contexto de intereses genera
		 * un contexto ANPMN473 de salida.
		 */
		for (IContexto dat014: ctx014)
		{
			idCondicion = "INT";
			tipoCondicion = "DEHA";
			
			// Para nivel oficina (0 o 10) e interés fijo 
			if( ((0 == dat014.getBigDecimal("ANPMN014050").compareTo(Constantes.CTE_BID_NIVEL_OFICINA)) || 
				 (0 == dat014.getBigDecimal("ANPMN014050").compareTo(Constantes.CTE_BID_NIVEL_TODOS))) && 
				(("00").equals(dat014.getString("ANPMN014070")) || 
				 ("01").equals(dat014.getString("ANPMN014070")) || 
				 ("06").equals(dat014.getString("ANPMN014070"))) )
			{
				tipoTramo = dat014.getString("ANPMN014070");
				descripcionTipo = "Fijo";

				valorEstandar = dat014.getBigDecimal("ANPMN014150");
				valorDesde 	  = dat014.getBigDecimal("ANPMN014160");
				valorHasta 	  = dat014.getBigDecimal("ANPMN014170");
				nivel 		  = dat014.getBigDecimal("ANPMN014050");
				ordenTramo    = dat014.getBigDecimal("ANPMN014060");
			}
			else // el interés es variable
			{
				for (IContexto dat015: ctx015)
				{
					// Para nivel oficina (0 o 10) y mismo orden
					if( (0 == (dat014.getBigDecimal("ANPMN014060").compareTo(dat015.getBigDecimal("ANPMN015060")))) && 
					    (((0 == dat015.getBigDecimal("ANPMN015050").compareTo(Constantes.CTE_BID_NIVEL_OFICINA))) || 
					     ((0 == dat015.getBigDecimal("ANPMN015050").compareTo(Constantes.CTE_BID_NIVEL_TODOS)))) )
					{
						if (0 == (BigDecimal.ZERO).compareTo(dat015.getBigDecimal("ANPMN015070"))) // interes == 0
						{
							tipoTramo = (dat015.getBigDecimal("ANPMN015060")).toString();
							descripcionTipo = "Variable";

							valorEstandar = dat015.getBigDecimal ("ANPMN015090");
							valorDesde 	  = dat015.getBigDecimal ("ANPMN015100");
							valorHasta 	  = dat015.getBigDecimal ("ANPMN015110");
							nivel 		  = dat015.getBigDecimal ("ANPMN015050");
							ordenTramo    = dat015.getBigDecimal ("ANPMN015060");
							
							break;
						}
					}
				}
			}
				
			// Obtener plazos e importes:
			// - Si el subproducto va por tarifas (salida443 != null) y el id de relacion de catalogo 
			//   esta en la salida del ANPM_443: se obtienen de la salida del ANPM_443
			// - Resto de casos: se obtienen de catalogo.
			if (null != ctx013)
			{
				plazoMinimo   = ctx013.getBigDecimal("ANPMN013210");
				plazoMaximo   = ctx013.getBigDecimal("ANPMN013220");
				importeMinimo = ctx013.getBigDecimal("ANPMN013170");
				importeMaximo = ctx013.getBigDecimal("ANPMN013180");
				plazoCarenciaDesde = ctx013.getBigDecimal("ANPMN013270");
				plazoCarenciaHasta = ctx013.getBigDecimal("ANPMN013280");
			}
			
			if (null != salida443)
			{				
				// Obtener id de relacion
				idRelacion = dat014.getBigDecimal("ANPMN014870");
				
				if (null != idRelacion)
				{
					// Obtener plazos e importes de la salida del ANPM_443 en funcion del id de relacion
					IRegistro plazosImportes = getPlazosImportes(salida443, idRelacion);
					
					
					if (!Utilidades.isBlankOrNull(plazosImportes.getBigDecimal("ANPMN443032"))){
						plazoMinimo = plazosImportes.getBigDecimal("ANPMN443032");
					}
					if (!Utilidades.isBlankOrNull(plazosImportes.getBigDecimal("ANPMN443033"))){
						plazoMaximo = plazosImportes.getBigDecimal("ANPMN443033");
					}
					if (!Utilidades.isBlankOrNull(plazosImportes.getBigDecimal("ANPMN443034"))){
						importeMinimo = plazosImportes.getBigDecimal("ANPMN443034");
					}
					if (!Utilidades.isBlankOrNull(plazosImportes.getBigDecimal("ANPMN443035"))){
						importeMaximo = plazosImportes.getBigDecimal("ANPMN443035");
					}					
				}
			}
			
			// Crear contexto ANPMN473 a partir de los datos obtenidos, y anhadir a la lista de contextos de salida
			lista473.add(rellenarSalida(idProductoDev, desProductoDev, idSubProductoDev, desSubProductoDev, idTarifa, descripcionTarifa, 
										plazoMinimo, plazoMaximo, importeMinimo, importeMaximo, valorEstandar, valorDesde, valorHasta,
										ordenTramo, tipoTramo, nivel, idCondicion, tipoCondicion, colectivo, descripcionTipo, 
										indPermiteFinanciarComision, plazoCarenciaDesde, plazoCarenciaHasta));
		}

		
		// 2017-11-09 - Hacer la llamada a tarifas para recuperar el idFinanciacion solo en caso
		// de que el subproducto vaya por tarifas. En caso contrario, se recupera el idFinanciacion
		// del contexto de comisiones (ANPMN005510)
		TarifaC tarifa = null;
		if (CTE_UNO.equals(tieneTarifas))
		{	
			// En todas las llamadas a rellenar salida, hay que meterle el idFinanciacion que se recupere de la ANTA0210 (confirma que es este el nuevo)
			// en lugar del que se está cogiendo actualmente (ANPMN0055510)
			TarifaEng daoTarifas = new TarifaEng(); 
			
			List<VersionesC> versiones = GestionVersiones.obtenerVersionesSubProducto(
																				idProductoDev.intValue(), 
																				idSubProductoDev.intValue(), 
																				colectivo.intValue());
	
			if(null == versiones
			|| 0 == versiones.size()
			|| null == versiones.get(0)
			|| null == versiones.get(0).getAn02tb01())
			{
				ServicioNegocio.rollback(
										new Integer(13678), 
										null,
										new String[]{idProductoDev.toString(), 
													 idSubProductoDev.toString(),
													 "",
													 colectivo.toString()}, 
										null);
			}
	
			tarifa = daoTarifas.obtenerTarifa(
											idProductoDev, // Producto 
											idSubProductoDev, // SubProducto 
											new BigDecimal(versiones.get(0).getAn02tb01()), // Versión 
											idTarifa);
			 
			if(null == tarifa
			|| null == tarifa.getIndicadorFinanciacion()) 
			{
				ServicioNegocio.rollback(
										new Integer(12874), 
										null,
										new String[]{idProductoDev
											 + "-" + idSubProductoDev
											 + "-" + versiones.get(0).getAn02tb01()
											 + "-" + idTarifa}, 
										null);
			}
		}
		
		/*
		 * Recorremos el contexto ANPMN005 (comisiones). Cada contexto de comisiones puede generar uno
		 * o dos contextos de salida (un contexto de tipo DEHA, o uno de tipo DEHA y otro de tipo MIN). 
		 * */
		for (IContexto dat005 : ctx005) // recorremos contexto 005 (contexto de comisiones)  
		{
			
			// Indicador de financiar comision
			if ((CTE_UNO.equals(tieneTarifas) && (null != tarifa)))
			{
				// Si el producto va por tarifas y se ha obtenido tarifa, el indicador de financiar
				// comision se lee de la tabla de tarifas (ANTATB01)
				indPermiteFinanciarComision = tarifa.getIndicadorFinanciacion();
			}
			else
			{
				// Si el producto no va por tarifas o va por tarifas y no se ha encontrado tarifa
				// el indicador de financiar comision se lee del contexto de comisiones
				indPermiteFinanciarComision = dat005.getBigDecimal("ANPMN005510");				
			}
			
			if (!((CTE_CERO).equals(dat005.getString("ANPMN005110")))) // si el indicador de porcentaje comisión es 0 entonces NO pintamos la comisión DEHA
			{
				idCondicion   = "COM";
				tipoCondicion = "DEHA"; // DEHA -> % 
				
				tipoTramo 	  = dat005.getString    ("ANPMN005060"); // Tipo Comision / Tipo Interés
				tipoTramo     = tipoTramo.substring(1);
				valorEstandar = dat005.getBigDecimal("ANPMN005080"); // porcentajeComisionEstandar
				valorDesde    = dat005.getBigDecimal("ANPMN005090"); // porcentajeComisionDesde
				valorHasta 	  = dat005.getBigDecimal("ANPMN005100"); // porcentajeComisionHasta
				
				ordenTramo 	  = dat005.getBigDecimal("ANPMN005070");
				nivel 		  = dat005.getBigDecimal("ANPMN005050");
				
				if (null != tipoTramo)
				{
					descripcionTipo = GestionConsultaDatosSolicitud.obtenerDescripcionTipoComision(tipoTramo);					
				}
				
				// Obtener plazos e importes:
				// - Si el subproducto va por tarifas (salida443 != null) y el id de relacion de catalogo 
				//   esta en la salida del ANPM_443: se obtienen de la salida del ANPM_443
				// - Resto de casos: se obtienen de catalogo.
				if (null != ctx013)
				{
					plazoMinimo   = ctx013.getBigDecimal("ANPMN013210");
					plazoMaximo   = ctx013.getBigDecimal("ANPMN013220");
					importeMinimo = ctx013.getBigDecimal("ANPMN013170");
					importeMaximo = ctx013.getBigDecimal("ANPMN013180");
					plazoCarenciaDesde = ctx013.getBigDecimal("ANPMN013270");
					plazoCarenciaHasta = ctx013.getBigDecimal("ANPMN013280");
				}
				
				if (null != salida443)
				{					
					// Obtener id de relacion
					//idRelacion = getIdRelacion(salida443, ordenTramo, tipoTramo, tipoCondicion, nivel, idCondicion);		
					idRelacion = dat005.getBigDecimal("ANPMN005520");
					
					if (null != idRelacion)
					{
						// Obtener plazos e importes de la salida del ANPM_443 en funcion del id de relacion
						IRegistro plazosImportes = getPlazosImportes(salida443, idRelacion);
						
						plazoMinimo = plazosImportes.getBigDecimal("ANPMN443032");
						plazoMaximo = plazosImportes.getBigDecimal("ANPMN443033");
						importeMinimo = plazosImportes.getBigDecimal("ANPMN443034");
						importeMaximo = plazosImportes.getBigDecimal("ANPMN443035");
					}
				}				
				
				// Crear contexto ANPMN473 a partir de los datos obtenidos, y anhadir a la lista de contextos de salida
				lista473.add(rellenarSalida(idProductoDev, desProductoDev, idSubProductoDev, desSubProductoDev, idTarifa, 
						descripcionTarifa, plazoMinimo, plazoMaximo, importeMinimo, importeMaximo, valorEstandar, valorDesde, 
						valorHasta, ordenTramo, tipoTramo, nivel, idCondicion, tipoCondicion, colectivo, descripcionTipo, 
						indPermiteFinanciarComision, plazoCarenciaDesde, plazoCarenciaHasta));	
			}

			if (!((CTE_CERO).equals(dat005.getString("ANPMN005190"))))// indicador de importe mínimo es != 0
			{
				idCondicion   = "COM";
				tipoCondicion = "MIN"; // MIN -> IMPORTE
				
				tipoTramo 	  = dat005.getString    ("ANPMN005060"); // Tipo Comision / Tipo Interés
				tipoTramo     = tipoTramo.substring(1);
				
				valorEstandar = dat005.getBigDecimal("ANPMN005160"); // importeMínimoEstandar
				valorDesde    =	dat005.getBigDecimal("ANPMN005170"); // importeMínimoDesde
				valorHasta    =	dat005.getBigDecimal("ANPMN005180"); // importeMínimoHasta
				
				ordenTramo 	  = dat005.getBigDecimal("ANPMN005070");
				nivel 		  = dat005.getBigDecimal("ANPMN005050");
				
				if (null != tipoTramo)
				{
					descripcionTipo = GestionConsultaDatosSolicitud.obtenerDescripcionTipoComision(tipoTramo);
				}

				// Obtener plazos e importes:
				// - Si el subproducto va por tarifas (salida443 != null) y el id de relacion de catalogo 
				//   esta en la salida del ANPM_443: se obtienen de la salida del ANPM_443
				// - Resto de casos: se obtienen de catalogo.
				if (null != ctx013)
				{
					plazoMinimo   = ctx013.getBigDecimal("ANPMN013210");
					plazoMaximo   = ctx013.getBigDecimal("ANPMN013220");
					importeMinimo = ctx013.getBigDecimal("ANPMN013170");
					importeMaximo = ctx013.getBigDecimal("ANPMN013180");
					plazoCarenciaDesde = ctx013.getBigDecimal("ANPMN013270");
					plazoCarenciaHasta = ctx013.getBigDecimal("ANPMN013280");
				}
				
				if (null != salida443)
				{					
					// Obtener id de relacion
					//idRelacion = getIdRelacion(salida443, ordenTramo, tipoTramo, tipoCondicion, nivel, idCondicion);
					idRelacion = dat005.getBigDecimal("ANPMN005520");
					
					if (null != idRelacion)
					{
						// Obtener plazos e importes de la salida del ANPM_443 en funcion del id de relacion
						IRegistro plazosImportes = getPlazosImportes(salida443, idRelacion);
						
						plazoMinimo = plazosImportes.getBigDecimal("ANPMN443032");
						plazoMaximo = plazosImportes.getBigDecimal("ANPMN443033");
						importeMinimo = plazosImportes.getBigDecimal("ANPMN443034");
						importeMaximo = plazosImportes.getBigDecimal("ANPMN443035");
					}
				}				
				
				// Crear contexto ANPMN473 a partir de los datos obtenidos, y anhadir a la lista de contextos de salida
				lista473.add(rellenarSalida(idProductoDev, desProductoDev, idSubProductoDev, desSubProductoDev, idTarifa, 
						descripcionTarifa, plazoMinimo, plazoMaximo, importeMinimo, importeMaximo, valorEstandar, valorDesde, 
						valorHasta, ordenTramo, tipoTramo, nivel, idCondicion, tipoCondicion, colectivo, descripcionTipo, 
						indPermiteFinanciarComision, plazoCarenciaDesde, plazoCarenciaHasta));
			}
		}
		
		return lista473;
	}
	
		
	/**
	 * Metodo que busca en la salida del ANPM_443 el registro de plazos e importes
	 * con el id de relacion indicado en la entrada.
	 * 
	 * @param salida443 salida del servicio ANPM_443.
	 * @param idRelacion id de relacion por el que se realizara la busqueda.
	 * @return registro de plazos e importes con el id de relacion indicado en la
	 *         entrada.
	 */
	private IRegistro getPlazosImportes(IContexto[] salida443, BigDecimal idRelacion)
	{
		IRegistro plazosImportes = null;
		
		// Buscar registro de plazos/importes con el id de relacion indicado 
		if (null != salida443)
		{
			// Obtener matriz de plazos e importes
			IRegistro[] matrizPlazosImportes = salida443[0].getRegistro("ANPMN443030");
			
			// Buscar el registro de plazos/importes
			for (IRegistro regPlazosImportes : matrizPlazosImportes)
			{
				if (0 == idRelacion.compareTo(regPlazosImportes.getBigDecimal("ANPMN443031")))
				{
					plazosImportes = regPlazosImportes;
					break;
				}
			}
		}
		
		// Devolver registro de plazos/importes
		return plazosImportes;
	}
	
	
	/**
	 * Metodo que realiza una copia profunda de un objeto utilizando
	 * serializacion.
	 * 
	 * @param source
	 * @return copia profunda del objeto recibido como parametro.
	 */
	@SuppressWarnings("unchecked")
	private static <T> T copy(T source, BigDecimal error)
	{
		error = BigDecimal.ZERO;
		
		try
		{
			ByteArrayOutputStream ostream = new ByteArrayOutputStream();
			ObjectOutputStream oostream = new ObjectOutputStream(ostream);

			oostream.writeObject(source);
			oostream.flush();

			byte[] bytes = ostream.toByteArray();

			InputStream istream = new ByteArrayInputStream(bytes);
			ObjectInputStream oistream = new ObjectInputStream(istream);

			return (T) oistream.readObject();
		}
		catch(RuntimeException e)
		{ 
			error = BigDecimal.ONE;
			return null;
		}
		catch(Exception e)
		{
			error = BigDecimal.ONE;
			return null;
		}
	}	
	

	/**
	 * Método que recibe los datos de interés fijo y diferencial de catálogo obtenidos en la consulta de datos subproducto hecha en el servicio ANPM_048 y
	 * los sobreescribe con los datos de interés fijo y diferencial recibidos en la consulta de precios tarifa, ANPM_443.
	 * 
	 * Actualización: También se sobreescriben con los datos devueltos del ANPM_443 las comisiones. Se sobreescribe el % comision (ANPMN005080 con
	 * el campo ANPMN443014 y el importeMínimoEstandar con el campo ANPMN443014 respectivamente.
	 * 
	 * @param contexto
	 * @param datosTarifa
	 * @param producto
	 * @param subProducto
	 * @param versionGeneral
	 */
	private static IContexto[] sobreescribirValoresInteresYComision(IContexto[] contextos, IContexto[] datosTarifas) 
	{
		
		IRegistro[] matrizPreciosTarifa = null;
		IContexto[] array014 = Utilidades.getArrayContexto(Constantes.CTE_ANPMN014, contextos);
		IContexto[] array015 = Utilidades.getArrayContexto(Constantes.CTE_ANPMN015, contextos);
		IContexto[] array005 = Utilidades.getArrayContexto(Constantes.CTE_ANPMN005, contextos);
		
		// Lista para los nuevos contextos ANPMN005 generados a partir de los datos devueltos por el ANPM_443
		List<IContexto> contextosSustitucion = new ArrayList<IContexto>();
		
		for (IContexto datosTarifa : datosTarifas)
		{
			matrizPreciosTarifa = datosTarifa.getRegistro(ConstantesComun.CTE_MATRIZ_TRAMO_TARIFA);

			// Sobreescribir registros interes
			for (IRegistro registro : matrizPreciosTarifa) 
			{
				for (IContexto contextoarray014 : array014) 
			    {
					if (((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(contextoarray014.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_INTERES))) ||
						((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(new BigDecimal(10))) && 
						 (0 == contextoarray014.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_INTERES).compareTo(BigDecimal.ZERO)))) &&
						 
						(0 == registro.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_SM).compareTo(contextoarray014.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_INTERES))) &&
						((ConstantesComun.CTE_INT.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION)))) ||
						 (ConstantesComun.CTE_DIF.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION))))))
					{
						  // Crear nuevo contexto ANPMN014, a partir de los datos de: 
						  // - Registro INT devuelto por el ANPM_443 
						  // - Contexto ANPMN014 correspondiente, devuelto por ANPM_048
						  IContexto nuevoCtx014 = getContexto014(contextoarray014, registro);
						  						  
						  // Anhadir nuevo contexto a la lista de contextos de sustitucion
						  contextosSustitucion.add(nuevoCtx014);
					}
			    }
			}
								
			for (IRegistro registro : matrizPreciosTarifa) 
			{ 
			  if (ConstantesComun.CTE_DIF.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION))))
			  {
					for (IContexto contextoarray015 : array015) 
					{
						if (((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(contextoarray015.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_DIFERENCIAL))) ||
							  ((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(new BigDecimal(10))) && 
								 (0 == contextoarray015.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_DIFERENCIAL).compareTo(BigDecimal.ZERO)))) &&
							(0 == registro.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_SM).compareTo(contextoarray015.getBigDecimal(ConstantesComun.CTE_STR_TRAMO_DIFERENCIAL))))
						{

							  // Crear nuevo contexto ANPMN015, a partir de los datos de: 
							  // - Registro DIF devuelto por el ANPM_443 
							  // - Contexto ANPMN005 correspondiente, devuelto por ANPM_048
							  IContexto nuevoCtx015 = getContexto015(contextoarray015, registro);
							  						  
							  // Anhadir nuevo contexto a la lista de contextos de sustitucion
							  contextosSustitucion.add(nuevoCtx015);
						}
					}
			  }
			  
			  if (ConstantesComun.CTE_COM.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION)))) // comisión
			  {
				  for (IContexto contextoarray005 : array005) 
				  {	  
					  // Comprobar longitud del tipo de comision
					  String tipoComision005 = contextoarray005.getString(ConstantesComun.CTE_TIPO_COMISION_005);
					  tipoComision005 = tipoComision005.substring(1);
					  
					  // Si coinciden nivel, tipo comision y orden tramo
					  if (((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(contextoarray005.getBigDecimal(ConstantesComun.CTE_NIVEL_005))) ||
							((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(new BigDecimal(10))) && 
								(0 == contextoarray005.getBigDecimal(ConstantesComun.CTE_NIVEL_005).compareTo(BigDecimal.ZERO)))) &&  // nivel -> (ANPMN005050 == ANPMN443017)
						   (tipoComision005.equals(registro.getString(ConstantesComun.CTE_STR_TIPO_INTERES_SM))) && 		  // tipo comision -> (ANPMN005060 == ANPMN443012)
					       (0 == contextoarray005.getBigDecimal(ConstantesComun.CTE_ID_ORDEN_005).compareTo(registro.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_SM)))) // id orden ->(ANPMN005070 == ANPMN443011)
					  {
						  
						  // Crear nuevo contexto ANPMN005, a partir de los datos de: 
						  // - Registro COM devuelto por el ANPM_443 
						  // - Contexto ANPMN005 correspondiente, devuelto por ANPM_048
						  IContexto nuevoCtx005 = getContexto005(contextoarray005, registro);
						  						  
						  // Anhadir nuevo contexto a la lista de contextos de sustitucion
						  contextosSustitucion.add(nuevoCtx005);
					  }
				  }
			  }
		   }
		}
				
		// Sustituir los contextos ANPMN005, ANPMN014 y ANPMN015 de la salida del ANPM_048 por
		// los contextos de sustitucion correspondientes, generados a partir de la salida del
		// ANPM_443.
		List<IContexto> nuevaSalida048 = sustituirContextos(contextos, contextosSustitucion);
		
		// Actualizar contextos ANPM_048
		return nuevaSalida048.toArray(new IContexto[0]);
	}	
	
	
	/**
	 * Metodo que construye un nuevo contexto ANPMN005 a partir de un registro de tipo COM 
	 * devuelto por el ANPM_443, y el contexto ANPMN005 correspondiente devuelto por el 
	 * ANPM_048. 
	 * 
	 * @param contexto005
	 * @param registro443
	 * @return
	 */
	private static IContexto getContexto005(IContexto contexto005, IRegistro registro443)
	{
		// Inicializaciones
		IContexto nuevoContexto005 = null;
		BigDecimal error = BigDecimal.ZERO;
		
		// Crear una copia del contexto ANPMN005 del ANPM_048
		nuevoContexto005 = copy(contexto005, error);
		
		if ((null == nuevoContexto005) && (0 == BigDecimal.ONE.compareTo(error)))
		{
			// Error creando copia del contexto
			ServicioNegocio.rollback(
				new Integer(13455), 
				new String[]{}, 
				new String[]{}, 
				new String[]{});
		}
		
		
		// Si no hay error, se sobreescriben los campos del nuevo contexto ANPMN005
		// con los valores correspondientes del ANPM_443.
		nuevoContexto005.put(ConstantesComun.CTE_ID_RELACION_TARIFAS, 
				registro443.getBigDecimal(ConstantesComun.CTE_REG_ANPMN443_ID_RELACION));
		
		// Si es tipo DEHA
		if (ConstantesComun.CTE_DEHA.equals(Utilidades.comprobarDatoNull(registro443.
				getString(ConstantesComun.CTE_STR_TIPO_CONDICION))))
		{		
			nuevoContexto005.put(ConstantesComun.CTE_PORCENTAJE_COMISION_EST, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));

			nuevoContexto005.put(ConstantesComun.CTE_PORCENTAJE_COMISION_DESDE, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));

			nuevoContexto005.put(ConstantesComun.CTE_PORCENTAJE_COMISION_HASTA, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
		}

		// Si es tipo MIN
		if (ConstantesComun.CTE_MIN.equals(Utilidades.comprobarDatoNull(registro443.
				getString(ConstantesComun.CTE_STR_TIPO_CONDICION))))
		{
			// Se sobreescribe el importe mínimo -> importeMinimoEstandar (PIC) X ANPMN443014
			nuevoContexto005.put(ConstantesComun.CTE_IMPORTE_MINIMO_EST, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));

			nuevoContexto005.put(ConstantesComun.CTE_IMPORTE_MINIMO_DESDE, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));

			nuevoContexto005.put(ConstantesComun.CTE_IMPORTE_MINIMO_HASTA, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
		}
		
		// Devolver nuevo contexto ANPMN005
		return nuevoContexto005;
	}
	
	
	/**
	 * Metodo que construye un nuevo contexto ANPMN014 a partir de un registro de tipo INT 
	 * devuelto por el ANPM_443, y el contexto ANPMN014 correspondiente devuelto por el 
	 * ANPM_048. 
	 * 
	 * @param contexto014
	 * @param registro443
	 * @return
	 */
	private static IContexto getContexto014(IContexto contexto014, IRegistro registro443)
	{
		// Inicializaciones
		IContexto nuevoContexto014 = null;
		BigDecimal error = BigDecimal.ZERO;
		
		// Crear una copia del contexto ANPMN014 del ANPM_048
		nuevoContexto014 = copy(contexto014, error);
		
		if ((null == nuevoContexto014) && (0 == BigDecimal.ONE.compareTo(error)))
		{
			// Error creando copia del contexto
			ServicioNegocio.rollback(
				new Integer(13455), 
				new String[]{}, 
				new String[]{}, 
				new String[]{});
		}
		
		// Si no hay error, se sobreescriben los campos del nuevo contexto ANPMN014
		// con los valores correspondientes del ANPM_443.
		
		/*20150922 Recuperamos el id de relación*/
		nuevoContexto014.put(ConstantesComun.CTE_ANPMN014_ID_RELACION, 
				registro443.getBigDecimal(ConstantesComun.CTE_REG_ANPMN443_ID_RELACION));
		
		if (ConstantesComun.CTE_INT.equals(Utilidades.comprobarDatoNull(
				registro443.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION))))
		{							
			nuevoContexto014.put(ConstantesComun.CTE_STR_TIPO_FLEXIBILIDAD, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_TIPO_FLEXIBILIDAD_SM));
			
			nuevoContexto014.put(ConstantesComun.CTE_TIPO_INTERES, 
					registro443.getString(ConstantesComun.CTE_STR_TIPO_INTERES_SM));
			
			nuevoContexto014.put(ConstantesComun.CTE_STR_INTERES_ESTANDAR, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
			
			nuevoContexto014.put(ConstantesComun.CTE_STR_INTERES_DESDE, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
			
			nuevoContexto014.put(ConstantesComun.CTE_STR_INTERES_HASTA, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
		}
		
		// Devolver nuevo contexto ANPMN014
		return nuevoContexto014;
	}
	
	
	/**
	 * Metodo que construye un nuevo contexto ANPMN015 a partir de un registro de tipo DIF 
	 * devuelto por el ANPM_443, y el contexto ANPMN015 correspondiente devuelto por el 
	 * ANPM_048. 
	 * 
	 * @param contexto015
	 * @param registro443
	 * @return
	 */
	private static IContexto getContexto015(IContexto contexto015, IRegistro registro443)
	{
		// Inicializaciones
		IContexto nuevoContexto015 = null;
		BigDecimal error = BigDecimal.ZERO;
		
		// Crear una copia del contexto ANPMN014 del ANPM_048
		nuevoContexto015 = copy(contexto015, error);
		
		if ((null == nuevoContexto015) && (0 == BigDecimal.ONE.compareTo(error)))
		{
			// Error creando copia del contexto
			ServicioNegocio.rollback(
				new Integer(13455), 
				new String[]{}, 
				new String[]{}, 
				new String[]{});
		}
		
		// Si no hay error, se sobreescriben los campos del nuevo contexto ANPMN015
		// con los valores correspondientes del ANPM_443.
		
		/*Si el tipo de referencia del contexto de diferencial que estamos recorriendo es no referenciado, entonces
		 * en vez de sobreescribir el diferencial estándar y su rango vamos a sobreescbirir el techo y su rango.*/
		if (Utilidades.esTipoReferenciaNoReferenciado(nuevoContexto015.getBigDecimal(
				ConstantesComun.CTE_TECHOSUELODIF_PROP_TIPO_REF).toString()))
		{
			nuevoContexto015.put(ConstantesComun.CTE_TECHOSUELODIF_PROP_TECHO_ESTANDAR, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
			
			nuevoContexto015.put(ConstantesComun.CTE_TECHOSUELODIF_PROP_TECHO_DESDE, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
			
			nuevoContexto015.put(ConstantesComun.CTE_TECHOSUELODIF_PROP_TECHO_HASTA, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
		}
		else
		{
			nuevoContexto015.put(ConstantesComun.CTE_STR_NIVEL_DIFERENCIAL, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM));
			
			nuevoContexto015.put(ConstantesComun.CTE_STR_DIFERENCIAL_ESTANDAR, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
			
			nuevoContexto015.put(ConstantesComun.CTE_STR_DIFERENCIAL_DESDE, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
			
			nuevoContexto015.put(ConstantesComun.CTE_STR_DIFERENCIAL_HASTA, 
					registro443.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
		}
		
		// Devolver nuevo contexto ANPMN015
		return nuevoContexto015;
	}	
	
	
	/**
	 * Dado un array de contextos de salida de ANPM_048 y una lista de contextos, se buscan en la
	 * salida de ANPM_048 los contextos a sustituir, y se sustituyen por los correspondientes de
	 * la lista recibida como parametro.
	 * 
	 * @param salida048 array de contextos de salida del ANPM_048
	 * @param contextosSustitucion lista de contextos por los que hay que sustituir los
	 *                             correspondientes de la salida del ANPM_048.
	 * @return
	 */
	private static List<IContexto> sustituirContextos(IContexto[] salida048, List<IContexto> contextosSustitucion)
	{
		// Inicializaciones
		List<IContexto> nuevaSalida048 = new ArrayList<IContexto>();
		
		boolean existe = false;
		BigDecimal ordenCtx048;
		BigDecimal nivelCtx048;
		BigDecimal tipoCtx048;
		BigDecimal ordenCtxSustitucion;
		BigDecimal nivelCtxSustitucion;
		BigDecimal tipoCtxSustitucion;
		
		// Buscar contextos de sustitucion
		List<IContexto> listaCtxSustitucion005 = UtilidadesTramitacion.getContextos(contextosSustitucion, "ANPMN005");
		List<IContexto> listaCtxSustitucion014 = UtilidadesTramitacion.getContextos(contextosSustitucion, "ANPMN014");
		List<IContexto> listaCtxSustitucion015 = UtilidadesTramitacion.getContextos(contextosSustitucion, "ANPMN015");
		
		
		// Inicialmente la nueva salida tiene los contextos de la salida del ANPM_048
		for (IContexto ctx048 : salida048)
		{
			nuevaSalida048.add(ctx048);
		}
		
		
		// Si hay contextos de sustitucion, sustituirlos por el contexto correspondiente	
		if ( ((null != listaCtxSustitucion005) && (0 < listaCtxSustitucion005.size())) ||
				((null != listaCtxSustitucion014) && (0 < listaCtxSustitucion014.size())) ||
				((null != listaCtxSustitucion015) && (0 < listaCtxSustitucion015.size())) )
		{
			
			// Lista temporal para sustituir los contextos ANPMN005
			List<IContexto> nuevaSalida005 = new ArrayList<IContexto>();
			
			// Sustituir contextos ANPMN005
			if ((null != listaCtxSustitucion005) && (0 < listaCtxSustitucion005.size()))
			{
				// Se anhaden a la lista todos los contextos distintos de ANPMN005,
				// y aquellos de tipo ANPMN005 que no esten en la lista.
				for (IContexto ctx : nuevaSalida048)
				{
					if (!ctx.getNombre().equals("ANPMN005"))
					{
						nuevaSalida005.add(ctx);
					}
					else
					{
						// Si el contexto es 005, se anhade solo si en la lista de nuevos
						// contextos no hay ninguno para ese tipo de comision, nivel y orden.
						
						// Buscar en la lista de contextos 005 de sustitucion si hay alguno
						// con el mismo tipo comision, nivel y orden que el contexto del 048.
						existe = false;
						ordenCtx048 = ctx.getBigDecimal("ANPMN005070");
						nivelCtx048 = ctx.getBigDecimal("ANPMN005050");
						tipoCtx048 = new BigDecimal(ctx.getString("ANPMN005060").trim());
						
						for (IContexto ctxSustitucion005 : listaCtxSustitucion005)
						{
							ordenCtxSustitucion = ctxSustitucion005.getBigDecimal("ANPMN005070");
							nivelCtxSustitucion = ctxSustitucion005.getBigDecimal("ANPMN005050");
							tipoCtxSustitucion = new BigDecimal(ctxSustitucion005.getString("ANPMN005060").trim());
							
							if (((0 == nivelCtx048.compareTo(nivelCtxSustitucion)) || 
									((0 == nivelCtx048.compareTo(BigDecimal.ZERO)) && 
									 (0 == nivelCtxSustitucion.compareTo(new BigDecimal(10))))) &&
								(0 == ordenCtx048.compareTo(ordenCtxSustitucion)) &&
								(0 == tipoCtx048.compareTo(tipoCtxSustitucion)))
							{
								existe = true;
								break;
							}
						}
						
						if (!existe)
						{
							nuevaSalida005.add(ctx);
						}
					}
				}
				
				// Se anhaden a la lista los nuevos contextos ANPMN005
				nuevaSalida005.addAll(listaCtxSustitucion005);
				nuevaSalida048 = nuevaSalida005;
			}
			
			
			// Sustituir contextos ANPMN014
			if ((null != listaCtxSustitucion014) && (0 < listaCtxSustitucion014.size()))
			{
				// Lista temporal para sustituir los contextos ANPMN014
				List<IContexto> nuevaSalida014 = new ArrayList<IContexto>();
				
				// Se anhaden a la lista todos los contextos distintos de ANPMN014,
				// y aquellos de tipo ANPMN014 que no esten en la lista.
				for (IContexto ctx : nuevaSalida048)
				{
					if (!ctx.getNombre().equals("ANPMN014"))
					{
						nuevaSalida014.add(ctx);
					}
					else
					{
						// Si el contexto es 014, se anhade solo si en la lista de nuevos
						// contextos no hay ninguno para ese tipo, nivel y orden.
						
						// Buscar en la lista de contextos 014 de sustitucion si hay alguno
						// con el mismo tipo, nivel y orden que el contexto del 048.
						existe = false;
						ordenCtx048 = ctx.getBigDecimal("ANPMN014060");
						nivelCtx048 = ctx.getBigDecimal("ANPMN014050");
						tipoCtx048 = new BigDecimal(ctx.getString("ANPMN014070").trim());
						
						for (IContexto ctxSustitucion014 : listaCtxSustitucion014)
						{
							ordenCtxSustitucion = ctxSustitucion014.getBigDecimal("ANPMN014060");
							nivelCtxSustitucion = ctxSustitucion014.getBigDecimal("ANPMN014050");
							tipoCtxSustitucion = new BigDecimal(ctxSustitucion014.getString("ANPMN014070").trim());
							
							if (((0 == nivelCtx048.compareTo(nivelCtxSustitucion)) || 
									((0 == nivelCtx048.compareTo(BigDecimal.ZERO)) && 
									 (0 == nivelCtxSustitucion.compareTo(new BigDecimal(10))))) &&
								(0 == ordenCtx048.compareTo(ordenCtxSustitucion)) &&
								(0 == tipoCtx048.compareTo(tipoCtxSustitucion)))
							{
								existe = true;
								break;
							}
						}
						
						if (!existe)
						{
							nuevaSalida014.add(ctx);
						}						
					}
				}
				
				// Se anhaden a la lista los nuevos contextos ANPMN014
				nuevaSalida014.addAll(listaCtxSustitucion014);
				nuevaSalida048 = nuevaSalida014;
			}			
			
			
			// Sustituir contextos ANPMN015
			if ((null != listaCtxSustitucion015) && (0 < listaCtxSustitucion015.size()))
			{
				// Lista temporal para sustituir los contextos ANPMN015
				List<IContexto> nuevaSalida015 = new ArrayList<IContexto>();
				
				// Se anhaden a la lista todos los contextos distintos de ANPMN015,
				// y aquellos de tipo ANPMN015 que no esten en la lista.
				for (IContexto ctx : nuevaSalida048)
				{
					if (!ctx.getNombre().equals("ANPMN015"))
					{
						nuevaSalida015.add(ctx);
					}
					else
					{
						// Si el contexto es 015, se anhade solo si en la lista de nuevos
						// contextos no hay ninguno para ese tipo, nivel y orden.
						
						// Buscar en la lista de contextos 015 de sustitucion si hay alguno
						// con el mismo tipo, nivel y orden que el contexto del 048.
						existe = false;
						ordenCtx048 = ctx.getBigDecimal("ANPMN015060");
						nivelCtx048 = ctx.getBigDecimal("ANPMN015050");
						tipoCtx048 = ctx.getBigDecimal("ANPMN015070");
						
						for (IContexto ctxSustitucion015 : listaCtxSustitucion015)
						{
							ordenCtxSustitucion = ctxSustitucion015.getBigDecimal("ANPMN015060");
							nivelCtxSustitucion = ctxSustitucion015.getBigDecimal("ANPMN015050");
							tipoCtxSustitucion = ctxSustitucion015.getBigDecimal("ANPMN015070");
							
							if (((0 == nivelCtx048.compareTo(nivelCtxSustitucion)) || 
									((0 == nivelCtx048.compareTo(BigDecimal.ZERO)) && 
									 (0 == nivelCtxSustitucion.compareTo(new BigDecimal(10))))) &&
								(0 == ordenCtx048.compareTo(ordenCtxSustitucion)) &&
								(0 == tipoCtx048.compareTo(tipoCtxSustitucion)))
							{
								existe = true;
								break;
							}
						}
						
						if (!existe)
						{
							nuevaSalida015.add(ctx);
						}						
					}
				}
				
				// Se anhaden a la lista los nuevos contextos ANPMN014
				nuevaSalida015.addAll(listaCtxSustitucion014);
				nuevaSalida048 = nuevaSalida015;
			}			
		}	
		
		// Devolver nueva lista de contextos de salida de ANPM_048
		return nuevaSalida048;
	}
	
	/**
	 * Método que filtra la lista por plazo e importe. 
	 * 
	 * @param listResultado: lista a filtrar
	 * @param plazo: plazo por el que se filtra
	 * @param importe: importe por el que se filtra
	 * 
	 * @return lista filtrada
	 * 
	 * */
	
	private static List<IContexto> filtrarResultado(List<IContexto> listResultado, BigDecimal importe, BigDecimal plazo)
	{		
		
		List<IContexto> resultadoFiltrado = new ArrayList<IContexto>();
		
		for (IContexto unidad : listResultado)
		{
			if ((0 == (plazo).compareTo(unidad.getBigDecimal("ANPMN473070")) ||
				(0 < (plazo).compareTo(unidad.getBigDecimal("ANPMN473070")))) &&
				(0 == (plazo).compareTo(unidad.getBigDecimal("ANPMN473080")) ||
				(0 > (plazo).compareTo(unidad.getBigDecimal("ANPMN473080")))) &&
				
				(0 == (importe).compareTo(unidad.getBigDecimal("ANPMN473090")) ||
				(0 < (importe).compareTo(unidad.getBigDecimal("ANPMN473090")))) &&
				(0 == (importe).compareTo(unidad.getBigDecimal("ANPMN473100")) ||
				(0 > (importe).compareTo(unidad.getBigDecimal("ANPMN473100")))))
			{
				resultadoFiltrado.add(unidad);
			}	
		}
		
		return resultadoFiltrado;
	}
	
	
//	/**
//	 * Método que recibe los datos de interés fijo y diferencial de catálogo obtenidos en la consulta de datos subproducto hecha en el servicio ANPM_048 y
//	 * los sobreescribe con los datos de interés fijo y diferencial recibidos en la consulta de precios tarifa, ANPM_443.
//	 * 
//	 * Actualización: También se sobreescriben con los datos devueltos del ANPM_443 las comisiones. Se sobreescribe el % comision (ANPMN005080 con
//	 * el campo ANPMN443014 y el importeMínimoEstandar con el campo ANPMN443014 respectivamente.
//	 * 
//	 * @param contexto
//	 * @param datosTarifa
//	 * @param producto
//	 * @param subProducto
//	 * @param versionGeneral
//	 */
//	
//	public static void sobreescribirValoresInteresYComision(IContexto[] contextos, IContexto[] datosTarifas) 
//	{
//		
//		IRegistro[] matrizPreciosTarifa = null;
//		IContexto[] array014 = Utilidades.getArrayContexto(Constantes.CTE_ANPMN014, contextos);
//		IContexto[] array015 = Utilidades.getArrayContexto(Constantes.CTE_ANPMN015, contextos);
//		IContexto[] array005 = Utilidades.getArrayContexto(Constantes.CTE_ANPMN005, contextos);
//		
//		for (IContexto datosTarifa : datosTarifas)
//		{
//			matrizPreciosTarifa = datosTarifa.getRegistro(ConstantesComun.CTE_MATRIZ_TRAMO_TARIFA);
//
//			// Sobreescribir registros interes
//			for (IRegistro registro : matrizPreciosTarifa) 
//			{
//				for (IContexto contextoarray014 : array014) 
//			    {
//					if (((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(contextoarray014.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_INTERES))) ||
//						((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(new BigDecimal(10))) && 
//						 (0 == contextoarray014.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_INTERES).compareTo(BigDecimal.ZERO)))) &&
//						 
//						(0 == registro.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_SM).compareTo(contextoarray014.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_INTERES))) &&
//						((ConstantesComun.CTE_INT.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION)))) ||
//						 (ConstantesComun.CTE_DIF.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION))))))
//					{
//						/*20150922 Recuperamos el id de relación*/
//						contextoarray014.put(ConstantesComun.CTE_ANPMN014_ID_RELACION, registro.getBigDecimal(ConstantesComun.CTE_REG_ANPMN443_ID_RELACION));
//						if (ConstantesComun.CTE_INT.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION))))
//						{							
//							contextoarray014.put(ConstantesComun.CTE_STR_TIPO_FLEXIBILIDAD, registro.getBigDecimal(ConstantesComun.CTE_STR_TIPO_FLEXIBILIDAD_SM));
//							contextoarray014.put(ConstantesComun.CTE_TIPO_INTERES, registro.getString(ConstantesComun.CTE_STR_TIPO_INTERES_SM));
//							contextoarray014.put(ConstantesComun.CTE_STR_INTERES_ESTANDAR, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
//							contextoarray014.put(ConstantesComun.CTE_STR_INTERES_DESDE, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
//							contextoarray014.put(ConstantesComun.CTE_STR_INTERES_HASTA, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
//						}
//					}
//			    }
//			}
//						
//			for (IRegistro registro : matrizPreciosTarifa) 
//			{ 
//			  if (ConstantesComun.CTE_DIF.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION))))
//			  {
//					for (IContexto contextoarray015 : array015) 
//					{
//						if (((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(contextoarray015.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_DIFERENCIAL))) ||
//							  ((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(new BigDecimal(10))) && 
//								 (0 == contextoarray015.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_DIFERENCIAL).compareTo(BigDecimal.ZERO)))) &&
//							(0 == registro.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_SM).compareTo(contextoarray015.getBigDecimal(ConstantesComun.CTE_STR_TRAMO_DIFERENCIAL))))
//						{
//							/*Si el tipo de referencia del contexto de diferencial que estamos recorriendo es no referenciado, entonces
//							 * en vez de sobreescribir el diferencial estándar y su rango vamos a sobreescbirir el techo y su rango.*/
//							if (Utilidades.esTipoReferenciaNoReferenciado(contextoarray015.getBigDecimal(ConstantesComun.CTE_TECHOSUELODIF_PROP_TIPO_REF).toString()))
//							{
//								contextoarray015.put(ConstantesComun.CTE_TECHOSUELODIF_PROP_TECHO_ESTANDAR, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
//								contextoarray015.put(ConstantesComun.CTE_TECHOSUELODIF_PROP_TECHO_DESDE, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
//								contextoarray015.put(ConstantesComun.CTE_TECHOSUELODIF_PROP_TECHO_HASTA, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
//							}
//							else
//							{
//								contextoarray015.put(ConstantesComun.CTE_STR_NIVEL_DIFERENCIAL, registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM));
//								contextoarray015.put(ConstantesComun.CTE_STR_DIFERENCIAL_ESTANDAR, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
//								contextoarray015.put(ConstantesComun.CTE_STR_DIFERENCIAL_DESDE, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
//								contextoarray015.put(ConstantesComun.CTE_STR_DIFERENCIAL_HASTA, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
//							}
//						}
//					}
//			  }
//			  
//			  if (ConstantesComun.CTE_COM.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_IDENTIFICADOR_CONDICION)))) // comisión
//			  {
//				  for (IContexto contextoarray005 : array005) 
//				  {
//					  // Si coinciden nivel, tipo comision y orden tramo
//					  if (((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(contextoarray005.getBigDecimal(ConstantesComun.CTE_NIVEL_005))) ||
//							((0 == registro.getBigDecimal(ConstantesComun.CTE_STR_NIVEL_SM).compareTo(new BigDecimal(10))) && 
//								(0 == contextoarray005.getBigDecimal(ConstantesComun.CTE_NIVEL_005).compareTo(BigDecimal.ZERO)))) &&  // nivel -> (ANPMN005050 == ANPMN443017)
//						   (contextoarray005.getString(ConstantesComun.CTE_TIPO_COMISION_005).equals(registro.getString(ConstantesComun.CTE_STR_TIPO_INTERES_SM))) && 		  // tipo comision -> (ANPMN005060 == ANPMN443012)
//					       (0 == contextoarray005.getBigDecimal(ConstantesComun.CTE_ID_ORDEN_005).compareTo(registro.getBigDecimal(ConstantesComun.CTE_STR_ORDEN_TRAMO_SM)))) // id orden ->(ANPMN005070 == ANPMN443011)
//					  {
//						  // Si es tipo DEHA
//						  if (ConstantesComun.CTE_DEHA.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_TIPO_CONDICION))))
//						  {
//							  // Se sobreescribe el % comision -> ANPMN005080 (PIC) X ANPMN443014
//							  contextoarray005.put(ConstantesComun.CTE_PORCENTAJE_COMISION_EST, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
//							  contextoarray005.put(ConstantesComun.CTE_PORCENTAJE_COMISION_DESDE, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
//							  contextoarray005.put(ConstantesComun.CTE_PORCENTAJE_COMISION_HASTA, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
//						  }
//						  
//						  // Si es tipo MIN
//						  if (ConstantesComun.CTE_MIN.equals(Utilidades.comprobarDatoNull(registro.getString(ConstantesComun.CTE_STR_TIPO_CONDICION))))
//						  {
//							  // Se sobreescribe el importe mínimo -> importeMinimoEstandar (PIC) X ANPMN443014
//							  contextoarray005.put(ConstantesComun.CTE_IMPORTE_MINIMO_EST, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_ESTANDAR_SM));
//							  contextoarray005.put(ConstantesComun.CTE_IMPORTE_MINIMO_DESDE, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_DESDE_SM));
//							  contextoarray005.put(ConstantesComun.CTE_IMPORTE_MINIMO_HASTA, registro.getBigDecimal(ConstantesComun.CTE_STR_VALOR_HASTA_SM));
//						  }
//					  }
//				  }
//			  }
//		   }
//		}
//	}
//		
	
}
