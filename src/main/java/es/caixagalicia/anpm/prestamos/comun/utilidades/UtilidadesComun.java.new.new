/**/
package es.caixagalicia.anpm.prestamos.comun.utilidades;

import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang.StringUtils;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Utilidades;
import es.caixagalicia.anpm.prestamos.comun.constantes.CodigosError;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesAutorizacion;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesGenericas;
import es.caixagalicia.anpm.prestamos.comun.utilidades.ICodigosANPM.CC;
import es.caixagalicia.anpm.prestamos.comun.utilidades.ICodigosANPM.CO;
import es.caixagalicia.anpm.prestamos.comun.utilidades.ICodigosANPM.IFSN_052;
import es.caixagalicia.anpm.prestamos.enotario.persistencia.datosgenerales.DatosgeneralesC;
import es.caixagalicia.anpm.prestamos.enotario.utilidades.IConstantesEnotario;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionesInteresC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionConsultaDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionVersionBackOffice;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesTramitacion;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.contextos.ContextoFactory;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.IRegistro;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.fechas.DateHelper;
import es.caixagalicia.ifrt.mainframe.ctgfacade.CtgFacade;
import es.caixagalicia.ifrt.parametros.Configuracion;
import es.caixagalicia.ifrt.mensajes.Mensaje;

/**
 * Clase común de utilidades.
 *
 * @author V360144
 */
public final class UtilidadesComun {

    public static final String CTE_DATELOWEST = "0001-01-01 00:00:00";

    private static CtgFacade ctgFacade = new CtgFacade();

    /**
     * Si el dato es nulo devuelve la cadena vacía.
     * @param dato
     * @return
     */
    public static String comprobarDatoNull(String dato) {
        String resultado = StringUtils.EMPTY;
        if (null != dato) {
            resultado = dato.trim();
        }
        return resultado;
    }

    /**
     * Si el dato es nulo devuelve la cadena por defecto.
     * @param dato
     * @return
     */
    public static String comprobarDatoNull(String dato, String strPorDefecto) {
        String resultado = StringUtils.EMPTY;
        if (null != dato) {
            resultado = dato.trim();
        } else {
            resultado = strPorDefecto;
        }
        return resultado;
    }

    /**
     * Comprueba si un tramo es fijo o es variable
     * @param aCtxtoIntereses
     * @return True si el tramo es fijo, False en otro caso
     */
    public static boolean isTramoFijo(CondicionesInteresC condicionInteres) {
        boolean tramoFijo = Boolean.TRUE;
        if (Constantes.INTERES_TIPO_INTERES.equals(condicionInteres.getCondicionesInteresKey().getIntTipoCondicion())) {
            if (Constantes.TIPO_INT_VARIABLE.equals(condicionInteres.getStrTipoDeInteres().trim()) || Constantes.TIPO_INT_VAR_BONIF.equals(condicionInteres.getStrTipoDeInteres().trim()) || Constantes.TIPO_INT_VAR_PENAL.equals(condicionInteres.getStrTipoDeInteres().trim()) || Constantes.TIPO_INT_VAR_DIF_BONIF.equals(condicionInteres.getStrTipoDeInteres().trim())) {
                tramoFijo = false;
            }
        }
        return tramoFijo;
    }

    /**
     * Comprueba si un tramo es fijo o es variable
     * @param aCtxtoIntereses
     * @return True si el tramo es fijo, False en otro caso
     */
    public static boolean isTramoFijo(IContexto ctxInteres) {
        boolean tramoFijo = Boolean.TRUE;
        String ID_CTXTO_CONDICIONES_TIPO_CONDICION = "ANPMN052050";
        String ID_CTXTO_CONDICIONES_TIPO_INTERES = "ANPMN052080";
        if (Constantes.INTERES_TIPO_INTERES.equals(ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_TIPO_CONDICION).intValue())) {
            if (Constantes.TIPO_INT_VARIABLE.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES)) || Constantes.TIPO_INT_VAR_BONIF.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES)) || Constantes.TIPO_INT_VAR_PENAL.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES)) || Constantes.TIPO_INT_VAR_DIF_BONIF.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES))) {
                tramoFijo = false;
            }
        }
        return tramoFijo;
    }

    /**
     * Comprueba si un tramo es fijo o es variable
     * @param aCtxtoIntereses
     * @return True si el tramo es fijo, False en otro caso
     */
    public static boolean isTramoFijoInteres(IContexto ctxInteres) {
        boolean tramoFijo = Boolean.TRUE;
        String ID_CTXTO_CONDICIONES_TIPO_INTERES = "ANPMN014070";
        if (Constantes.TIPO_INT_VARIABLE.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES)) || Constantes.TIPO_INT_VAR_BONIF.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES)) || Constantes.TIPO_INT_VAR_PENAL.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES)) || Constantes.TIPO_INT_VAR_DIF_BONIF.equals(ctxInteres.getString(ID_CTXTO_CONDICIONES_TIPO_INTERES))) {
            tramoFijo = false;
        }
        return tramoFijo;
    }

    /**
     * @param ibanCargoEuros
     * @param ibanAbonoEuros
     * @param ibanCargoAbonoDivisa
     * @return rollback si alguna de las cuentas introducidas no es valida
     */
    public static void verificarCuentaValida(String ibanCargoEuros, String ibanAbonoEuros, String ibanCargoAbonoDivisa) {
        String cuentaContable = "";
        List<String> cuentas = new ArrayList<String>();
        if (null != ibanAbonoEuros && ibanAbonoEuros.length() > 0 && !ibanAbonoEuros.trim().equals(ConstantesComun.CTE_STR_EMPTY)) {
            cuentas.add(ibanAbonoEuros.trim());
        }
        if (null != ibanCargoEuros && ibanCargoEuros.length() > 0 && !ibanCargoEuros.trim().equals(ConstantesComun.CTE_STR_EMPTY)) {
            cuentas.add(ibanCargoEuros.trim());
        }
        if (null != ibanCargoAbonoDivisa && ibanCargoAbonoDivisa.length() > 0 && !ibanCargoAbonoDivisa.trim().equals(ConstantesComun.CTE_STR_EMPTY)) {
            cuentas.add(ibanCargoAbonoDivisa.trim());
        }
        if (null != cuentas && cuentas.size() > 0) {
            for (String cuenta : cuentas) {
                cuentaContable = cuenta.substring(14, 17);
                switch(cuentaContable) {
                    // Cuenta divisa   		: 394
                    case "500":
                    case "550":
                    case "394":
                    case "300":
                    case "302":
                    case "305":
                    case "306":
                    case "310":
                    case "304":
                    case "311":
                    case "312":
                        // Todo bien continuamos
                        break;
                    default:
                        // No es una cuenta permitida y salimos
                        ServicioNegocio.rollback(CodigosError.ERROR_CUENTA_CONTABLE, null, new String[] { cuenta.trim() }, null);
                        break;
                }
            }
        } else {
            // No es una cuenta permitida y salimos
            ServicioNegocio.rollback(CodigosError.ERROR_CUENTA_CONTABLE, null, new String[] {}, null);
        }
    }

    /**
     * Si el dato es nulo devuelve un 0.
     * @param dato
     * @return
     */
    public static BigDecimal comprobarDatoNull(BigDecimal dato) {
        BigDecimal resultado = BigDecimal.ZERO;
        if (null != dato) {
            resultado = dato;
        }
        return resultado;
    }

    /**
     * Si el dato es nulo devuelve un 0.
     * @param dato
     * @return
     */
    public static Integer comprobarDatoNull(Integer dato) {
        Integer resultado = new Integer(0);
        if (null != dato) {
            resultado = dato;
        }
        return resultado;
    }

    /**
     * Comprueba si el objeto es nulo o vacío.
     * <br/>
     * En el caso de las cadenas de caracteres {@link String} mira si hay algun caracter no blanco.
     * <br/>
     * En el caso de las fechas {@link Date} se compara con la fecha mas baja en Java.
     * <br/>
     * En el caso de las colecciones, {@link Collection} {@link Set} {@link Map},
     * mira si esta no tiene elementos.
     * <br/>
     * En el caso de los datos arquitectura se resuelve su valor y se comprueba si esta vacio
     *
     * @param obj - Objeto a comprobar
     * @return Cierto si el objeto es nulo o vacío
     */
    public static boolean isBlankOrNull(final Object obj) {
        boolean ret = false;
        if (obj == null) {
            ret = true;
        } else if (obj instanceof String) {
            ret = (obj == null) || "".equals(((String) obj).trim());
        } else if (obj instanceof Boolean) {
            ret = false;
        } else if (obj instanceof Character) {
            ret = Character.isWhitespace(((Character) obj).charValue());
        } else if (obj instanceof Number) {
            ret = false;
        } else if (obj instanceof Date) {
            final java.util.Date dLow = Timestamp.valueOf(CTE_DATELOWEST);
            ret = dLow.after((Date) obj) || dLow.equals(obj);
        } else {
            ret = 0 == length(obj);
        }
        return ret;
    }

    /**
     * Metodo que comprueba que una cadena no sea una sucesion de espacios en blanco.
     * @param str cadena de entrada
     * @return <code>boolean</code>
     */
    public static boolean isEmptyOrNullString(final String str) {
        boolean ret = false;
        if (str == null) {
            ret = true;
        } else {
            boolean success = true;
            char[] chars = str.toCharArray();
            final int length = chars.length;
            for (int cont = 0; cont < length; cont++) {
                if (chars[cont] != ' ') {
                    success = false;
                    break;
                }
            }
            ret = success;
        }
        return ret;
    }

    /**
     * Averigual el numero de elementos de una coleccion o el numero de caracteres
     * de una cadena de texto (si el objeto es un {@link String} o un {@link StringBuffer}
     *
     * @param obj - objeto a comprobar su longitud
     * @return Longitud del objecto
     * @throws IllegalArgumentException  - si el objeto no es compatible
     */
    @SuppressWarnings("rawtypes")
    public static int length(final Object obj) {
        int l;
        if (obj == null) {
            l = 0;
        } else if (obj instanceof String) {
            l = ((String) obj).length();
        } else if (obj instanceof StringBuffer) {
            l = ((StringBuffer) obj).length();
        } else if (obj instanceof Collection) {
            l = ((Collection) obj).size();
        } else if (obj instanceof Map) {
            l = ((Map) obj).size();
        } else if (obj instanceof Set) {
            l = ((Set) obj).size();
        } else {
            int count = 0;
            if (obj instanceof Iterator) {
                final Iterator it = (Iterator) obj;
                boolean bHayMas = it.hasNext();
                while (bHayMas) {
                    it.next();
                    bHayMas = it.hasNext();
                    count++;
                }
                l = count;
            } else if (obj instanceof Enumeration) {
                Enumeration en = (Enumeration) obj;
                boolean bHayMas = en.hasMoreElements();
                while (bHayMas) {
                    en.nextElement();
                    bHayMas = en.hasMoreElements();
                    count++;
                }
                l = count;
            } else {
                try {
                    l = Array.getLength(obj);
                } catch (IllegalArgumentException e) {
                    throw new IllegalArgumentException(new Mensaje(ServicioNegocio.getContexto(), INCONSISTENT_OBJECT_TYPE_1388509224).toString() + obj.getClass());
                }
            }
        }
        return l;
    }

    /**
     * Método que invoca el servicio CGAL_373 para obtener la descripción del nivel indicado.
     *
     * @param nivel
     * @return
     */
    public static String obtenerDescrNivel(BigDecimal nivel) {
        String descrNivel = StringUtils.EMPTY;
        String nivelAutorizacion = null;
        String paramNivelCodDentroTabla = null;
        boolean lanzarRollbackConsParam = true;
        boolean detalleAutorizacionActivo = true;
        if (UtilidadesComun.consultaParametro("DET_NIVEL", "ACTIVO").equals(ConstantesComun.CTE_STR_1)) {
            detalleAutorizacionActivo = true;
        } else {
            detalleAutorizacionActivo = false;
        }
        if ((null == nivel) || (0 == BigDecimal.ZERO.compareTo(nivel))) {
            nivelAutorizacion = ConstantesGenericas.CTE_STR_10;
        } else {
            nivelAutorizacion = nivel.toString();
        }
        if (detalleAutorizacionActivo) {
            paramNivelCodDentroTabla = ConstantesGenericas.CTE_STR_CO.concat(nivelAutorizacion);
            /*Llamamos al método que consulta el parametro en la CG32TB01 a través del servicio CGAL_373:
			 * Tabla (CG210010): "NIV"
			 * Código dentro tabla (CG320020): "CO<nivel>"
			 * */
            descrNivel = getParametroUnicoDescr1(ConstantesAutorizacion.CTE_PARAM_TABLA_NIV, paramNivelCodDentroTabla, lanzarRollbackConsParam);
        } else if (!detalleAutorizacionActivo && null != nivel) {
            if (0 == nivel.compareTo(ConstantesAutorizacion.CTE_NIV_TERRITORIAL) || 0 == nivel.compareTo(ConstantesAutorizacion.CTE_NIV_DIVISION) || 0 == nivel.compareTo(ConstantesAutorizacion.CTE_NIV_DIVISION) || 0 == nivel.compareTo(ConstantesAutorizacion.CTE_NIV_DIRGEN)) {
                descrNivel = new String(new Mensaje(ServicioNegocio.getContexto(), NIVEL_SUPERIOR_1593071887).toString());
            } else {
                paramNivelCodDentroTabla = ConstantesGenericas.CTE_STR_CO.concat(nivelAutorizacion);
                /*Llamamos al método que consulta el parametro en la CG32TB01 a través del servicio CGAL_373:
					 * Tabla (CG210010): "NIV"
					 * Código dentro tabla (CG320020): "CO<nivel>"
					 * */
                descrNivel = getParametroUnicoDescr1(ConstantesAutorizacion.CTE_PARAM_TABLA_NIV, paramNivelCodDentroTabla, lanzarRollbackConsParam);
            }
        }
        return descrNivel;
    }

    public static BigDecimal mayor(BigDecimal a, BigDecimal b) {
        BigDecimal mayor = null;
        if (0 < a.compareTo(b)) {
            mayor = a;
        } else {
            mayor = b;
        }
        return mayor;
    }

    /**
     * Método que llama al ANPM_424 para obtener el maximo diferencial bonificado.
     *
     * @param nucExpediente
     * @param estado
     */
    public static BigDecimal obtenerDiferencialBonificado(DatosSolicitudC solicitud, BigDecimal diferencial) {
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        IContexto[] resultado = null;
        IDatosEntradaTx datosEntrada = null;
        BigDecimal maximaBonificacion = BigDecimal.ZERO;
        BigDecimal diferencialBonificado = BigDecimal.ZERO;
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_CO);
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_PRODUCTO, solicitud.getProducto());
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_SUBPRODUCTO, solicitud.getSubproducto());
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_IDTARIFA, solicitud.getIdTarifa());
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_VERSIONGENERAL, solicitud.getVersionGeneral());
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_NUCEXPEDIENTE, solicitud.getDatosSolicitudKey().getNucExpediente());
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_PLAZOTRAMOINICIAL, solicitud.getPlazoTotal());
        resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if (!UtilidadesComun.isBlankOrNull(resultado)) {
            maximaBonificacion = resultado[0].getBigDecimal(ConstantesComun.CTE_SN_CONSULTA_BONIFICACION_PLAZOTRAMOINICIAL_SALIDA);
            if (0 != maximaBonificacion.compareTo(BigDecimal.ZERO)) {
                diferencialBonificado = diferencial.subtract(maximaBonificacion);
            }
        }
        return diferencialBonificado;
    }

    /**
     * Método que llama al EEXP_273 para cambiar el estado de una determinada tarea del Expediente Electrónico.
     *
     * @param nucExpediente
     * @param estado
     */
    public static void cambiarEstadoTareaExpediente(BigDecimal nucExpediente, BigDecimal codProceso, String estado) {
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        IContexto[] resultado = null;
        IDatosEntradaTx datosEntrada = null;
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_CC, ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_CO);
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_ENTRADA_NUC, nucExpediente);
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_ENTRADA_CODIGO_PROCESO, codProceso);
        datosEntrada.addCampo(ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_ENTRADA_NUEVO_ESTADO, estado);
        resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if ((!UtilidadesComun.isBlankOrNull(resultado)) && (!ConstantesGenericas.CTE_STR_0.equals(resultado[0].getString(ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_SALIDA_COD_ERROR)))) {
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_CAMBIAR_ESTADO_EEXP, null, new String[] { resultado[0].getString(ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_SALIDA_COD_ERROR), resultado[0].getString(ConstantesComun.CTE_SN_CAMBIAR_ESTADO_EEXP_SALIDA_DESR_ERROR) }, null);
        }
    }

    /**
     * Método que consulta una lista de valores invocando a IFSN_052
     * indicando su id
     *
     * @return IContexto[]
     */
    public static String getDescripcionElementoListaValores(BigDecimal idLista, String idElemento) {
        String descripcion = null;
        IDatosEntradaTx datosEntrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), CC._107.getIntId(), CO._052.getIntId());
        datosEntrada.addCampo(IFSN_052.IDLISTA.name(), idLista);
        // datosEntrada.addCampo(IFSN_052.IDVALOR.name(), idElemento);
        final IContexto[] resultado = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntrada);
        if ((!UtilidadesComun.isBlankOrNull(resultado)) && (!ConstantesGenericas.CTE_STR_0.equals(resultado[0].getString("")))) {
            for (IContexto contexto : resultado) {
                if (contexto.getString(ConstantesComun.CTE_SN_CONSULTAR_LISTA_VALORES_VALOR).equals(idElemento)) {
                    descripcion = contexto.getString(ConstantesComun.CTE_SN_CONSULTAR_LISTA_ETIQUETA_MULTIIDIOMA);
                }
            }
        }
        return descripcion;
    }

    /**
     * Comprueba si el producto tramitado es un producto de concesionarios. El subproducto es opcional.
     * Si el subproducto va informado comprueba tambien el nivel subproducto, de lo contario solo comprueba el nivel producto.
     *
     * @param producto
     * @return true si es un producto concesionarios, false de lo contrario.
     */
    public static boolean esProductoConcesionarios(String producto, String subproducto) {
        final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_CAMPO_PARAMETRO, producto);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, "CONCESIO");
        final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
        if (!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0 && !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR))) {
            // Si viene informado el campo del subproducto
            if (!UtilidadesTramitacion.isBlankOrNull(subproducto)) {
                if (aContextoParametro[0].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR).equals(subproducto)) {
                    return true;
                } else {
                    return false;
                }
            } else {
                if (!UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR))) {
                    return true;
                } else {
                    return false;
                }
            }
        }
        return false;
    }

    /**
     * Comprueba si la tarifa es Aplazos 11+1. Lo será si el producto, tarifa y plazo recibidos
     * como entrada coinciden con los valores parametrizados en la AN82TB01 para la agrupacion
     * APLAZ_11M1. La tarifa Aplazos 11+1 está parametrizada en la AN82TB01 de la siguiente manera
     * (3 filas en la tabla):
     * <ul>
     * <li>AGRUPACIÓN: APLAZ_11M1</li>
     * <li>PARÁMETRO:  fila 1 = PRODUCTO / fila 2 = TARIFA / fila 3 = PLAZO</li>
     * <li>VALOR:      fila 1 = 1067     / fila 2 = 22     / fila 3 = 11</li>
     * </ul>
     * @param producto producto para el que se comprobara si es Aplazos 11+1
     * @param tarifa tarifa para la que se comprobara si es Aplazos 11+1
     * @param plazo plazo para el que se comprobara si es Aplazos 11+1
     * @return true si la tarifa es Aplazos 11+1, false en caso contrario.
     */
    public static boolean esAplazos11M1(BigDecimal producto, BigDecimal tarifa, BigDecimal plazo) {
        // Inicializaciones
        boolean esAplazos11M1 = false;
        String parametro = null;
        String valor = null;
        String valorProducto = null;
        String valorTarifa = null;
        String valorPlazo = null;
        // Si se reciben producto, tarifa y valor != vacio o null, se consulta la tabla de parametros
        if ((null != producto) && (null != tarifa) && (null != plazo)) {
            // Llamada al servicio de consulta de parametros (ANPM_180)
            IDatosEntradaTx entradaConsultaParametros = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
            entradaConsultaParametros.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, "APLAZ_11M1");
            IContexto[] salidaConsultaParametros = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entradaConsultaParametros);
            // Comprobar resultados
            if ((!UtilidadesTramitacion.isBlankOrNull(salidaConsultaParametros)) && (salidaConsultaParametros.length > 0)) {
                // Obtener producto, tarifa y plazo parametrizados
                for (int i = 0; i < salidaConsultaParametros.length; i++) {
                    parametro = salidaConsultaParametros[i].getString(ConstantesComun.CTXTO_PARAMETRO_PARAMETRO);
                    valor = salidaConsultaParametros[i].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR);
                    if (!UtilidadesTramitacion.isBlankOrNull(parametro) && !UtilidadesTramitacion.isBlankOrNull(valor)) {
                        if (parametro.equals("PRODUCTO")) {
                            valorProducto = valor;
                        } else {
                            if (parametro.equals("TARIFA")) {
                                valorTarifa = valor;
                            } else {
                                if (parametro.equals("PLAZO")) {
                                    valorPlazo = valor;
                                }
                            }
                        }
                    }
                }
                // con los parametrizados
                if (!UtilidadesTramitacion.isBlankOrNull(valorProducto) && !UtilidadesTramitacion.isBlankOrNull(valorTarifa) && !UtilidadesTramitacion.isBlankOrNull(valorPlazo)) {
                    if (valorProducto.equals(producto.toString()) && valorTarifa.equals(tarifa.toString()) && valorPlazo.equals(plazo.toString())) {
                        esAplazos11M1 = true;
                    }
                }
            }
        }
        // Devolver resultado
        return esAplazos11M1;
    }

    /**
     * Método que consulta la tabla de parámetros (CG32TB01) a través del
     * servicio CGAL_373 (CC 100).
     * Si no hay ninguna fila o hay más de una lanza un rollback.
     *
     * @param tabla columna CG320010
     * @param claveDentroTabla columna CG320020
     * @param lanzarRollback, en caso de que no exista el parámetro, si este parámetro
     * 			está a true se lanza rollback, en caso contrario devuelve null.
     * @return Devuelve el contexto CG151CON.
     */
    public static IContexto getParametroUnico(String tabla, String claveDentroTabla, boolean lanzarRollback) {
        IDatosEntradaTx datosEntradaConsultaParam = null;
        IContexto[] resultadoConsultaParam = null;
        IContexto resultado = null;
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        datosEntradaConsultaParam = ServicioNegocio.getPrograma(contextoEjecucion, ConstantesComun.CTE_CC_GESTION_PARAM, ConstantesComun.CTE_CO_GESTION_PARAM);
        datosEntradaConsultaParam.addCampo(ConstantesGenericas.CTE_INT_0, ConstantesGenericas.CTE_STR_C);
        datosEntradaConsultaParam.addCampo(ConstantesGenericas.CTE_INT_1, tabla);
        datosEntradaConsultaParam.addCampo(ConstantesGenericas.CTE_INT_2, claveDentroTabla);
        resultadoConsultaParam = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntradaConsultaParam);
        if (lanzarRollback) {
            if (UtilidadesComun.isBlankOrNull(resultadoConsultaParam)) {
                ServicioNegocio.rollback(CodigosError.CTE_PARAMETRO_NO_EXISTE, null, new String[] { tabla, claveDentroTabla }, null);
            }
            if (!BigDecimal.ZERO.equals(resultadoConsultaParam[0].getBigDecimal("CG151C010"))) {
                ServicioNegocio.rollback(CodigosError.CTE_PARAMETRO_NO_EXISTE, null, new String[] { tabla, claveDentroTabla }, null);
            }
            resultado = resultadoConsultaParam[0];
        } else {
            if ((!UtilidadesComun.isBlankOrNull(resultadoConsultaParam)) && BigDecimal.ZERO.equals(resultadoConsultaParam[0].getBigDecimal("CG151C010"))) {
                resultado = resultadoConsultaParam[0];
            }
        // si no existe devolvemos nulo.
        }
        return resultado;
    }

    /**
     * Método que consulta la tabla de parámetros (CG32TB01) a través del
     * servicio CGAL_373 (CC 100).
     * Si no hay ninguna fila o hay más de una lanza un rollback.
     *
     * @param tabla columna CG320010
     * @param claveDentroTabla columna CG320020
     * @return Devuelve el campo CG151C050 del contexto CG151CON (columna CG320030).
     */
    public static String getParametroUnicoDescr1(String tabla, String claveDentroTabla, boolean lanzarRollback) {
        IContexto contexto = null;
        String descr2 = null;
        contexto = getParametroUnico(tabla, claveDentroTabla, lanzarRollback);
        if (null != contexto) {
            descr2 = contexto.getString("CG151C050").trim();
        }
        return descr2;
    }

    /**
     * Método que consulta la tabla de parámetros (CG32TB01) a través del
     * servicio CGAL_373 (CC 100).
     * Si no hay ninguna fila o hay más de una lanza un rollback.
     *
     * @param tabla columna CG320010
     * @param claveDentroTabla columna CG320020
     * @return Devuelve el campo CG151C0110 del contexto CG151CON (columna CG320090).
     */
    public static BigDecimal getParametroUnicoImporte1(String tabla, String claveDentroTabla, boolean lanzarRollback) {
        IContexto contexto = null;
        BigDecimal imp1 = null;
        contexto = getParametroUnico(tabla, claveDentroTabla, lanzarRollback);
        if (null != contexto) {
            imp1 = contexto.getBigDecimal("CG151C110");
        }
        return imp1;
    }

    /**
     * 	Metodo que obtiene el numero de solicitud a partir de un codigo de contrato de Prestamo.
     *
     * @param contratoPrestamo
     * @return
     */
    public static String obtenerNumeroSolicitud(String contratoPrestamo) {
        // EJEMPLO DE UN NUMERO DE CONTRATO DEPRESTAMO //
        // 
        // 2080 5986 42 500 202715 8
        /*
		 * Codigo Entidad	-----------	2080
		 * Numero de oficina	-------	5986	
		 * Digitos de control	-------	42
		 * Cuenta Contable Prestamos --	500	
		 * Numero Solicitud	-----------	202715
		 * Digito solicitud	-----------	8
		 * 
		 */
        String numeroSolicitud = null;
        if (null != contratoPrestamo && ConstantesComun.CTE_INT_TAM_CONTRATO_PRESTAMO == contratoPrestamo.length()) {
            numeroSolicitud = contratoPrestamo.substring(ConstantesComun.CTE_INT_POS_INIT_NUMERO_SOL, ConstantesComun.CTE_INT_POS_FIN_NUMERO_SOL);
        }
        return numeroSolicitud;
    }

    /**
     * Devuelve verdadero si un prestamo es personal falso en otro caso.
     * @param solicitud
     * @param contexto
     */
    public static boolean esPersonal(DatosSolicitudC solicitud) {
        boolean esPersonal = false;
        IDatosEntradaTx datosEntradaSrvTipoExpediente = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_TIPO_EXPEDIENTE, IConstantesTramitacion.CTE_CO_CONSULTA_TIPO_EXPEDIENTE);
        datosEntradaSrvTipoExpediente.addCampo(IConstantesTramitacion.CTE_CAMPO_TIPO_EXPEDIENTE, solicitud.getTipoExpediente().toString());
        String tipoExpediente = new String();
        IContexto[] salidaSrvTipoExpediente = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaSrvTipoExpediente);
        if (!UtilidadesTramitacion.isBlankOrNull(salidaSrvTipoExpediente)) {
            tipoExpediente = salidaSrvTipoExpediente[0].getString("ANPMN079010");
            if (tipoExpediente.trim().equals("P")) {
                esPersonal = true;
            } else if (tipoExpediente.trim().equals("H")) {
                esPersonal = false;
            } else {
                esPersonal = false;
            }
        }
        return esPersonal;
    }

    /**
     * Devuelve verdadero si un prestamo es personal falso en otro caso.
     * @param ctxtSolicitud
     */
    public static boolean esPersonal(IContexto ctxtSolicitud) {
        boolean esPersonal = false;
        String tipoExpediente = ctxtSolicitud.getBigDecimal("ANPMN050270").toString();
        IDatosEntradaTx datosEntradaSrvTipoExpediente = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_TIPO_EXPEDIENTE, IConstantesTramitacion.CTE_CO_CONSULTA_TIPO_EXPEDIENTE);
        datosEntradaSrvTipoExpediente.addCampo(IConstantesTramitacion.CTE_CAMPO_TIPO_EXPEDIENTE, tipoExpediente);
        String tipoExpedienteSalida = new String();
        IContexto[] salidaSrvTipoExpediente = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaSrvTipoExpediente);
        if (!UtilidadesTramitacion.isBlankOrNull(salidaSrvTipoExpediente)) {
            tipoExpedienteSalida = salidaSrvTipoExpediente[0].getString("ANPMN079010");
            if (tipoExpedienteSalida.trim().equals("P")) {
                esPersonal = true;
            } else if (tipoExpedienteSalida.trim().equals("H")) {
                esPersonal = false;
            } else {
                esPersonal = false;
            }
        }
        return esPersonal;
    }

    /**
     * @return
     */
    public static BigDecimal obtenerNivelMaximoPreciosTarifa(DatosSolicitudC datosSolicitud, IContexto[] contextosPrecios) {
        BigDecimal nivelMaximo = null;
        int ordenTramoInteres = ConstantesComun.CTE_INT_CERO;
        String tipoInteresInteres = null;
        BigDecimal tipoReferenciaInteres = null;
        BigDecimal interesFijo = null;
        BigDecimal interesFijoVarNoRef = null;
        BigDecimal diferencialInteres = null;
        // 0: Fijo, 1: Variable, 2: Variable no referenciado.
        int tipoInteres = -1;
        BigDecimal valorDesdePrecio = null;
        BigDecimal valorHastaPrecio = null;
        String descripcionErrorFueraRangoTarifa = null;
        BigDecimal nivelInteres = null;
        int ordenTramoPrecio = ConstantesComun.CTE_INT_CERO;
        String tipoInteresPrecio = null;
        String identificadorPrecio = null;
        List<CondicionesInteresC> listaIntereses = null;
        /*Recorremos la lista de intereses y buscamos el precio a aplicar en el array de precios de tarifa.*/
        listaIntereses = datosSolicitud.getCondicionesInteres();
        for (CondicionesInteresC condicionesInteres : listaIntereses) {
            ordenTramoInteres = condicionesInteres.getCondicionesInteresKey().getIntOrdenDelTramo().intValue();
            tipoInteresInteres = condicionesInteres.getStrTipoDeInteres();
            tipoReferenciaInteres = new BigDecimal(condicionesInteres.getIntTipoReferencia());
            interesFijo = condicionesInteres.getIntInteres();
            interesFijoVarNoRef = condicionesInteres.getIntTecho();
            diferencialInteres = condicionesInteres.getIntDif();
            for (IContexto precioTarifa : contextosPrecios) {
                tipoInteresPrecio = UtilidadesTramitacion.comprobarDatoNull(precioTarifa.getString(ConstantesComun.CTE_CTX_PRECIO_TARIFA_TIPO_INTERES));
                ordenTramoPrecio = precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_ORDEN_TRAMO).intValue();
                identificadorPrecio = UtilidadesTramitacion.comprobarDatoNull(precioTarifa.getString(ConstantesComun.CTE_CTX_PRECIO_TARIFA_IDENT_CONDICION));
                valorDesdePrecio = precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_VALOR_DESDE);
                valorHastaPrecio = precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_VALOR_HASTA);
                // filtramos por orden de tramo y tipo de interés (el char de 2. 00: fijo, 02: variable, 03: variable bonificable,...)
                if (((ordenTramoInteres == ordenTramoPrecio)) && (tipoInteresInteres.equals(tipoInteresPrecio))) {
                    // ahora miramos el tipo de condición, si es INT es un precio de interés fijo, si es DIF es un diferencial.
                    if (ConstantesComun.CTE_PRECIO_TARIFA_TIPO_FIJO.equals(identificadorPrecio)) {
                        tipoInteres = ConstantesComun.CTE_TIPO_INTERES_FIJO;
                        // miramos si este tramo fijo está en el rango que estamos recorriendo.
                        if (datoEnRangoTarifa(interesFijo, valorDesdePrecio, valorHastaPrecio)) {
                            // esto puede pasar cuando un valor está en más de un rango.
                            if ((null == nivelInteres) || (0 < nivelInteres.compareTo(precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_NIVEL)))) {
                                nivelInteres = precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_NIVEL);
                            }
                        }
                    } else if (ConstantesComun.CTE_PRECIO_TARIFA_TIPO_VARIABLE.equals(identificadorPrecio)) {
                        /*si es un tramo variable pero el tipo de referencia es no referenciado, lo que tenemos que comprobar si está en rango
						es el interés fijo, pero en este caso está en el campo techo del interés, y realmente, aunque el precio tenga identificador "DIF",
						en realidad lo que se está guardando en este precio es el interés fijo de este tramo variable no referenciado.
						*/
                        if (GestionConsultaDatosSolicitud.esTipoReferenciaNoReferenciado(tipoReferenciaInteres.toString())) {
                            tipoInteres = ConstantesComun.CTE_TIPO_INTERES_VARIABLE_NO_REFERENCIADO;
                            // miramos si este tramo variable no referenciado está en el rango que estamos recorriendo.
                            if (datoEnRangoTarifa(interesFijoVarNoRef, valorDesdePrecio, valorHastaPrecio)) {
                                // esto puede pasar cuando un valor está en más de un rango.
                                if ((null == nivelInteres) || (0 < nivelInteres.compareTo(precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_NIVEL)))) {
                                    nivelInteres = precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_NIVEL);
                                }
                            }
                        } else {
                            tipoInteres = ConstantesComun.CTE_TIPO_INTERES_VARIABLE;
                            // miramos si este tramo variable normal está en el rango que estamos recorriendo.
                            if (datoEnRangoTarifa(diferencialInteres, valorDesdePrecio, valorHastaPrecio)) {
                                // esto puede pasar cuando un valor está en más de un rango.
                                if ((null == nivelInteres) || (0 < nivelInteres.compareTo(precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_NIVEL)))) {
                                    nivelInteres = precioTarifa.getBigDecimal(ConstantesComun.CTE_CTX_PRECIO_TARIFA_NIVEL);
                                }
                            }
                        }
                    }
                }
            }
            /*aqui tenemos dos opciones:
			  - Que el dato de interés del tramo que estamos recorriendo esté en un nivel válido, es decir, que esté en un rango.
			  - Que no esté en un nivel, es decir, que no esté en ningún rango.
			 Si no está en ningún rango cascamos.
			*/
            if (null == nivelInteres) {
                /*
				 * Mensajes de error cuando el precio introducido no está en rango:
				 *  - Cuando es un tramo fijo: El interés fijo introducido en el tramo {0} no está en rango.
				 *  - Cuando es un tramo variable normal: El diferencial introducido en el tramo {0} no está en rango.
				 *  - Cuando es un tramo variable no referenciado: El interés fijo introducido en el techo del tramo {0} no está en rango.
				 * 
				 * Descripción error CGDN: {0} tramo {1} no está en rango.
				 * 
				 * */
                if (ConstantesComun.CTE_TIPO_INTERES_FIJO == tipoInteres) {
                    descripcionErrorFueraRangoTarifa = new Mensaje(ServicioNegocio.getContexto(), INTER_S_FIJO_INTRODUCIDO_1585418128).toString();
                } else if (ConstantesComun.CTE_TIPO_INTERES_VARIABLE == tipoInteres) {
                    descripcionErrorFueraRangoTarifa = new Mensaje(ServicioNegocio.getContexto(), DIFERENCIAL_INTRODUCIDO_1189610890).toString();
                } else if (ConstantesComun.CTE_TIPO_INTERES_VARIABLE_NO_REFERENCIADO == tipoInteres) {
                    descripcionErrorFueraRangoTarifa = new Mensaje(ServicioNegocio.getContexto(), INTER_S_FIJO_INTRODUCIDO_TECHO_1655471895).toString();
                }
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_PRECIO_TARIFA_FUERA_DE_RANGO, null, new String[] { descripcionErrorFueraRangoTarifa, condicionesInteres.getCondicionesInteresKey().getIntOrdenDelTramo().toString() }, null);
            } else {
                if (null == nivelMaximo) {
                    nivelMaximo = nivelInteres;
                } else {
                    /*Si el nivel actual es más grande que el máximo.*/
                    if (0 < nivelInteres.compareTo(nivelMaximo)) {
                        nivelMaximo = nivelInteres;
                    }
                }
            }
            // si no es nulo quiere decir que tenemos que actualizar el nivel correspondiente, que según el tipo de tramo será uno u otro.
            // finalmente reseteamos el nivel interés.
            nivelInteres = null;
        }
        return nivelMaximo;
    }

    /**
     * Recupera un parametro de la tabla de parametros cag.an82tb01
     * @param nombreProducto
     * @param agrupacionParametro
     * @return
     */
    public static String consultaParametro(String nombreParametro, String agrupacionParametro) {
        final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
        if (!UtilidadesComun.isBlankOrNull(nombreParametro)) {
            datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_CAMPO_PARAMETRO, nombreParametro);
        }
        if (!UtilidadesComun.isBlankOrNull(agrupacionParametro)) {
            datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, agrupacionParametro);
        }
        final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
        if (!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0 && !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR))) {
            // Si viene informado el campo del subproducto
            return aContextoParametro[0].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR).trim();
        }
        return new String();
    }

    /**
     * Método que devuelve los registros correspondientes a una agrupación
     *
     * @param agrupacion
     * @return
     */
    public static IContexto[] consultaAgrupacion(String agrupacion) {
        IContexto[] salida = null;
        IDatosEntradaTx entrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
        if (StringUtils.isNotBlank(agrupacion)) {
            entrada.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, agrupacion);
            salida = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
        }
        return salida;
    }

    /**
     * Para un contexto con los registros de la 82, consulta un parámetro y devuelve su valor.
     *
     * @param parametro
     * @param ANPMN031
     * @return
     */
    public static String consultaParametroAgrupacion(String parametro, IContexto[] ANPMN031) {
        String valor = null;
        if (null != parametro && null != ANPMN031) {
            for (IContexto registro : ANPMN031) {
                if (null != registro.getString("ANPMN031040") && 0 == parametro.compareTo(registro.getString("ANPMN031040").trim())) {
                    valor = registro.getString("ANPMN031050");
                }
            }
        }
        return valor;
    }

    /**
     * Estará en el rango si:
     *
     * valorDesde <= datoValidar <= valorHasta
     *
     * Es decir:
     *
     * valorDesde <= datoValidar && datoValidar <= valorHasta
     *
     * @param interesFijoVarNoRef
     * @param valorDesdePrecio
     * @param valorHastaPrecio
     * @return
     */
    public static boolean datoEnRangoTarifa(BigDecimal datoValidar, BigDecimal valorDesde, BigDecimal valorHasta) {
        boolean estaEnRango = false;
        estaEnRango = (0 >= valorDesde.compareTo(datoValidar)) && (0 >= datoValidar.compareTo(valorHasta));
        return estaEnRango;
    }

    /**
     * 	Devuelve el codigo Bic de la entidad
     *
     * @return
     */
    public static String obtenerCodigoBic() {
        String codigoBic = "";
        codigoBic = Configuracion.getInstance().getValor(ConstantesComun.CTE_COD_APP_CGAL, ConstantesComun.CTE_AGRUP_ENTIDAD, ConstantesComun.CTE_PARAM_ENTIDAD_SWIFT_BIC).trim();
        return codigoBic;
    }

    /**
     * Reserva memoria en el contexto para el registro que se pasa como parámetro
     * @param contexto Contexto donde reservar memoria
     * @param strCtxtoIdRegistro Id del registro a crear
     * @param iRegistrosSize Número de registros a crear
     */
    public static void reservarMemoriaRegistro(IContexto contexto, String strCtxtoIdRegistro, int iRegistrosSize) {
        List<IRegistro> lstRegistros = new ArrayList<IRegistro>(iRegistrosSize);
        for (int i = 0; i < iRegistrosSize; i++) {
            lstRegistros.add(ContextoFactory.getInstance().getRegistro(contexto, strCtxtoIdRegistro));
        }
        contexto.put(strCtxtoIdRegistro, lstRegistros.toArray(new IRegistro[lstRegistros.size()]));
    }

    /**
     * Inovca al servicio de negocio ANPM_505 para obtener el tipo de referencia en prestamos internacionales
     * @param datosSolicitud
     * @return
     */
    public static String obtenerFechaPublicacionTipoReferenciaDivisa(DatosSolicitudC datosSolicitud, CondicionesInteresC condicionesInteres) {
        String fechaPublicacion = null;
        IDatosEntradaTx datosEntradaTx = null;
        IContexto[] datosSalidaTx = null;
        datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), new Integer(ConstantesComun.CTE_INT_CC_ANPM), new Integer(ConstantesComun.CTE_INT_COP_OBTENER_TIPO_REF_CO_DIVISA));
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getMonedaImporteSolicitado())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_DIVISA, datosSolicitud.getMonedaImporteSolicitado());
        }
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getGarantiaContable())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_GARANTIA, datosSolicitud.getGarantiaContable().toString());
        }
        // Si la fecha de formalizacion es distinta de nula se mete la de formalizacion sino la de solicitud
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getFechaFormalizacion()) && !((datosSolicitud.getFechaFormalizacion().toString().trim()).equals(DateUtils.CTE_DATELOWESTONLYDAY))) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_FECHA, datosSolicitud.getFechaFormalizacion().toString());
        } else if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getFechaSolicitud())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_FECHA, datosSolicitud.getFechaSolicitud().toString());
        }
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getPlazoTotal())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_PLAZO_MAXIMO_MESES, new BigDecimal(condicionesInteres.getIntNumPeriodosRevision()));
        }
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getImporteSolicitado())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_IMPORTE_MAXIMO, datosSolicitud.getImporteSolicitado());
        }
        datosSalidaTx = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
        if ((null != datosSalidaTx) && (0 < datosSalidaTx.length)) {
            fechaPublicacion = datosSalidaTx[0].getString("ANPMN505030");
        }
        return fechaPublicacion;
    }

    /**
     * Se llama al servicio EEXP_273 que actualiza el estado de la tarea
     * @param datosSolicitud
     */
    public static void actualizarEstadoTarea(BigDecimal nuc, BigDecimal codigoProceso, String estadoTarea) {
        // Comprobamos si esta la informacion previa impresa para poder cambiar a finalizada la tarea.
        IContexto ctxEntrada = null;
        Timestamp timestamp = null;
        String timestampStr = null;
        IContextoEjecucion ctxEjecucion = null;
        timestamp = DateHelper.getInstance().askTimestampFromDB2();
        timestampStr = DateHelper.timestampToString(timestamp, DateHelper.FORMATO_DB2_TIMESTAMP);
        ctxEjecucion = ServicioNegocio.getContexto();
        /*Informamos el contexto de entrada*/
        ctxEntrada = ContextoFactory.getInstance().getContexto(ConstantesComun.E_CTX_EE114CON);
        ctxEntrada.put(ConstantesComun.E_R114_OPERACION, ConstantesComun.EXP_OPE_MODIFICAR);
        ctxEntrada.put(ConstantesComun.E_R114_NUC, nuc);
        ctxEntrada.put(ConstantesComun.E_R114_PROCESO, codigoProceso);
        ctxEntrada.put(ConstantesComun.E_R114_ESTADO, estadoTarea);
        ctxEntrada.put(ConstantesComun.E_R114_TIMESTAMP, timestampStr);
        ctxEntrada.put(ConstantesComun.E_R114_TERMINAL, ctxEjecucion.getTerminal());
        ctxEntrada.put(ConstantesComun.E_R114_USUARIO, ctxEjecucion.getUsuario());
        // ctxEntrada.put(E_R114_COD_ERROR, BigDecimal.ZERO);
        // ctxEntrada.put(E_R114_TEX_ERROR, StringUtils.EMPTY);
        /*Invocamos el EEXPR114*/
        IContexto[] salidaServicio = ctgFacade.invocarProgramaCics(ctxEntrada, ConstantesComun.CTE_EEXPR114);
        if ((null == salidaServicio) || (!BigDecimal.ZERO.equals(salidaServicio[0].getBigDecimal(ConstantesComun.E_R114_COD_ERROR)))) {
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_CAMBIO_ESTADO_EEXP, null, new String[] { nuc.toString() }, null);
        }
    }

    /**
     * Este metodo devuelve verdadero cuando la informacion previa esta impresa cuando es necesaria
     * @param datosSolicitudC
     * @return
     */
    public static boolean comprobarInformacionPreviaImpresa(DatosSolicitudC datosSolicitudC) {
        if (null != datosSolicitudC) {
            // Si la info previa es necesaria
            if (datosSolicitudC.getNecesidadInfo().equals(ConstantesComun.CTE_STR_S) && datosSolicitudC.getDateFechaImpresion().toString().equals(DateUtils.CTE_DATELOWESTONLYDAY)) {
                return false;
            } else if (!datosSolicitudC.getNecesidadInfo().equals(ConstantesComun.CTE_STR_S)) {
                return true;
            }
        } else {
            return false;
        }
        return true;
    }

    /**
     * Obtiene el estado de la tarea de expediente electronico
     * @param nucExpediente
     * @param codigoProceso
     * @return
     */
    public static String obtenerEstadoTarea(BigDecimal nucExpediente, BigDecimal codigoProceso) {
        String estadoTarea = null;
        IContexto[] resultado = null;
        IDatosEntradaTx datosEntrada = null;
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, ConstantesComun.CTE_INT_CC_EEXP, ConstantesComun.CTE_INT_COP_OBTENER_ESTADO_TAREA);
        datosEntrada.addCampo(ConstantesComun.CTE_NUC, nucExpediente);
        datosEntrada.addCampo(ConstantesComun.CTE_CODIGO_PROCESO, codigoProceso);
        resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if (!UtilidadesTramitacion.isBlankOrNull(resultado)) {
            if (ConstantesComun.CTE_STR_0.equals(resultado[0].getString(ConstantesComun.CTE_SALIDA_CONS_ESTADO_TAREA_COD_ERROR))) {
                estadoTarea = resultado[0].getString(ConstantesComun.CTE_SALIDA_CONS_ESTADO_TAREA_ESTADO);
            }
        }
        return estadoTarea;
    }

    /**
     * Inovca al servicio de negocio ANPM_505 para obtener el tipo de referencia en prestamos internacionales
     * @param datosSolicitud
     * @return
     */
    public static BigDecimal obtenerInteresTipoReferenciaDivisa(DatosSolicitudC datosSolicitud, CondicionesInteresC condicionesInteres) {
        BigDecimal interesTipoReferencia = null;
        IDatosEntradaTx datosEntradaTx = null;
        IContexto[] datosSalidaTx = null;
        datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), new Integer(ConstantesComun.CTE_INT_CC_ANPM), new Integer(ConstantesComun.CTE_INT_COP_OBTENER_TIPO_REF_CO_DIVISA));
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getMonedaImporteSolicitado())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_DIVISA, datosSolicitud.getMonedaImporteSolicitado());
        }
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getGarantiaContable())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_GARANTIA, datosSolicitud.getGarantiaContable().toString());
        }
        // Si la fecha de formalizacion es distinta de nula se mete la de formalizacion sino la de solicitud
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getFechaFormalizacion()) && !datosSolicitud.getFechaFormalizacion().toString().equals(DateUtils.CTE_DATELOWESTONLYDAY)) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_FECHA, datosSolicitud.getFechaFormalizacion().toString());
        } else if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getFechaSolicitud())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_FECHA, datosSolicitud.getFechaSolicitud().toString());
        }
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getPlazoTotal())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_PLAZO_MAXIMO_MESES, new BigDecimal(condicionesInteres.getIntNumPeriodosRevision()));
        }
        if (!UtilidadesTramitacion.isBlankOrNull(datosSolicitud.getImporteSolicitado())) {
            datosEntradaTx.addCampo(ConstantesComun.CTE_SN_OBTENER_TIPO_REF_DIVISA_ENTRADA_IMPORTE_MAXIMO, datosSolicitud.getImporteSolicitado());
        }
        datosSalidaTx = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
        if ((null != datosSalidaTx) && (0 < datosSalidaTx.length)) {
            interesTipoReferencia = datosSalidaTx[0].getBigDecimal("ANPMN505080");
        }
        return interesTipoReferencia;
    }

    /**
     * Método que llama al servicio ANPM_075 para obtener el parámetros de la AN82TB01.
     *
     * @param agrupacion
     * @param nombreParametro
     *
     * @return valorParametro
     */
    public static IContexto[] obtenerParametroANPM(String agrupacion, String nombreParametro) {
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        IDatosEntradaTx datosEntrada = null;
        IContexto[] resultadosParam = null;
        /*Llamamos al ANPM_075 para obtener el listado de productos destino, si existe.*/
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, Constantes.CTE_SN_BUSQ_PARAM_CC, Constantes.CTE_SN_BUSQ_PARAM_CO);
        datosEntrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_NOMBRE, nombreParametro);
        datosEntrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_AGRUP, agrupacion);
        resultadosParam = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        return resultadosParam;
    }

    /**
     * Metodo que llama al servicio ANPM_075 para devolver la entidad de Abanca
     *
     * @return
     */
    public static String obtieneEntidadAbanca() {
        String entidadAbanca = "";
        IContexto[] contextoSalidaANPM = null;
        // LLamada al servicio ANPM_075 para obtener la entidad asociada a ABANCA
        IDatosEntradaTx datosEntradaANPM075 = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_ENTIDAD_INTERNA);
        datosEntradaANPM075.addCampo(ConstantesComun.CTE_COP_NOMBRE_PARAMETRO, ConstantesComun.NOMBRE_PARAMETRO);
        datosEntradaANPM075.addCampo(ConstantesComun.CTE_COP_AGRUPACION_PARAMETRO, ConstantesComun.AGRUPACION_PARAMETRO);
        contextoSalidaANPM = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaANPM075);
        if (!UtilidadesComun.isBlankOrNull(contextoSalidaANPM)) {
            entidadAbanca = contextoSalidaANPM[0].getString(ConstantesComun.VALOR_ENTIDAD);
        }
        return entidadAbanca;
    }

    /**
     * Metodo que llama al servicio RAJE_069 para obtener la divisa de la cuenta.
     *
     * @param cuenta
     * @return
     */
    public static String buscaDivisa(String cuenta) {
        IContexto[] contextoSalidaRAJE = null;
        String divisa = "";
        IDatosEntradaTx datosEntradaRAJE069 = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_RAJE, ConstantesComun.CTE_INT_COP_CONSULTA_DATOS_GENERALES_CUENTAS);
        datosEntradaRAJE069.addCampo(ConstantesComun.CTE_COP_LISTA_CUENTAS, cuenta);
        contextoSalidaRAJE = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaRAJE069);
        // Si devuelve valor cogemos el correspondiente a la divisa de esa cuenta.
        if (!UtilidadesTramitacion.isBlankOrNull(contextoSalidaRAJE) && null != contextoSalidaRAJE[0].getString(ConstantesComun.CTE_CTX_CODIGO_MONEDA)) {
            divisa = contextoSalidaRAJE[0].getString(ConstantesComun.CTE_CTX_CODIGO_MONEDA).trim();
        }
        return divisa;
    }

    /**
     * Metodo que llama al servicio CRTO_144 para obtener la divisa de la cuenta.
     *
     * @param cuenta
     * @return
     */
    public static String buscaDivisaCreditos(String oficina, String numero) {
        IContexto[] contextoSalidaCRTO = null;
        String divisa = "";
        IDatosEntradaTx datosEntradaCRTO144 = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_CRTO, ConstantesComun.CTE_INT_COP_CONSULTA_DATOS_GENERALES_CREDITOS);
        datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_OFICINA_1, oficina);
        datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_NUMERO_1, numero);
        datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_DIVISION_1, BigDecimal.ZERO);
        datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_SUBDIVISION_1, BigDecimal.ZERO);
        contextoSalidaCRTO = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaCRTO144);
        // Si devuelve valor cogemos el correspondiente a la divisa de esa cuenta.
        if (!UtilidadesTramitacion.isBlankOrNull(contextoSalidaCRTO) && null != contextoSalidaCRTO[0].getString(ConstantesComun.CTE_CTX_CODIGO_MONEDA_CTRO)) {
            divisa = contextoSalidaCRTO[0].getString(ConstantesComun.CTE_CTX_CODIGO_MONEDA_CTRO).trim();
        } else if (null == contextoSalidaCRTO[0].getString(ConstantesComun.CTE_CTX_CODIGO_MONEDA_CTRO)) {
            divisa = ServicioNegocio.getContexto().getCodigoContable();
        }
        return divisa;
    }

    /**
     * Metodo que llama al servicio ITAL_601 para buscar el pais con una cuenta IBAN.
     *
     * @param cuentaIBAN
     * @return
     */
    public static BigDecimal buscaCodPais(String cuentaIBAN) {
        String strPais = "";
        BigDecimal codPais = BigDecimal.ZERO;
        IContexto[] contextoSalidaITAL = null;
        if (!UtilidadesComun.isBlankOrNull(cuentaIBAN)) {
            strPais = cuentaIBAN.substring(0, 2);
            // LLamada al servicio ITAL_601 para consultar el codigo del pais.
            IDatosEntradaTx datosEntradaITAL601 = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ITAL, ConstantesComun.CTE_INT_COP_ITAL_CONSULTA_PAIS);
            datosEntradaITAL601.addCampo(ConstantesComun.CTE_COP_CODIGO_CONTROL, ConstantesComun.CODIGO_CONTROL);
            datosEntradaITAL601.addCampo(ConstantesComun.CTE_COP_INF_ABREVIADA, ConstantesComun.INF_ABREVIADA);
            datosEntradaITAL601.addCampo(ConstantesComun.CTE_COP_COD_ISO, strPais);
            contextoSalidaITAL = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaITAL601);
            // Si devuelve algun valor cogemos el codigo interno para el pais.
            if (!UtilidadesComun.isBlankOrNull(contextoSalidaITAL)) {
                codPais = contextoSalidaITAL[0].getBigDecimal(ConstantesComun.CTE_CTX_CODIGO_INTERNO_CXG);
            }
        }
        return codPais;
    }

    /**
     * Metodo que invoca el servicio ANPM_469 para obtener el id de domiciliacion.
     *
     * @return
     */
    public static BigDecimal obtenerIdDomiciliacion() {
        BigDecimal idDomiciliacion = ConstantesComun.CTE_BID_0;
        IContexto[] contextoSalida = null;
        IDatosEntradaTx entrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_OBTENER_ID_DOMICILIACION);
        contextoSalida = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
        if (!UtilidadesComun.isBlankOrNull(contextoSalida)) {
            idDomiciliacion = contextoSalida[0].getBigDecimal(ConstantesComun.CTE_CAMPO_ANPMN469010);
        }
        return idDomiciliacion;
    }

    /**
     * Llama al servicio de comprobacion de la correcion del KYC y devuelve un rollback si alguna de las cuentas tiene el KYC incompleto
     * @param iban
     */
    public static void Raje069compruebaKyc(List<String> cuentasIban) {
        if (null != cuentasIban && cuentasIban.size() > 0) {
            for (String iban : cuentasIban) {
                if (!StringUtils.isBlank(iban)) {
                    if (iban.substring(14, 17).equals("550")) {
                        // Si es una cuenta de creditos lo hacemos por el servicio de negocio de CRTO
                        Crto144compruebaKyc(iban);
                    } else {
                        String strCuenta = iban.substring(14, 23);
                        // Inicializamos los campos del SRV
                        IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_RAJE, ConstantesComun.CTE_INT_COP_CONSULTA_DATOS_GENERALES_CUENTAS);
                        // Campo de entrada numero de cliente
                        datosEntradaTx.addCampo(ConstantesComun.CTE_COP_LISTA_CUENTAS, strCuenta);
                        // Invocar el srv
                        IContexto[] salidaComprobarKYC = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
                        if (null != salidaComprobarKYC) {
                            for (IContexto ctxtComprobarkyc : salidaComprobarKYC) {
                                if (null != ctxtComprobarkyc.getString(ConstantesComun.CTE_CTX_RAJEN007_ESTADO_KYC_RAJEN007250)) {
                                    if (ctxtComprobarkyc.getString(ConstantesComun.CTE_CTX_RAJEN007_ESTADO_KYC_RAJEN007250).subSequence(55, 56).equals(ConstantesComun.CTE_STR_0) || ctxtComprobarkyc.getString(ConstantesComun.CTE_CTX_RAJEN007_ESTADO_KYC_RAJEN007250).subSequence(56, 57).equals(ConstantesComun.CTE_STR_0)) {
                                        ServicioNegocio.rollback(CodigosError.CTE_COD_MSG_ERROR_KYC_INCOMPLETO, null, null, null);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Metodo que llama al servicio CRTO_144 para obtener la divisa de la cuenta.
     *
     * @param cuenta
     * @return
     */
    public static void Crto144compruebaKyc(String iban) {
        IContexto[] contextoSalidaCRTO = null;
        String oficina = "";
        // String cuenta = "";
        String numero = "";
        if (!StringUtils.isBlank(iban)) {
            IDatosEntradaTx datosEntradaCRTO144 = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_CRTO, ConstantesComun.CTE_INT_COP_CONSULTA_DATOS_GENERALES_CREDITOS);
            numero = iban.substring(17, 23);
            oficina = iban.substring(8, 12);
            datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_OFICINA_1, oficina);
            datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_NUMERO_1, numero);
            datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_DIVISION_1, BigDecimal.ZERO);
            datosEntradaCRTO144.addCampo(ConstantesComun.CTE_COP_SUBDIVISION_1, BigDecimal.ZERO);
            contextoSalidaCRTO = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaCRTO144);
            if (null != contextoSalidaCRTO) {
                for (IContexto ctxtComprobarkyc : contextoSalidaCRTO) {
                    if (null != ctxtComprobarkyc.getString(ConstantesComun.CTE_CTX_RAJEN007_ESTADO_KYC_CRTON007250)) {
                        if (ctxtComprobarkyc.getString(ConstantesComun.CTE_CTX_RAJEN007_ESTADO_KYC_CRTON007250).subSequence(55, 56).equals(ConstantesComun.CTE_STR_0) || ctxtComprobarkyc.getString(ConstantesComun.CTE_CTX_RAJEN007_ESTADO_KYC_CRTON007250).subSequence(56, 57).equals(ConstantesComun.CTE_STR_0)) {
                            ServicioNegocio.rollback(CodigosError.CTE_COD_MSG_ERROR_KYC_INCOMPLETO, null, null, null);
                        }
                    }
                }
            }
        }
    }

    /**
     * Metodo que llama al servicio EEXP_272 para consultar los datos de
     *  expediente de un nuc
     *
     * @param nuc
     * @return
     */
    public static IContexto[] ConsultaExpediente(BigDecimal nuc) {
        IDatosEntradaTx datosEntradaEEXP_272 = null;
        IContexto[] contextoSalidaEEXP_272 = null;
        datosEntradaEEXP_272 = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_EEXP, ConstantesComun.CTE_INT_COP_CONSULTA_EXPEDIENTE);
        datosEntradaEEXP_272.addCampo(0, nuc);
        contextoSalidaEEXP_272 = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaEEXP_272);
        return contextoSalidaEEXP_272;
    }

    /**
     * Metodo que invoca el servicio ANPM_471 para comprobar los prescriptores
     *
     * @param nuc
     * @param paso
     * @return
     */
    public static IContexto[] comprobacionPrescriptores(BigDecimal nuc, BigDecimal paso) {
        IDatosEntradaTx datosEntrada = null;
        IContexto[] contextoSalida = null;
        datosEntrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_COMPROBACION_PRESC);
        datosEntrada.addCampo(0, nuc);
        datosEntrada.addCampo(4, paso);
        contextoSalida = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntrada);
        return contextoSalida;
    }

    /**
     * 	Si la poliza esta enviada no se puede modificar en oficina.
     * @param datoGeneral
     */
    public static void comprobacionPolizaEnviada(DatosgeneralesC datoGeneral) {
        // Si la poliza esta enviada no se puede modificar
        if (datoGeneral.getEstado().equals(IConstantesEnotario.CTE_ESTADO_03)) {
            ServicioNegocio.rollback(IConstantesEnotario.CTE_ERROR_POLIZA_ENVIADA, null, null, null);
        }
    }

    /**
     * Metodo que suma un numero de dias a una fecha, y devuelve la fecha resultante.
     *
     * @param fecha fecha a la que se sumaran los dias.
     * @param dias numero de dias a sumar a la fecha.
     * @return fecha resultado de sumar a la fecha recibida como parametro el numero
     *         de dias indicado en la entrada.
     */
    public static Date sumarFechaDias(Date fecha, int dias) {
        Calendar cal = new GregorianCalendar();
        cal.setTimeInMillis(fecha.getTime());
        cal.add(Calendar.DATE, dias);
        return new Date(cal.getTimeInMillis());
    }

    public static String obtenerNumOficina(String contratoPrestamo) {
        // EJEMPLO DE UN NUMERO DE CONTRATO DEPRESTAMO //
        // 
        // 20805986425002027158
        /*
		 * Codigo Entidad	-----------	2080
		 * Numero de oficina	-------	5986	
		 * Digitos de control	-------	42
		 * Cuenta Contable Prestamos --	500	
		 * Numero Solicitud	-----------	202715
		 * Digito solicitud	-----------	8
		 * 
		 */
        String numeroOficina = null;
        if (null != contratoPrestamo && ConstantesComun.CTE_INT_TAM_CONTRATO_PRESTAMO == contratoPrestamo.length()) {
            numeroOficina = contratoPrestamo.substring(ConstantesComun.CTE_INT_POS_INIT_NUM_OFI, ConstantesComun.CTE_INT_POS_FIN_NUM_OFI);
        }
        return numeroOficina;
    }

    /*
	 * Método que compara los parámetros de entrada con la agrupación ANPMCFG_EDUCREDITO_COLECTIVO
	 * 
	 * 
	 * */
    public static boolean coincideEducredito(String producto, String colectivo, String lineaColectivo) {
        String parametroConfiguracion = null;
        boolean comparacion = false;
        parametroConfiguracion = Configuracion.getInstance().getValor(ConstantesComun.CTE_APLICACION_COD_ENT, ConstantesComun.CTE_GRUPO_CONFIG_COD_ENT, ConstantesComun.CTE_PARAM_CONFIG_COD_PARAM).trim();
        if (null != parametroConfiguracion) {
            String productoParam = parametroConfiguracion.substring(3, 7);
            String colectivoParam = parametroConfiguracion.substring(11, 14);
            String lineaColectivoParam = parametroConfiguracion.substring(17, 21);
            if ((producto.equals(productoParam)) && (colectivo.equals(colectivoParam)) && (lineaColectivo.equals(lineaColectivoParam))) {
                comparacion = true;
            }
        }
        return comparacion;
    }

    /**
     * Comprueba si el producto tramitado es un producto de comunidad de propietarios. El subproducto es opcional.
     * Si el subproducto va informado comprueba tambien el nivel subproducto, de lo contario solo comprueba el nivel producto.
     *
     * @param producto
     * @param subproducto
     *
     * @return true si es un producto de comunidad de propietarios, false de lo contrario.
     */
    public static boolean esProductoEducredito(String producto, String subproducto) {
        boolean resultado = false;
        final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_CAMPO_PARAMETRO, producto);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, "EDUCREDITO");
        final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
        if (!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0) {
            // Si viene informado el campo del subproducto
            if (!UtilidadesTramitacion.isBlankOrNull(subproducto)) {
                for (IContexto contxAuxiliar : aContextoParametro) {
                    if (contxAuxiliar.getString(ConstantesComun.CTXTO_PARAMETRO_VALOR).equals(subproducto)) {
                        resultado = true;
                        break;
                    }
                }
            } else {
                resultado = false;
            }
        }
        return resultado;
    }

    /**
     * Comprueba si el producto tramitado es un producto de comunidad de propietarios. El subproducto es opcional.
     * Si el subproducto va informado comprueba tambien el nivel subproducto, de lo contario solo comprueba el nivel producto.
     *
     * @param producto
     * @param subproducto
     *
     * @return true si es un producto de comunidad de propietarios, false de lo contrario.
     */
    public static boolean esProductoComunidadPropietarios(String producto, String subproducto) {
        boolean resultado = false;
        final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_CAMPO_PARAMETRO, producto);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, ConstantesComun.CTE_AGRUPACION_COM_PROP);
        final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
        if (!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0) {
            // Si viene informado el campo del subproducto
            if (!UtilidadesTramitacion.isBlankOrNull(subproducto)) {
                for (IContexto contxAuxiliar : aContextoParametro) {
                    if (contxAuxiliar.getString(ConstantesComun.CTXTO_PARAMETRO_VALOR).equals(subproducto)) {
                        resultado = true;
                        break;
                    } else {
                        resultado = true;
                    }
                }
            } else {
                resultado = false;
            }
        }
        return resultado;
    }

    /**
     * Comprueba si una solicitud tiene desposito
     * @param datosSolicitudC
     * @return true si tiene deposito, false si no lo tiene.
     */
    public static boolean tieneDeposito(DatosSolicitudC datosSolicitudC) {
        boolean deposito = false;
        if (null != datosSolicitudC.getDeposito()) {
            if (!datosSolicitudC.getDeposito().equals("0")) {
                deposito = true;
            }
        }
        return deposito;
    }

    /**
     * Invoca el FCLI_722 para determinar si es o no comunidad de propietarios
     *
     * @param nuc
     * @return true en caso de que sea comunidad de propietarios
     */
    public static boolean esComunidadPropietarios(BigDecimal nuc) {
        IDatosEntradaTx datosEntrada = null;
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        IContexto[] contextoResult = null;
        String nucParticipante = null;
        String relacionParticipante = null;
        String secuenciaParticipante = null;
        boolean resultado = false;
        // Llamar al servicio FCLI_722 para obtener los participantes del NUC
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, ConstantesComun.CTE_SN_CC_CONSULTA_CLIENTES_NUC, ConstantesComun.CTE_SN_CO_CONSULTA_CLIENTES_NUC);
        datosEntrada.addCampo("NUC", nuc);
        contextoResult = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if (Utilidades.isBlankOrNull(contextoResult)) {
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_DATOS_CLIENTE_NUC_NO_TIENE, null, new String[] { nuc.toString() }, null);
        }
        // Comprobar si el primer titular es comunidad de propietarios
        for (IContexto participante : contextoResult) {
            // Obtener relacion participante y secuencia dentro de la relacion
            relacionParticipante = participante.getString(ConstantesComun.CTE_RELACION_NUC);
            secuenciaParticipante = participante.getString(ConstantesComun.CTE_SECUENCIA_RELACION_NUC);
            // Comprobar si es primer titular
            if (null != relacionParticipante && relacionParticipante.equals(ConstantesComun.CTE_RELACION_NUC_PRIMER_TITULAR) && null != secuenciaParticipante && secuenciaParticipante.equals(ConstantesComun.CTE_SECUENCIA_RELACION_NUC_PRIMER_TITULAR)) {
                // Si es primer titular, comprobar si es comunidad de propietarios
                nucParticipante = participante.getString(ConstantesComun.CTE_NIF_EXPEDIENTE);
                // Si el CIF empieza por "H" entonces es Comunidad de Propietarios
                if (null != nucParticipante && nucParticipante.startsWith("H")) {
                    resultado = true;
                }
                // Si está habilitado el control de operatoria se considera comunidad de propietarios
                if (UtilidadesTramitacion.comprobarControlOperatoria(nuc, ConstantesComun.CTE_CONTROL_OPERATORIA_COMUNIDAD_PROPIETARIOS, false)) {
                    resultado = true;
                }
                break;
            }
        }
        // Devolver resultado: true si el primer titular es C.P., false en caso contrario.
        return resultado;
    }

    /**
     * Método que comprueba si el producto tramitado va por solicitud-contrato o no.
     * Esta información se consulta en la CAG.AN82TB01
     *
     * @param producto
     * @return en caso de ir por solicitud contrato
     */
    public static boolean esSolicitudContrato(String producto) {
        boolean resultado = false;
        final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_CAMPO_PARAMETRO, producto);
        datosEntradaConsultaParametro.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, ConstantesComun.CTE_AGRUP_SOL_CONTRA);
        final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
        // Si existen resultados se está ante un producto que va por solicitud-contrato
        if (!UtilidadesTramitacion.isBlankOrNull(aContextoParametro)) {
            resultado = true;
        }
        return resultado;
    }

    /**
     * Obtener el tipo de cartera a partir del NUC: llamada al servicio AZTR_025 pasándole el NUC como campo de entrada.
     * @param nuc
     * @return El tipo de cartera vendrá en el campo AZTRN017040 del contexto de salida AZTRN017.
     */
    public static String obtenerTipoCartera(BigDecimal nuc) {
        String resultado = Constantes.CTE_STRING_EMPTY;
        IDatosEntradaTx datosEntradaCartera = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_CUENTA_CONTABLE_APLICACION_AZTR, ConstantesComun.CTE_COD_OPERACION_CONS_RED_SRV);
        datosEntradaCartera.addCampo(ConstantesComun.CTE_CONTEXTO_NUC, nuc);
        IContexto[] aCntxtoSalidaCartera = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaCartera);
        if (aCntxtoSalidaCartera != null && aCntxtoSalidaCartera.length > 0) {
            for (IContexto buscado : aCntxtoSalidaCartera) {
                resultado = buscado.getString(ConstantesComun.CTE_GET_CARTERA);
            }
        }
        return resultado;
    }

    /**
     * Calcula el importe mínimo para la comision de apertura y tarifa Aplazos 11+1,
     * a partir del importe solicitado recibido como parametro.
     *
     * @param importeSolicitado importe solicitado
     * @return importe minimo calculado a partir del importe solicitado
     */
    public static BigDecimal calcularImporteMinimoAplazos11M1(BigDecimal importeSolicitado) {
        BigDecimal importeMinimo = null;
        if (null != importeSolicitado) {
            importeMinimo = importeSolicitado.divide(new BigDecimal(11), 2, BigDecimal.ROUND_HALF_UP);
        }
        return importeMinimo;
    }

    /**
     * Método que llama al ANPM_443 para obtener los precios a aplicar (diferenciales e interés fijo)
     * para cada tramo y nivel, en función de la tarifa y de la versión general vigente del subproducto
     * en cuestión.
     *
     * @param producto
     * @param subProducto
     * @param versionGeneral
     * @param plazo
     * @param tarifa
     * @param origen
     * @param importe
     * @param nuc
     *
     * @return contextos de salida del servicio ANPM_443.
     */
    public static IContexto[] obtencionDatosTarifa(BigDecimal producto, BigDecimal subProducto, BigDecimal versionGeneral, String plazo, BigDecimal tarifa, BigDecimal origen, BigDecimal importe, BigDecimal nuc, BigDecimal indContextosLineales, String entidad) {
        // Invocamos el servicio de búsqueda de detalle de catálogo
        IContextoEjecucion contexto = ServicioNegocio.getContexto();
        IDatosEntradaTx datosEntrada = ServicioNegocio.getPrograma(contexto, ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CO_CONSULTA_PRECIOS_TARIFA);
        datosEntrada.addCampo(ConstantesComun.CTE_PARAM_COD_PRODUCTO, producto);
        datosEntrada.addCampo(ConstantesComun.CTE_PARAM_COD_SUB_PRODUCTO, subProducto);
        datosEntrada.addCampo(ConstantesComun.CTE_PARAM_COD_VERSION_GENERAL, versionGeneral);
        datosEntrada.addCampo(ConstantesComun.CTE_PARAM_COD_PLAZO, plazo);
        if (!Utilidades.isBlankOrNull(entidad)) {
            if (!UtilidadesComun.esASF(entidad)) {
                datosEntrada.addCampo(ConstantesComun.CTE_PARAM_COD_TARIFA, tarifa);
            }
        } else {
            datosEntrada.addCampo(ConstantesComun.CTE_PARAM_COD_TARIFA, tarifa);
        }
        datosEntrada.addCampo(ConstantesComun.CTE_PARAM_COD_ORIGEN, origen);
        if (null != importe) {
            datosEntrada.addCampo(ConstantesComun.CTE_PARAM_IMPORTE, importe);
        }
        if (null != nuc) {
            datosEntrada.addCampo(ConstantesComun.CTE_PARAM_NUC, nuc);
        }
        if (null != indContextosLineales) {
            datosEntrada.addCampo(ConstantesComun.CTE_PARAM_IND_LLAMADA_NSDK, indContextosLineales);
        }
        IContexto[] datosSalida = ServicioNegocio.invocarServicio(contexto, datosEntrada);
        return datosSalida;
    }

    /**
     * Metodo que indica si un campo de una solicitud ha sido modificado po BO.
     *
     * @param nucExpediente NUC para el que se realiza la consulta.
     * @param campo nombr del campo a consultar.
     * @return true si el campo ha sido modificado por BO, false en caso contrario.
     */
    public static boolean modificadoPorBO(BigDecimal nuc, String campo, BigDecimal orden) {
        boolean modificadoBO = false;
        GestionVersionBackOffice gestionVersionBO = new GestionVersionBackOffice();
        modificadoBO = gestionVersionBO.modificadoPorBO(campo, nuc, orden);
        return modificadoBO;
    }

    /**
     * Enviar email de caracter general
     *
     * @param mensaje
     * @param asunto
     */
    public static void enviarCorreoGeneral(String mensaje, String asunto) {
        if (StringUtils.isNotEmpty(mensaje) && StringUtils.isNotEmpty(asunto)) {
            enviarCorreo(Constantes.CTE_AGRUP_MAIL_GNRL, mensaje, asunto);
        }
    }

    /**
     * Método que envía correo a partir de la agrupación y el mensaje especificados.
     * La agrupación debe tener los parámetros DESTINATAR, ASUNTO y AUTOR en la AN82TB01.
     *
     * @param agrupacion
     * @param mensaje
     */
    public static void enviarCorreo(String agrupacion, String mensaje) {
        if (StringUtils.isNotEmpty(agrupacion) && StringUtils.isNotEmpty(mensaje)) {
            enviarCorreo(agrupacion, mensaje, null);
        }
    }

    /**
     * Método que envía correo a partir de la agrupación y el mensaje especificados.
     * La agrupación debe tener los parámetros DESTINATAR, ASUNTO y AUTOR en la AN82TB01.
     *
     * @param agrupacion
     * @param mensaje
     *
     * @author V362374 - Diego Jamardo
     */
    public static void enviarCorreo(String agrupacion, String mensaje, String asunto) {
        if (StringUtils.isNotEmpty(agrupacion) && StringUtils.isNotEmpty(mensaje)) {
            List<String> destinatarios = new ArrayList<String>(1);
            String remitenteNombre = null;
            String autor = null;
            destinatarios = UtilidadesTramitacion.obtenerListaValoresParametro(agrupacion, Constantes.CTE_MAIL_DESTINATARIO);
            if (UtilidadesTramitacion.isBlankOrNull(destinatarios)) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO, null, new String[] { agrupacion, Constantes.CTE_MAIL_DESTINATARIO }, null);
            }
            autor = UtilidadesTramitacion.obtenerValorParametroUnico(agrupacion, Constantes.CTE_MAIL_AUTOR);
            if (StringUtils.isBlank(autor)) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO, null, new String[] { agrupacion, Constantes.CTE_MAIL_AUTOR }, null);
            }
            if (null == asunto) {
                asunto = UtilidadesTramitacion.obtenerValorParametroUnico(agrupacion, Constantes.CTE_MAIL_ASUNTO);
            }
            if (StringUtils.isBlank(asunto)) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO, null, new String[] { agrupacion, Constantes.CTE_MAIL_ASUNTO }, null);
            }
            java.util.Map<String, Object> model = new HashMap<String, Object>(1);
            model.put(Constantes.CTE_MAIL_PARAM_1, mensaje);
            UtilidadesTramitacion.enviarCorreo(destinatarios.toArray(new String[destinatarios.size()]), asunto, autor, remitenteNombre, Constantes.CTE_MAIL_ALERT17, model);
        }
    }

    public static IContexto[] comprobarClienteTieneCuotaPreautorizada(BigDecimal nuc, BigDecimal tipoExpediente) {
        IContexto[] contextoSalidaHost = null;
        // Rellenar el contexto de comunicación con la rutina PLI
        final IContexto ctxEntradaHost = ContextoFactory.getInstance().getContexto(ConstantesComun.CTX_XPREN028);
        ctxEntradaHost.put(ConstantesComun.CTX_XPREN028_NUC, nuc);
        ctxEntradaHost.put(ConstantesComun.CTX_XPREN028_CLIENTE, BigDecimal.ZERO);
        ctxEntradaHost.put(ConstantesComun.CTX_XPREN028_TIPO_EXPEDIENTE, tipoExpediente);
        // V- canal oficina2000
        ctxEntradaHost.put(ConstantesComun.CTX_XPREN028_CANAL, "V");
        // Llamamos al programa puente XPRER011
        final CtgFacade ctg = new CtgFacade();
        contextoSalidaHost = ctg.invocarProgramaCics(ctxEntradaHost, ConstantesComun.PROGRAMA_XPRER011);
        // Obtenemos la salida
        if ((null == contextoSalidaHost) || (!BigDecimal.ZERO.equals(contextoSalidaHost[0].getBigDecimal(ConstantesComun.CTX_XPREN028_COD_ERROR)))) {
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_XPRER011, null, new String[] { nuc.toString() }, null);
        }
        return contextoSalidaHost;
    }

    public static boolean esPreconcedido(BigDecimal tipoExpediente) {
        boolean esPreconcedido = false;
        if ((tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_PRECONCEDIDO_ABANCA) == 0) || (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_PRECONCEDIDO_ASF) == 0)) {
            esPreconcedido = true;
        }
        return esPreconcedido;
    }

    public static boolean esPreconcedidoASF(BigDecimal tipoExpediente) {
        boolean esPreconcedidoASF = false;
        if (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_PRECONCEDIDO_ASF) == 0) {
            esPreconcedidoASF = true;
        }
        return esPreconcedidoASF;
    }

    public static boolean esConcesionarioASF(BigDecimal tipoExpediente) {
        boolean esConcesionarioASF = false;
        if (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_CONCESIONARIO_ASF) == 0) {
            esConcesionarioASF = true;
        }
        return esConcesionarioASF;
    }

    public static boolean esRefinanciancionASF(BigDecimal tipoExpediente, String destino) {
        boolean esRefinanciacionASF = false;
        if ((tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_CONSUMO_ASF) == 0) && (destino.compareTo(ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS) == 0)) {
            esRefinanciacionASF = true;
        }
        return esRefinanciacionASF;
    }

    public static boolean esConsumoASFsinRefinaciacion(BigDecimal tipoExpediente, String destino) {
        boolean esRefinanciacionASF = false;
        if ((tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_CONSUMO_ASF) == 0) && (destino.compareTo(ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS) != 0)) {
            esRefinanciacionASF = true;
        }
        return esRefinanciacionASF;
    }

    public static boolean esASF(String entidad) {
        boolean esASF = false;
        if (!UtilidadesTramitacion.isBlankOrNull(entidad) && (0 == entidad.compareTo(ConstantesComun.CTE_ENTIDAD_ASF))) {
            esASF = true;
        }
        return esASF;
    }

    /**
     * Devuelve si es un expediente de subrogación o ampliacion, es decir,
     * si es 292, 260, 293
     *
     * @param tipoExpediente
     * @return boolean
     */
    public static boolean esExpedienteSubrogacionAmpliacion(BigDecimal tipoExpediente) {
        boolean esExpSubrogacionAmpliacion = false;
        if ((!(null == tipoExpediente)) && ((tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_AMPLIACION) == 0) || (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_SUBROGACION) == 0) || (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_SUBROGACION_AMPLIACION) == 0))) {
            esExpSubrogacionAmpliacion = true;
        }
        return esExpSubrogacionAmpliacion;
    }

    /**
     * Devuelve si es un expediente de subrogación, es decir,
     * si es 260, 293
     *
     * @param tipoExpediente
     * @return boolean
     */
    public static boolean esExpedienteSubrogacion(BigDecimal tipoExpediente) {
        boolean esExpedienteSubrogacion = false;
        if ((!(null == tipoExpediente)) && ((tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_SUBROGACION) == 0) || (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_SUBROGACION_AMPLIACION) == 0))) {
            esExpedienteSubrogacion = true;
        }
        return esExpedienteSubrogacion;
    }

    /**
     * Devuelve si es un expediente de ampliacion, es decir,
     * si es 292
     *
     * @param tipoExpediente
     * @return boolean
     */
    public static boolean esExpedienteAmpliacion(BigDecimal tipoExpediente) {
        boolean esExpedienteAmpliacion = false;
        if ((!(null == tipoExpediente)) && (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_AMPLIACION) == 0)) {
            esExpedienteAmpliacion = true;
        }
        return esExpedienteAmpliacion;
    }

    /**
     * Devuelve si es un expediente de novacion, es decir,si es 267
     *
     * @param tipoExpediente
     * @return boolean
     */
    public static boolean esExpedienteNovacion(BigDecimal tipoExpediente) {
        boolean esExpedienteNovacion = false;
        if ((!(null == tipoExpediente)) && (tipoExpediente.compareTo(ConstantesComun.EXPEDIENTE_NOVACION) == 0)) {
            esExpedienteNovacion = true;
        }
        return esExpedienteNovacion;
    }

    /**
     * Servicio que devuelve la entidad asociada al centro del terminal que está
     * ejecutando el SN. Para eso llama al SN CGAL_307 pasándole como parámetro
     * en centro del que queremos obtener la entidad.
     *
     * @param centro
     * @return entidad
     */
    public static String obtenerEntidadCentro(String centro) {
        String entidad = "";
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        IDatosEntradaTx datosEntrada = null;
        IContexto[] resultado = null;
        /*Llamamos al CGAL_307 pasándole el centro de la terminal que ejecuta el SN*/
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, Constantes.CTE_APLIC_CGAL, Constantes.CTE_COD_CONS_CENTRO);
        // Campos de entrada del servicio de Ámbitos
        datosEntrada.addCampo(0, centro);
        resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if (!isBlankOrNull(resultado)) {
            entidad = resultado[0].getString(Constantes.CTE_COD_CONS_CENTRO_SAL_ENTIDAD);
        }
        return entidad;
    }

    /**
     * Comprueba si el importe de un hipoteca ó un personal es mayor o igual al importe especificado
     * en la AN82TB01. Consulta los parámetros de una agrupación en ANPM_180
     *
     * @param nomParametro
     * @param agrupParametro
     * @param datosSolicitud
     * @return boolean
     */
    public static boolean esImporteValido(BigDecimal tipoExpediente, BigDecimal importe, boolean comprobarHipotecario, boolean comprobarPersonal) {
        boolean valido = true;
        BigDecimal importeH = BigDecimal.ZERO;
        BigDecimal importeP = BigDecimal.ZERO;
        IContexto[] arrayContextos = new IContexto[] {};
        IDatosEntradaTx entrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ConstantesComun.CTE_INT_CC_ANPM, ConstantesComun.CTE_INT_COP_CONSULTA_PARAMETROS);
        entrada.addCampo(ConstantesComun.NOMBRE_AGRUPACION_PARAMETRO, "COMP_SIMUL");
        arrayContextos = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
        if (null != arrayContextos && 0 < arrayContextos.length && null != arrayContextos[0]) {
            for (int i = 0; i < arrayContextos.length; i++) {
                if (arrayContextos[i].getNombre().equalsIgnoreCase(ConstantesComun.CTXTO_PARAMETRO)) {
                    if (arrayContextos[i].getString(ConstantesComun.CTXTO_PARAMETRO_PARAMETRO).equals("IMP_HIPOTE")) {
                        importeH = new BigDecimal(arrayContextos[i].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR));
                    } else if (arrayContextos[i].getString(ConstantesComun.CTXTO_PARAMETRO_PARAMETRO).equals("IMP_PERSON")) {
                        importeP = new BigDecimal(arrayContextos[i].getString(ConstantesComun.CTXTO_PARAMETRO_VALOR));
                    }
                }
            }
            if (UtilidadesTramitacion.esHipotecario2(tipoExpediente) == true) {
                if ((importeH.compareTo(BigDecimal.ZERO) > 0) && (comprobarHipotecario)) {
                    if (importe.compareTo(importeH) <= 0)
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMPORTE_HIPOT, null, new String[] { importeH.toString() }, new String[] { importeH.toString() });
                }
            } else {
                if ((importeP.compareTo(BigDecimal.ZERO) > 0) && (comprobarPersonal)) {
                    if (importe.compareTo(importeP) <= 0)
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMPORTE_PERSONAL, null, new String[] { importeP.toString() }, new String[] { importeP.toString() });
                }
            }
        }
        return valido;
    }

    private static final String NIVEL_SUPERIOR_1593071887 = "NIVEL_SUPERIOR_1593071887";

    private static final String INCONSISTENT_OBJECT_TYPE_1388509224 = "INCONSISTENT_OBJECT_TYPE_1388509224";

    private static final String INTER_S_FIJO_INTRODUCIDO_TECHO_1655471895 = "INTER_S_FIJO_INTRODUCIDO_TECHO_1655471895";

    private static final String INTER_S_FIJO_INTRODUCIDO_1585418128 = "INTER_S_FIJO_INTRODUCIDO_1585418128";

    private static final String DIFERENCIAL_INTRODUCIDO_1189610890 = "DIFERENCIAL_INTRODUCIDO_1189610890";
}
