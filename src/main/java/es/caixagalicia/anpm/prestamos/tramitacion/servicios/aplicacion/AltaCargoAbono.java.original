package es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;

import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.enotario.utilidades.UtilidadesEnotario;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.cuentas.DatosCuentasC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.cuentas.DatosCuentasEng;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudEng;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.CodigosError;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.anpm.prestamos.tramitacionmultimedio.aplicacion.AbstractSolicitudMultimedio;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.parametros.Configuracion;

/**
 * @author V361030
 *
 */
public class AltaCargoAbono
{

    private static final String CAE_INCORRECTA      = "Abono";
    private static final String CCE_INCORRECTA      = "Cargo";
    private static final String CPE_INCORRECTA      = "Comercio";
    private static final String CC_INTERNA          = "interna";
    private static final String CC_EXTERNA          = "externa";
    private static final String CTE_ENVIA_MAIL 		= "S";
    private static final String CTE_APLICACION 		= "ANPM";
    private static final String CTE_GRUPO 			= "ENVIARMAIL";
    private static final String CTE_PARAM 			= "CONFIRMACION";

    
	/**
	 * Valida los datos de entrada del servicio que son obligatorios.
	 * 
	 * @param entrada
	 * @param gds
	 */
	public static void validarDatosEntrada(IDatosEntradaTx entrada, GestionDatosSolicitud gds,String entidad)
	{
		List<String> cuentasIbanTecleadas = new ArrayList<String>(1);
		String cuentaCargoIban = null;
		String cuentaAbonoIban = null;
		BigDecimal nucExpediente = null;
		IContexto contextoTitClientes = null;
		
		DatosSolicitudC datosSolicitud = null;
		String titularidad = null; //parcial: 0, completa: 1
		String disponibilidad = null;
		
		BigDecimal tipoCuenta = BigDecimal.ONE;
		
		tipoCuenta = entrada.getDecimal(Constantes.E_507270_TCCA);
		
		/*20150513 Ahora si la inserción de cuentas viene desde la alta automática de un crediventas, es posible que 
		 * las cuentas de cargo y abono del cliente no se inserten, es decir sólo se insertaría la del comercio.*/
/*
		if (Constantes.CADENA_VACIA.equals(entrada.getString(Constantes.E_507270_DCA).trim()) || Constantes.CADENA_VACIA.equals(entrada.getString(Constantes.E_507270_DCC).trim())) {
			ServicioNegocio.rollback(Constantes.CTE_ERROR_NO_PARAMETRO,null,new String[] {"Divisa"},null);
		}
		if (Constantes.CERO.equals(entrada.getDecimal(Constantes.E_507270_PCA)) || Constantes.CERO.equals(entrada.getDecimal(Constantes.E_507270_PCC))) {
			ServicioNegocio.rollback(Constantes.CTE_ERROR_NO_PARAMETRO,null,new String[] {"Código de país"},null);
		}
*/
		//Si la entidad es ASF (8620), las cuentas no pueden ser internas
		if (UtilidadesComun.esASF(entidad)){
			if (!UtilidadesTramitacion.isBlankOrNull(tipoCuenta) 
					&& (tipoCuenta.compareTo(new BigDecimal(2))!=0)){
				ServicioNegocio.rollback(CodigosError.CTE_ERROR_ASF_NO_CUENTAS_INTERNAS, null, null, null);
			}
		}
			
		nucExpediente = entrada.getDecimal(Constantes.E_507270_NUC);
		datosSolicitud = gds.getUltimaVersionCompleta(nucExpediente);
		titularidad = datosSolicitud.getTitularidad();
		disponibilidad = datosSolicitud.getDisponibilidad();
		
		// Se comprueba si es banca móvil
		boolean esPreconcedido = false;
		esPreconcedido = AbstractSolicitudMultimedio.esPreconcedido(
						datosSolicitud.getTipoPrescriptor(), 
						datosSolicitud.getCanal(), 
						datosSolicitud.getIndModoAlta());
		
		// Si las cuentas son internas se comprueba la titularidad, de lo contrario no.
		if (BigDecimal.ONE.equals(tipoCuenta))
		{
			/*20150319 Comprobamos que todas las cuentas tecleadas pertenezcan a algún titular.
			 * Para ello invocamos el servicio ANPM_292.
			 * */
			/*Construimos la lista de cuentas IBAN tecleadas*/
			cuentaCargoIban = UtilidadesTramitacion.comprobarDatoNull(
				entrada.getString(Constantes.E_507270_CCE));
			cuentaAbonoIban = UtilidadesTramitacion.comprobarDatoNull(
				entrada.getString(Constantes.E_507270_CAE));
	

			if (! StringUtils.isBlank(cuentaCargoIban))
			{
				cuentasIbanTecleadas.add(cuentaCargoIban);
			}
			if (! StringUtils.isBlank(cuentaAbonoIban))
			{
				cuentasIbanTecleadas.add(cuentaAbonoIban);
			}
			
			if (! UtilidadesTramitacion.isBlankOrNull(cuentasIbanTecleadas))
			{
				if(!esPreconcedido){
					contextoTitClientes = GestionConsultaTitularidad.compruebaCuentaCliente(
						cuentasIbanTecleadas,
						titularidad,disponibilidad,
						nucExpediente,
						null);
				}
			}
			
			if ((null != contextoTitClientes) &&
				(! Constantes.CTE_STR_1.equals(contextoTitClientes.getString("ANPMN292010"))))
			{
				ServicioNegocio.rollback(CodigosError.CTE_COD_MSG_ERROR_TITULARIDAD, null, null, null);
			}
		}

		if (! StringUtils.isBlank(cuentaCargoIban))
		{
			cuentasIbanTecleadas.add(cuentaCargoIban);
		}
		if (! StringUtils.isBlank(cuentaAbonoIban))
		{
			cuentasIbanTecleadas.add(cuentaAbonoIban);
		}

	}
	
	/**
	 * Inserta una cuenta.
	 * @param strTipoCuenta
	 * @param datosSolicitud
	 * @param usuario
	 * @param entrada
	 */
	public static void insertarCuenta(String strTipoCuenta, DatosSolicitudC datosSolicitud, String usuario, IDatosEntradaTx entrada) {
		BigDecimal ofiSol = entrada.getDecimal(Constantes.E_507270_OFI);
		BigDecimal sol = entrada.getDecimal(Constantes.E_507270_NUM);
		//BigDecimal ver = entrada.getDecimal(Constantes.E_507270_VER);
		BigDecimal nuc = entrada.getDecimal(Constantes.E_507270_NUC);
		BigDecimal prioridad = ConstantesComun.CTE_BID_1;
		BigDecimal tipoDom = ConstantesComun.CTE_BID_1;
		BigDecimal div = Constantes.CERO;
		BigDecimal subdiv = Constantes.CERO;
		BigDecimal formato = Constantes.CTE_FORMATO_IBAN;
		String vigencia = Constantes.CTE_STR_S;
		String iban = Constantes.CADENA_VACIA;
		String divisa = Constantes.CADENA_VACIA;
		BigDecimal pais = Constantes.CERO;
		
		if(null != entrada.getDecimal(Constantes.E_507270_TCCA))
		{
			tipoDom = entrada.getDecimal(Constantes.E_507270_TCCA);
		}
		
		
		/*20150504 Si no viene informada la oficina la recuperamos de la solicitud*/
		if (null == ofiSol)
		{
			ofiSol = datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud();
		}
		/*Lo mismo con el número de solicitud*/
		if (null == sol)
		{
			sol = datosSolicitud.getDatosSolicitudKey().getNumSolicitud();
		}
		
		/*20150504 Se añade la cuenta comercio para Crediventas*/
		if (Constantes.CTE_TIPO_CUENTA_CONTABLE.equals(strTipoCuenta))
		{
			iban = entrada.getString(Constantes.E_507270_CCE);
			divisa = entrada.getString(Constantes.E_507270_DCC);
			pais = entrada.getDecimal(Constantes.E_507270_PCC);
		}
		else if (Constantes.CTE_TIPO_CUENTA_ABONO.equals(strTipoCuenta))
		{
			iban = entrada.getString(Constantes.E_507270_CAE);
			divisa = entrada.getString(Constantes.E_507270_DCA);
			pais = entrada.getDecimal(Constantes.E_507270_PCA);
		}
		else if (Constantes.CTE_TIPO_CUENTA_COMERCIO.equals(strTipoCuenta))
		{
			iban = entrada.getString(Constantes.E_507270_IBAN_COMERCIO);
			divisa = entrada.getString(Constantes.E_507270_DIVISA_COMERCIO);
			pais = entrada.getDecimal(Constantes.E_507270_COD_PAIS_COMERCIO); //teleproc, ej: código teleproceso España es el 17.
		}
		
		// Si la cuenta es externa y de cargo calculamos la cuenta de prestamo.
		if(ConstantesComun.CTE_BID_2.equals(tipoDom) &&
			UtilidadesTramitacion.isEmptyOrNullString(iban) &&
			Constantes.CTE_TIPO_CUENTA_ABONO.equals(strTipoCuenta))
		{
			iban = UtilidadesEnotario.getContratoIban(datosSolicitud);

		}
		
		if(null == pais || 0 == ConstantesComun.CTE_BID_0.compareTo(pais))
		{
			pais = UtilidadesComun.buscaCodPais(iban);
		}
		
		if(UtilidadesComun.isEmptyOrNullString(divisa))
		{
			divisa 	= ConstantesComun.CTE_DIVISA_EUR;
		}
		
		/*20150504 Las cuentas de cargo y de abono vienen siempre informadas para darlas de alta pero la cuenta
		 * del comercio no siempre va a venir, por lo tanto en el servicio ANPM_270 sólo la insertamos si viene informada*/
		/* Para Crediventas viene informada solo la cuenta de comercio*/
		
		if ((!StringUtils.isBlank(iban)) &&
			 (!StringUtils.isBlank(divisa) &&
			 (null != pais) &&
			 (0 != BigDecimal.ZERO.compareTo(pais))))
		{
			String strEntidad = iban.substring(4, 8);
			BigDecimal entidad = new BigDecimal(strEntidad);
			String strOficina = iban.substring(8, 12);
			BigDecimal oficina = new BigDecimal(strOficina);
			String strCuenta = iban.substring(14, 24);
			BigDecimal cuenta = new BigDecimal(strCuenta);
			DatosSolicitudEng dsEng = new DatosSolicitudEng(ConstantesComun.CTE_JNDI_DATASOURCE);
			DatosCuentasC datosCuenta = new DatosCuentasC(sol, ofiSol, datosSolicitud.getDatosSolicitudKey().getVersionSolicitud(), nuc, divisa, entidad, oficina, cuenta, pais, strTipoCuenta, prioridad, tipoDom, div, subdiv, formato, usuario, vigencia, iban);
			
			// Se inserta el numero de domiciliacion.
			// Para esto se llama al servicio ANPM_469.
			if(ConstantesComun.CTE_BID_2.equals(tipoDom) && 
					Constantes.CTE_TIPO_CUENTA_CARGO.equals(strTipoCuenta))
			{
				BigDecimal idDom = UtilidadesComun.obtenerIdDomiciliacion();
				datosCuenta.setBidIdDomiciliacion(idDom);
				
				enviarCorreoDomiciliacion(idDom, datosSolicitud.getDatosSolicitudKey().getNucExpediente());
			}
			
			DatosCuentasEng dceng = new DatosCuentasEng();
			//DatosCuentasEng dceng	= new DatosCuentasEng(ConstantesComun.CTE_JNDI_DATASOURCE);
			datosCuenta.getCuentasKey().setIdCuenta(dceng.getSiguienteIdCuenta(
					datosCuenta.getCuentasKey().getOficinaSolicitud(),
					datosCuenta.getCuentasKey().getNumeroSolicitud(),
					datosCuenta.getCuentasKey().getVersionSolicitud(),
					datosCuenta.getCuentasKey().getNucExpediente()));
			/*20151130 Se cambia el persist() por el insert() */
			dceng.insert(datosCuenta);
			/*20151130 traemos los cambios hechos desde BD al objeto persistente.*/
			dceng.refresh(datosCuenta);
			
			dsEng.refresh(datosSolicitud);
			//datosSolicitud.refresh();
		}
	}
	
	
	/**
	 * Metodo para validar las cuentas de Cargo y Abono.
	 * 
	 * @param entrada
	 * @param entidad
	 */
	public static void validarCuentas(IDatosEntradaTx entrada){
		
		BigDecimal tipoDom = BigDecimal.ONE;
		String entidadAbanca = new String("");
		
		tipoDom = entrada.getDecimal(Constantes.E_507270_TCCA);
						
		String cuentaCargoIban = UtilidadesTramitacion.comprobarDatoNull(
                       entrada.getString(Constantes.E_507270_CCE));
		String cuentaAbonoIban = UtilidadesTramitacion.comprobarDatoNull(
                       entrada.getString(Constantes.E_507270_CAE));		
		String cuentaComercioIban = UtilidadesTramitacion.comprobarDatoNull(
                       entrada.getString(Constantes.E_507270_IBAN_COMERCIO));

		// Devuelve la entidad de Abanca.
        entidadAbanca = UtilidadesComun.obtieneEntidadAbanca();
		
		// Si por algun motivo no viene informado el tipo de domiciliazion se configura a interna por defecto
		if (UtilidadesTramitacion.isBlankOrNull(entrada.getDecimal(Constantes.E_507270_TCCA))){
			tipoDom = BigDecimal.ONE;
		}
				
		// VALIDACION de las cuentas para asegurarnos de que son acordes con el tipo de cuentas que se ha seleccionado.
		// Validacion de cuentas internas.
		if (BigDecimal.ONE.equals(tipoDom)){
			validarCuentaInterna(cuentaCargoIban, 0, entidadAbanca); // 0: Cuenta de Cargo
            validarCuentaInterna(cuentaAbonoIban, 1, entidadAbanca); // 1: Cuenta de Abono
            validarCuentaInterna(cuentaComercioIban, 2, entidadAbanca); // 2: Cuenta de Comercio
		}
		// validacion de cuentas externas.
		else if(ConstantesComun.CTE_BID_2.equals(tipoDom)){
			validarCuentaExterna(cuentaCargoIban, entidadAbanca); // 0: Cuenta de Cargo
			//validarCuentaExterna(cuentaAbonoIban, entidadAbanca); // 1: Cuenta de Abono
			//validarCuentaExterna(cuentaComercioIban, entidadAbanca); // 2: Cuenta de Comercio
		}
	}
	
	
	/**
	 * Metodo para validar una cuenta interna.
	 * 
	 * @param cuentaIBAN
	 * @param tipoCuenta
	 * @param entidadAbanca
	 */
    public static void validarCuentaInterna(String cuentaIBAN, int tipoCuenta, String entidadAbanca)
    {
       String cuenta = "";
       String divisa = "";
       String cuentaContable = "";
       String numero = "";
       String oficina = "";
       final String cuentaContableCreditos = "550";
       
       if(!UtilidadesTramitacion.isEmptyOrNullString(cuentaIBAN))
       {
	       // Si la cuenta introducida no es ABANCA se informa de que tiene seleccionada una cuenta interna.
	       if(!entidadAbanca.equals(cuentaIBAN.substring(4, 8)))
	       {
	           ServicioNegocio.rollback(CodigosError.CTE_ERROR_DOM_CUENTA_INCORRECTA, null, new String[] {CC_EXTERNA, CC_INTERNA}, null);
	       }
	       
	       // Concatenamos valores de la cuenta IBAN para formar el numero de cuenta.
	       cuenta = cuentaIBAN.substring(14, 17) + cuentaIBAN.substring(8, 12) + cuentaIBAN.substring(17, 23);
	       
	       cuentaContable = cuentaIBAN.substring(14, 17);
	       
	       
	       if(cuentaContable.equals(cuentaContableCreditos)) {
	    	   //Extraemos los datos correspondientes
	    	   numero = cuentaIBAN.substring(17, 23);
	    	   oficina = cuentaIBAN.substring(8, 12);
	    	   //Invoco al metodo alternativo
	    	   divisa = UtilidadesComun.buscaDivisaCreditos(oficina, numero);
	       }else {
	    	    // LLamada al servicio RAJE_069 para comprobar si la cuenta es correcta y devuelve la divisa.
	    	   divisa = UtilidadesComun.buscaDivisa(cuenta);
	       }
	       
	      
	       
	       // Comprueba que la divisa sea en EUROS.
	       if(!ConstantesComun.CTE_DIVISA_EUR.equals(divisa))
	       {
	           // Mensajes de error para las cuentas si tienen el formato mal.
	           if(0 == tipoCuenta)
	           {
	               ServicioNegocio.rollback(CodigosError.CTE_ERROR_IBAN_INCORRECTO, null, new String[] {CAE_INCORRECTA}, new String[] {CAE_INCORRECTA});
	           }
	           else if (1 == tipoCuenta)
	           {
	               ServicioNegocio.rollback(CodigosError.CTE_ERROR_IBAN_INCORRECTO, null, new String[] {CCE_INCORRECTA}, new String[] {CCE_INCORRECTA});
	           }
	           else if (2 == tipoCuenta)
	           {
	               ServicioNegocio.rollback(CodigosError.CTE_ERROR_IBAN_INCORRECTO, null, new String[] {CPE_INCORRECTA}, new String[] {CPE_INCORRECTA});
	           }
	       }
       }

    }
    
    
    /**
     * Metodo para validar una cuenta externa.
     * 
     * @param cuentaIBAN
     * @param entidadAbanca
     */
    public static void validarCuentaExterna(String cuentaIBAN, String entidadAbanca)
    {
    	if(!UtilidadesTramitacion.isEmptyOrNullString(cuentaIBAN))
    	{
	       // Si la cuenta introducida es realmente ABANCA se informa de que tiene seleccionada una cuenta Interna.
	       if(entidadAbanca.equals(cuentaIBAN.substring(4, 8)))
	       {
	           ServicioNegocio.rollback(CodigosError.CTE_ERROR_DOM_CUENTA_INCORRECTA, null, new String[] {CC_INTERNA, CC_EXTERNA}, null);
	       }
    	}
    }
    
    
    /**
     * Metodo para enviar un correo informando de la insercion de las cuentas en base de datos.
     * 
     * @param idDom
     * @param nuc
     */
    public static void enviarCorreoDomiciliacion(BigDecimal idDom, BigDecimal nuc)
    {
    	//Se obtiene el parámetro que controla si se envía mail en función del entorno en el que se lanza la aplicación
    	final String enviarMail = Configuracion.getInstance().getValor(CTE_APLICACION, CTE_GRUPO, CTE_PARAM);
    	
    	List <String> listaDestinatarios = UtilidadesTramitacion.obtenerListaValoresParametro(
								Constantes.CTE_PARAMETRO_AGRUP_DOMICILIACION, Constantes.CTE_PARAMETRO_DOM_DESTINATARIOS);
		String asunto = UtilidadesTramitacion.obtenerValorParametroUnico(
								Constantes.CTE_PARAMETRO_AGRUP_DOMICILIACION, Constantes.CTE_PARAMETRO_DOM_ASUNTO);
		String autor = UtilidadesTramitacion.obtenerValorParametroUnico(
								Constantes.CTE_PARAMETRO_AGRUP_DOMICILIACION, Constantes.CTE_PARAMETRO_DOM_AUTOR);
		
		String[] destinatarios = listaDestinatarios.toArray(new String[listaDestinatarios.size()]);
		
		String remitenteNombre = null;
		
		Map<String, Object> model = new HashMap<String, Object>(1);
		/*Parametrizamos el nuc en la plantilla*/
		model.put("PARAM_1", nuc.toString());
		model.put("PARAM_2", UtilidadesTramitacion.bigDecimalToString(idDom, 20, 0, false));
		
		//Sólo se envía el correo cuando el entorno es distinto de preexplotación (vendrá a S el parámetro)
		if(CTE_ENVIA_MAIL.equals(enviarMail)) 
		{
			UtilidadesTramitacion.enviarCorreo(destinatarios, asunto, autor, remitenteNombre, Constantes.CTE_ANPM_REFERENCIA_DOM_EXTERNA, model);
		}
		
    }

}
