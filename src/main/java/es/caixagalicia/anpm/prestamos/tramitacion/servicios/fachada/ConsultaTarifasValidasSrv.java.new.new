/**
 */
package es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionesInteresC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudEng;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoTarifasValidas;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.IRegistro;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.mensajes.Mensaje;

/**
 * Servicio que consulta las tarifas validas para un NUC.
 *
 * CO:  ANPM_453
 * CTX: ANPMN453
 * TX:  ANU6
 *
 * @author V361732
 */
public final class ConsultaTarifasValidasSrv extends ServicioNegocio {

    // private static final String CTE_CTX_PROGRAMA									= "ANPMR208";
    // 
    // private static final String CTE_CTX_PRODUCTO 									= "ANPMN439010";
    // private static final String CTE_CTX_SUBPRODUCTO 								= "ANPMN439020";
    // private static final String CTE_CTX_ID_TARIFA									= "ANPMN439040";
    // private static final String CTE_CTX_MATRIZ_BONIFICACIONES_PRODUCTO 				= "ANPMN439100";
    // private static final Integer CTE_CTX_LONGITUD_MATRIZ_BONIFICACIONES_PRODUCTO 	= Integer.valueOf(300);
    // private static final String CTE_CTX_BONIFICACION_MAXIMA 						= "ANPMN439110";
    // private static final String CTE_CTX_CODIGO_RETORNO		 						= "ANPMN439120";
    // private static final String CTE_CTX_NUC_EXPEDIENTE 								= "ANPMN439060";
    // private static final String CTE_CTX_PERIODICIDAD_INTERES 						= "ANPMN439070";
    @Override
    public IContexto[] ejecutar(IContextoEjecucion contextoEjecucion, IDatosEntradaTx datosEntrada) {
        contextoEjecucion.setDiarioElectronico(new DiarioElectronico(DiarioElectronico.TIPO_CONSULTA));
        IContexto[] datosSalida = new IContexto[0];
        BigDecimal nuc = datosEntrada.getDecimal("NUC");
        BigDecimal codProd = BigDecimal.ZERO;
        BigDecimal codSubProd = BigDecimal.ZERO;
        BigDecimal plazo = BigDecimal.ZERO;
        BigDecimal importe = BigDecimal.ZERO;
        BigDecimal periodicidadInteres = BigDecimal.ZERO;
        BigDecimal versionGeneral = null;
        String bonificacion = "";
        // Control de posible NUC vacio.
        if (null == nuc || 0 == BigDecimal.ZERO.compareTo(nuc)) {
            ServicioNegocio.rollback(12708, null, new String[] { new Mensaje(ServicioNegocio.getContexto(), NUC_109436).toString() }, null);
        }
        // Se necesitan los siguientes datos para llamar al SN 443.(COD_PROD.,COD_SUBP.,PLAZO)
        // Cogemos el registro de la ultima version incompleta que cumple la igualdad del nuc.
        DatosSolicitudEng datosSolicitudesEng = new DatosSolicitudEng();
        List<DatosSolicitudC> datosSolicitud = datosSolicitudesEng.buscarSolicitudesIncompletas(nuc);
        // Control por si devuelve la lista de solicitudes incompletas vacia con ese NUC.
        if (null == datosSolicitud || 0 >= datosSolicitud.size()) {
            ServicioNegocio.rollback(12773, null, new String[] { nuc.toString() }, null);
        }
        // Coge la ultima version.
        DatosSolicitudC solicitudIncompleta = datosSolicitud.get(0);
        for (int i = 0; i < datosSolicitud.size() - 1; i++) {
            if (0 < solicitudIncompleta.getDatosSolicitudKey().getVersionSolicitud().compareTo(datosSolicitud.get(i + 1).getDatosSolicitudKey().getVersionSolicitud()))
                solicitudIncompleta = datosSolicitud.get(i + 1);
        }
        /* ----------------------ANPM_442----------------------------- */
        // Llamada al servicio de negocio ANPM_442. Saca el campo ID_TARIFA
        // para introducirlo en la siguiente llamada al servicio de negocio 443.
        IDatosEntradaTx datosEntrada442 = ServicioNegocio.getPrograma(contextoEjecucion, new Integer(507), new Integer(442));
        // 0 para Simulacion, 1 para Solicitud
        datosEntrada442.addCampo("ORIGEN", new String("1"));
        datosEntrada442.addCampo("NUC", nuc.toString());
        IContexto[] datosSalida442 = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada442);
        // Porque no hay tarifas aplicacbles a ese NUC
        if (null == datosSalida442 || 0 >= datosSalida442.length) {
            ServicioNegocio.rollback(12774, null, null, null);
        }
        IRegistro[] registro442 = datosSalida442[0].getRegistro("ANPMN442010");
        if (null == registro442 || 0 >= registro442.length) {
            ServicioNegocio.rollback(12774, null, null, null);
        }
        /* -------------------------ANPM_443---------------------------------------- */
        // Llama al Servicio de Negocio ANPM_443 por cada tarifa que tenemos
        // para devolver los datos de los intereses.
        List<IContexto> listaContextos = new ArrayList<IContexto>(IConstantesSolicitud.CTE_TAM_INICIAL_ARRAYS);
        for (int i = 0; i < registro442.length; i++) {
            BigDecimal idTarifa = registro442[i].getBigDecimal("ANPMN442011");
            IDatosEntradaTx datosEntrada443 = ServicioNegocio.getPrograma(contextoEjecucion, new Integer(507), new Integer(443));
            codProd = solicitudIncompleta.getProducto();
            codSubProd = solicitudIncompleta.getSubproducto();
            plazo = solicitudIncompleta.getPlazoTotal();
            // 19052016: se añade el campo importe
            importe = solicitudIncompleta.getImporteSolicitado();
            // 30052016: se anhade el campo version general
            versionGeneral = solicitudIncompleta.getVersionGeneral();
            // Se obtiene la periodicidad del interés para el orden 1
            List<CondicionesInteresC> condicionesC = solicitudIncompleta.getCondicionesInteres();
            for (CondicionesInteresC condicion : condicionesC) {
                if (0 == BigDecimal.ONE.compareTo(BigDecimal.valueOf(condicion.getCondicionesInteresKey().getIntOrdenDelTramo()))) {
                    periodicidadInteres = BigDecimal.valueOf(condicion.getIntPeriodicidadNumPeriodo());
                    break;
                }
            }
            // Llamada al SN ANPM_424 (PL1) para obtener la maxima bonificacion
            // por cada tarifa que tenemos.
            /*
			IContexto contextoEntradaPLI = ContextoFactory.getInstance().getContexto("ANPMN439");
			
			//Reservo memoria para la matriz de pagos
			reservarMemoriaRegistro(contextoEntradaPLI,
					CTE_CTX_MATRIZ_BONIFICACIONES_PRODUCTO,
					CTE_CTX_LONGITUD_MATRIZ_BONIFICACIONES_PRODUCTO);
			
			contextoEntradaPLI.put(CTE_CTX_PRODUCTO, codProd);
			contextoEntradaPLI.put(CTE_CTX_SUBPRODUCTO, codSubProd);
			contextoEntradaPLI.put(CTE_CTX_ID_TARIFA, idTarifa);
			contextoEntradaPLI.put(CTE_CTX_NUC_EXPEDIENTE, nuc); 
			contextoEntradaPLI.put(CTE_CTX_PERIODICIDAD_INTERES, periodicidadInteres);
			contextoEntradaPLI.put(CTE_CTX_VERSION_GENERAL, versionGeneral);
			
			CtgFacade ctg = new CtgFacade();
			IContexto[] contextoSalidaPLI = ctg.invocarProgramaCics(contextoEntradaPLI, CTE_CTX_PROGRAMA);
			if (contextoSalidaPLI[0].getBigDecimal(CTE_CTX_CODIGO_RETORNO).equals(BigDecimal.ZERO)) // OK
				bonificacion = UtilidadesTramitacion.bigDecimalToString(
 									contextoSalidaPLI[0].getBigDecimal(CTE_CTX_BONIFICACION_MAXIMA),
 									3, 4, true
 									);
			*/
            BigDecimal bonificacionMaxima = UtilidadesTramitacion.obtenerBonificacionMaxima(codProd, codSubProd, idTarifa, nuc, periodicidadInteres, versionGeneral);
            bonificacion = UtilidadesTramitacion.bigDecimalToString(bonificacionMaxima, 3, 4, true);
            // Datos de entrada necesarios.
            datosEntrada443.addCampo("COD_PRODUCTO", codProd);
            datosEntrada443.addCampo("COD_SUBPRODUCTO", codSubProd);
            datosEntrada443.addCampo("PLAZO", plazo);
            datosEntrada443.addCampo("ID_TARIFA", idTarifa);
            // 1 para Simulacion, 2 para Solicitud
            datosEntrada443.addCampo("ORIGEN_CONSULTA", new BigDecimal(2));
            datosEntrada443.addCampo("IMPORTE", importe);
            IContexto[] datosSalida443 = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada443);
            IRegistro[] registro443 = datosSalida443[0].getRegistro("ANPMN443010");
            IRegistro registroTramo1 = null;
            IRegistro registroTramo2 = null;
            IRegistro registroTramo3 = null;
            if (null != registro443) {
                for (int j = 0; j < registro443.length; j++) {
                    if (registro443[j].getBigDecimal("ANPMN443017").equals(BigDecimal.ZERO) || registro443[j].getBigDecimal("ANPMN443017").equals(new BigDecimal(10)) && !registro443[j].getString("ANPMN443019").trim().equals("COM")) {
                        if (registro443[j].getBigDecimal("ANPMN443011").equals(BigDecimal.ONE)) {
                            registroTramo1 = registro443[j];
                        } else if (registro443[j].getBigDecimal("ANPMN443011").equals(new BigDecimal(2))) {
                            registroTramo2 = registro443[j];
                        } else if (registro443[j].getBigDecimal("ANPMN443011").equals(new BigDecimal(3))) {
                            registroTramo3 = registro443[j];
                        }
                    }
                }
            }
            // Control por si la tarifa no tiene bien definidos los tramos.
            // 2016-02-08 - Comprobar si la tarifa tiene uno o dos tramos de interés:
            // - Si tiene un tramo se comprueba solo el tramo 1.
            // - Si tiene dos tramos se comprueban el tramo1 y el tramo2.
            // Obtener datos interes del producto/subproducto (ANPM_048)
            boolean tieneTramo1 = false;
            boolean tieneTramo2 = false;
            boolean tieneTramo3 = false;
            // List<CondicionesInteresC> condInteres = solicitudIncompleta.getCondicionesInteres();
            // if ((null != condInteres) && (0 < condInteres.size()))
            // {
            // for (CondicionesInteresC cond : condInteres)
            // {
            // if (cond.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_UNO))
            // {
            // tieneTramo1 = true;
            // }
            // 
            // if (cond.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_DOS))
            // {
            // tieneTramo2 = true;
            // }
            // }
            // }
            IContexto[] salidaANPM048 = UtilidadesTramitacion.consultarDatosSubproductoCatalogo(solicitudIncompleta);
            if (null != salidaANPM048) {
                for (IContexto ctx : salidaANPM048) {
                    if (ctx.getNombre().equals("ANPMN014")) {
                        if (0 == ctx.getBigDecimal("ANPMN014060").compareTo(Constantes.CTE_BID_1)) {
                            tieneTramo1 = true;
                        }
                        if (0 == ctx.getBigDecimal("ANPMN014060").compareTo(Constantes.CTE_BID_2)) {
                            tieneTramo2 = true;
                        }
                        if (0 == ctx.getBigDecimal("ANPMN014060").compareTo(Constantes.CTE_BID_3)) {
                            tieneTramo3 = true;
                        }
                    }
                }
            }
            boolean tieneUnTramo = tieneTramo1 && (!tieneTramo2) && (!tieneTramo3);
            boolean tieneDosTramos = tieneTramo1 && tieneTramo2 && (!tieneTramo3);
            boolean tieneTresTramos = tieneTramo1 && tieneTramo2 && tieneTramo3;
            if ((tieneTresTramos && (null != registroTramo1 && null != registroTramo2 && null != registroTramo3)) || (tieneDosTramos && (null != registroTramo1 && null != registroTramo2)) || (tieneUnTramo && (null != registroTramo1))) {
                listaContextos.add(ContextoTarifasValidas.obtenerContextoTarifasValidas(registro442[i], registroTramo1, registroTramo2, registroTramo3, plazo, bonificacion));
            }
        }
        datosSalida = listaContextos.toArray(new IContexto[listaContextos.size()]);
        return datosSalida;
    }

    /**
     * Reserva memoria en el contexto para el registro que se pasa como parámetro
     * @param contexto Contexto donde reservar memoria
     * @param strCtxtoIdRegistro Id del registro a crear
     * @param iRegistrosSize Número de registros a crear
     */
    // private void reservarMemoriaRegistro(IContexto contexto,
    // String strCtxtoIdRegistro, int iRegistrosSize){
    // List<IRegistro> lstRegistros = new ArrayList<IRegistro>(iRegistrosSize);
    // for (int i = 0; i < iRegistrosSize; i++){
    // lstRegistros.add(ContextoFactory.getInstance().getRegistro(contexto, strCtxtoIdRegistro));
    // }
    // contexto.put(strCtxtoIdRegistro, lstRegistros.toArray(new IRegistro[0]));
    // }
    private static final String NUC_109436 = "NUC_109436";
}
