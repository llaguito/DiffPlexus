package es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada;

import java.math.BigDecimal;
import java.sql.Time;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import es.caixagalicia.anpm.prestamos.catalogo.persistencia.adelantos.AdelantoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.comisiones.ComisionesC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.condCapital.CondicionesCapitalC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.datEconomicos.DatEcoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.interes.InteresC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.interes.TechosSuelosDifeC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.version.VersionEng;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.version.VersionesC;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionAdelanto;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionComisiones;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionConCapital;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionDatEco;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionInteres;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionTechosSuelosDife;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionVersiones;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.tramitacion.excepcion.DatoEnRangoException;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatoEnRango;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatoEnRango.TablaAN03TB01;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatoEnRango.TablaAN04TB01;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatoEnRango.TablaAN06TB01;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatoEnRango.TablaAN07TB01;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatoEnRango.TablaAN08TB01;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatoEnRango.TablaAN13TB01;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionInformacionRiesgoOrigen;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionVersionBackOffice;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoDatoEnRango;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoDatoEnRangoBloques;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.InformacionRiesgoOrigenVO;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.ResultadoDatoEnRangoVO;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.log.LogHelper;
import es.caixagalicia.ifrt.persistencia.eccv02.CEcc;

/**
 * CO:  ANPM_165
 * CTX: ANPMN058
 * 
 * @author E800197
 *
 */
public class DatoEnRangoSrv extends ServicioNegocio
{
	// Identificación de campos de entrada.
	private static final String CTE_COD_PRODUCTO = "COD_PRODUCTO";
	private static final String CTE_COD_SUBPRODUCTO = "COD_SUBPRODUCTO";
	private static final String CTE_COLECTIVO = "COLECTIVO";
	private static final String CTE_VERSION_GENERAL = "VERSION_GENERAL";
	private static final String CTE_TIPO_EXPEDIENTE = "TIPO_EXPEDIENTE";
	private static final String CTE_DESTINO_PRINCIPAL = "DESTINO_PRINCIPAL";
	private static final String CTE_SECTOR = "SECTOR";
	private static final String CTE_GARANTIA = "GARANTIA";
	private static final String CTE_CANAL = "CANAL";
	private static final String CTE_IMPORTE_SOLICITADO = "IMPORTE_SOLICITADO";
	private static final String CTE_PLAZO_TOTAL = "PLAZO_TOTAL";
	private static final String CTE_PLAZO_CARENCIA = "PLAZO_CARENCIA";
	private static final String CTE_PLAZO_DIFERIMIENTO = "PLAZO_DIFERIMIENTO";
	private static final String CTE_PLAZO_DESEMBOLSO = "PLAZO_DESEMBOLSO";
	private static final String CTE_BLOQUE = "BLOQUE";
	
	//Identificacion campos entrada BO
	private static final String CTE_MODIFICACION_BO = "MODIFICACION_BO";
	private static final String CTE_NUC_EXPEDIENTE = "NUC_EXPEDIENTE";
	
	private static final String CTE_DEPOSITO_SN = "DEPOSITO";
	
	// Constantes de tablas de catálogo consultadas
	private static final String CTE_TABLA_DATOS_ECONOMICOS = "AN03TB01";
	private static final String CTE_TABLA_COND_CAPITAL = "AN04TB01";
	private static final String CTE_TABLA_COMISIONES = "AN06TB01";
	private static final String CTE_TABLA_COND_INTERES = "AN07TB01";
	private static final String CTE_TABLA_DIFE_INTERES = "AN08TB01";
	private static final String CTE_TABLA_TRATAMIENTO_ADELANTOS = "AN13TB01";
	
	// Número máximo de bloques de datos.
	private static final int NUMERO_MAXIMO_BLOQUES = 16;	
	
	//Variable común a métodos de toda la clase.
	boolean pertenceRedSantiagoOMadrid = false;
	
	// Tipos de bloques a recibir.
	private static final String TIPO_BLOQUE_DATOS_INTERES = "TipoBloqueI";
	private static final String TIPO_BLOQUE_DATOS_SUSTITUTIVOS = "TipoBloqueS";
	private static final String TIPO_BLOQUE_SISTEMA_DE_AMORTIZACION = "TipoBloqueA";	
	private static final String TIPO_BLOQUE_TRATAMIENTO_DE_ADELANTOS = "TipoBloqueT";
	private static final String TIPO_BLOQUE_GASTOS_Y_COMISIONES = "TipoBloqueC";
	
	/**
	 * Constates para la comprobacion BO
	 */
	private static final String CTE_VALOR_FUERA_RANGO = "-1";
	private static final String CTE_COMPROBACION_ES_BO = "1";
	
	private static String NIVEL_MAXIMO_AUTORIZACION = Constantes.CADENA_VACIA;
	
	// Logger de la clase.
	private static final LogHelper LOGGER = LogHelper.getLog(DatoEnRangoSrv.class);
	
	private enum PasosAsistente
	{
		CLASIFICACION, CONDICIONES_ECONOMICAS, INTERES, SISTEMA_DE_AMORTIZACION, GASTOS_Y_COMISIONES
	};
	
	/**
	 * Paso del proceso en el que nos encontramos.
	 * 
	 * @param tipoExpediente
	 * @param destinoPrincipal
	 * @param sector
	 * @param garantia
	 * @param canal
	 * @param importeSolicitado
	 * @param plazoTotal
	 * @param plazoCarencia
	 * @param plazoDiferimiento
	 * @param plazoDesembolso
	 * @param bloquesDatosInteres
	 * @param bloquesDatosSustitutivos
	 * @param bloquesTratamientoAdelantos
	 * @param bloquesSistemaAmortizacion
	 * @param bloquesGastosComisiones
	 * @return
	 */
	private PasosAsistente comprobarPasoAsistente(
			BigDecimal tipoExpediente, 
			BigDecimal destinoPrincipal, 
			BigDecimal sector, 
			BigDecimal garantia, 
			BigDecimal canal, 
			BigDecimal importeSolicitado, 
			BigDecimal plazoTotal, 
			BigDecimal plazoCarencia, 
			BigDecimal plazoDiferimiento, 
			BigDecimal plazoDesembolso, 
			List<String> bloquesDatosInteres, 
			List<String> bloquesDatosSustitutivos, 
			List<String> bloquesSistemaAmortizacion, 
			List<String> bloquesTratamientoAdelantos, 
			List<String> bloquesGastosComisiones)
	{
		PasosAsistente paso;
		
		paso = ((!(UtilidadesTramitacion.isBlankOrNull(tipoExpediente))) && 
				(!(UtilidadesTramitacion.isBlankOrNull(destinoPrincipal))) && 
				(!(UtilidadesTramitacion.isBlankOrNull(sector))) && 
				(!(UtilidadesTramitacion.isBlankOrNull(garantia))) && 
				(!(UtilidadesTramitacion.isBlankOrNull(canal))))
				? PasosAsistente.CLASIFICACION 
						: null;
		
		if (paso == null)
		{
			paso = ((!(UtilidadesTramitacion.isBlankOrNull(importeSolicitado))) && 
					(!(UtilidadesTramitacion.isBlankOrNull(plazoTotal))) && 
					(!(UtilidadesTramitacion.isBlankOrNull(plazoCarencia))) && 
					(!(UtilidadesTramitacion.isBlankOrNull(plazoDiferimiento))) && 
					(!(UtilidadesTramitacion.isBlankOrNull(plazoDesembolso))))
					? PasosAsistente.CONDICIONES_ECONOMICAS 
							: null;
		}
		
		if (paso == null)
		{
			paso = ((!(bloquesDatosInteres.isEmpty())) || 
					(!(bloquesDatosSustitutivos.isEmpty())))
					? PasosAsistente.INTERES 
							: null;
		}
		
		if (paso == null)
		{
			paso = ((!(bloquesSistemaAmortizacion.isEmpty())) || 
					(!(bloquesTratamientoAdelantos.isEmpty())))
					? PasosAsistente.SISTEMA_DE_AMORTIZACION 
							: null;
		}
		
		if (paso == null)
		{
			paso = (!(bloquesGastosComisiones.isEmpty())) 
					? PasosAsistente.GASTOS_Y_COMISIONES 
							: null;			
		}
		
		return paso;
	}

	/**
	 * 
	 * @param contexto
	 * @param entrada
	 * @return IContexto[]
	 */
	@Override
	public IContexto[] ejecutar(IContextoEjecucion contexto, IDatosEntradaTx entrada)
	{		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Inicio SNANPM165: Servicio de dato en rango");			
		}
				
		ResultadoDatoEnRangoVO datoEnRango = new ResultadoDatoEnRangoVO();
		
		contexto.setDiarioElectronico(new DiarioElectronico(
				Constantes.CTE_OPERACION_CO, 
				Integer.valueOf(0), 
				BigDecimal.ZERO, 
				BigDecimal.ZERO, 
				BigDecimal.ZERO, 
				BigDecimal.ZERO, 
				Constantes.CTE_STRING_EMPTY, 
				Constantes.CTE_STRING_EMPTY, 
				BigDecimal.ZERO, 
				BigDecimal.ZERO, 
				Integer.valueOf(0)));
		
		// Campos de entrada obligatorios.
		BigDecimal codigoProducto = entrada.getDecimal(CTE_COD_PRODUCTO);
		BigDecimal codigoSubproducto = entrada.getDecimal(CTE_COD_SUBPRODUCTO);
		BigDecimal colectivo = entrada.getDecimal(CTE_COLECTIVO);
		BigDecimal versionGeneral = entrada.getDecimal(CTE_VERSION_GENERAL);
		
		// 2016-10-26 - Si el colectivo viene a null, se setea a 0.
		if (null == colectivo)
		{
			colectivo = BigDecimal.ZERO;
		}
		
		// Campos de entrada optativos.
		BigDecimal tipoExpediente = entrada.getDecimal(CTE_TIPO_EXPEDIENTE);
		BigDecimal destinoPrincipal = entrada.getDecimal(CTE_DESTINO_PRINCIPAL);
		BigDecimal sector = entrada.getDecimal(CTE_SECTOR);
		BigDecimal garantia = entrada.getDecimal(CTE_GARANTIA);
		BigDecimal canal = entrada.getDecimal(CTE_CANAL);
		BigDecimal importeSolicitado = entrada.getDecimal(CTE_IMPORTE_SOLICITADO);
		BigDecimal plazoTotal = entrada.getDecimal(CTE_PLAZO_TOTAL);
		BigDecimal plazoCarencia = entrada.getDecimal(CTE_PLAZO_CARENCIA);
		BigDecimal plazoDiferimiento = entrada.getDecimal(CTE_PLAZO_DIFERIMIENTO);
		BigDecimal plazoDesembolso = entrada.getDecimal(CTE_PLAZO_DESEMBOLSO);
		
		// Campos de entrada optativos (bloques de datos).
		List<String> bloquesDatosInteres = new ArrayList<String>(Constantes.CTE_CERO);
		List<String> bloquesDatosSustitutivos = new ArrayList<String>(Constantes.CTE_CERO);		
		List<String> bloquesSistemaAmortizacion = new ArrayList<String>(Constantes.CTE_CERO);
		List<String> bloquesTratamientoAdelantos = new ArrayList<String>(Constantes.CTE_CERO);
		List<String> bloquesGastosComisiones = new ArrayList<String>(Constantes.CTE_CERO);
		
		//Campos de entrada para BO (optativos)
		BigDecimal esBO = entrada.getDecimal(CTE_MODIFICACION_BO);
		BigDecimal nucExpediente = entrada.getDecimal(CTE_NUC_EXPEDIENTE);
		
		String     deposito = entrada.getString(CTE_DEPOSITO_SN);
		
		//Comprobar si esta nulo el dato si lo esta se pone a vacio
		deposito = UtilidadesTramitacion.comprobarDatoNull(deposito);
		
		NIVEL_MAXIMO_AUTORIZACION = UtilidadesTramitacion.obtenerValorParametroUnico(
                "NIVELAUTRZ","NIVEL_BO");
		
		//esBO = new BigDecimal(1);
		//nucExpediente = new BigDecimal(100446638);
		// comprobamos si la oficina asociada al nuc pertenece a la red de Santiago
		
//		if (!UtilidadesTramitacion.isBlankOrNull(nucExpediente))
//		{
//			  pertenceRedSantiagoOMadrid = esCentroSantiagoOMadrid(nucExpediente);
//		}
		

		// Obtener los datos de la solicitud
		GestionDatosSolicitud gestionDatosSolicitud = new GestionDatosSolicitud();
		DatosSolicitudC solicitud = gestionDatosSolicitud.getUltimaVersion(nucExpediente);
		BigDecimal indNovacionSinModalidad = null; 
		boolean esNovacionSinModalidad = false;
		if (null != solicitud)
		{
			// Leer indicador de novacion sin modalidad
			indNovacionSinModalidad = solicitud.getIndNovacionSinModalidad();
			
			// Leer tipo de expediente, en caso de que no venga en la entrada
			if (null == tipoExpediente)
			{
				tipoExpediente = solicitud.getTipoExpediente();
			}
		}

		// 2018-02-14 - Determinar si es una novacion sin modalidad
		if ((null != indNovacionSinModalidad) && (indNovacionSinModalidad.compareTo(BigDecimal.ONE) == 0))
		{
			esNovacionSinModalidad = true;
		}
		
		// 2018-01-29 - Si el tipo de expediente se corresponde con una subrogacion interna 
		// (292, 260, 293) o una novacion (267), obtener los datos del riesgo origen.
		InformacionRiesgoOrigenVO datosRiesgoOrigen = null;
		boolean esSubrogacionNovacion = false;
		
		//Comprobar si el campo no es nulo
		if(null != tipoExpediente){
			esSubrogacionNovacion = (UtilidadesComun.esExpedienteSubrogacionAmpliacion(tipoExpediente) ||
					UtilidadesComun.esExpedienteNovacion(tipoExpediente));		
		}

		
		if (esSubrogacionNovacion)
		{
			datosRiesgoOrigen = GestionInformacionRiesgoOrigen.obtieneInformacionRO(
					nucExpediente, tipoExpediente, codigoProducto, Constantes.CADENA_VACIA);
		}
				
	
		for (int cont = 1; cont <= NUMERO_MAXIMO_BLOQUES; cont++)
		{
			final String bloque = entrada.getString(CTE_BLOQUE + '_' + cont);
			
			if (!(UtilidadesTramitacion.isBlankOrNull(bloque)))
			{
				final String tipoBloque = bloque.substring(0, 11);
				
				if (TIPO_BLOQUE_DATOS_INTERES.equals(tipoBloque))
				{
					bloquesDatosInteres.add(bloque);
				}
				else if (TIPO_BLOQUE_DATOS_SUSTITUTIVOS.equals(tipoBloque))
				{
					bloquesDatosSustitutivos.add(bloque);
				}
				else if (TIPO_BLOQUE_SISTEMA_DE_AMORTIZACION.equals(tipoBloque))
				{
					bloquesSistemaAmortizacion.add(bloque);
				}
				else if (TIPO_BLOQUE_TRATAMIENTO_DE_ADELANTOS.equals(tipoBloque))
				{
					bloquesTratamientoAdelantos.add(bloque);
				}
				else if (TIPO_BLOQUE_GASTOS_Y_COMISIONES.equals(tipoBloque))
				{
					bloquesGastosComisiones.add(bloque);
				}
			}
		}
		
		IContexto[] contextoSalida = null;		
		
		PasosAsistente paso = 
			this.comprobarPasoAsistente(
				tipoExpediente, 
				destinoPrincipal, 
				sector, 
				garantia, 
				canal, 
				importeSolicitado, 
				plazoTotal, 
				plazoCarencia, 
				plazoDiferimiento, 
				plazoDesembolso,
				bloquesDatosInteres, 
				bloquesDatosSustitutivos, 
				bloquesSistemaAmortizacion, 
				bloquesTratamientoAdelantos, 
				bloquesGastosComisiones);
		
		try
		{			
			if (paso != null)
			{
				List<String> tablas = this.getTablasCatalogo(paso);				
				List<CEcc> listDatosVersion = null;

				// 2018-02-14 - Si es una novacion sin modalidad, obtener los datos de la 5980
				// para hacer las validaciones, en lugar de los datos del producto de la solicitud.
				if (esNovacionSinModalidad)
				{
					// Obtener datos de la 5980
					
					// Producto, subproducto y colectivo
					Integer codProdNovacionSinModalidad = new Integer(Constantes.CTE_PRODUCTO_NOVACION_SIN_MODALIDAD.intValue());
					Integer codSubprodNovacionSinModalidad = new Integer(Constantes.CTE_SUBPRODUCTO_NOVACION_SIN_MODALIDAD.intValue());
					Integer colectivoNovacionSinModalidad = new Integer(Constantes.CTE_COLECTIVO_NOVACION_SIN_MODALIDAD.intValue());
										
					// Version vigente
					Date fechaHoy = new Date(DateUtils.getSoloFecha(DateUtils.dateNow()).getTime());
					Time horaHoy = new Time(DateUtils.getSoloHorario(DateUtils.dateNow()).getTime());	
					VersionEng versionEng = new VersionEng();		
					VersionesC version = versionEng.obtenerVersionVigenteEnFecha(codProdNovacionSinModalidad, 
							codSubprodNovacionSinModalidad,  colectivoNovacionSinModalidad, fechaHoy, horaHoy);
					Integer versionGeneralNovacionSinModalidad = version.getVersionKey().getIdVersionGeneral();
					
					// Versiones de datos de las tablas solicitadas
					listDatosVersion = obtenerDatosVersion(
							codProdNovacionSinModalidad, 
							codSubprodNovacionSinModalidad, 
							colectivoNovacionSinModalidad, 
							versionGeneralNovacionSinModalidad,
							tablas
					);						
				}
				else
				{
					// Versiones de datos de las tablas solicitadas.
					listDatosVersion = obtenerDatosVersion(
							new Integer(codigoProducto.intValue()), 
							new Integer(codigoSubproducto.intValue()), 
							new Integer(colectivo.intValue()), 
							new Integer(versionGeneral.intValue()),
							tablas
					);
				}
				
				switch (paso)
				{
					case CLASIFICACION:
					{
						break;
					}
					case CONDICIONES_ECONOMICAS:
					{
						List<CEcc> listDatosEco = 
							this.getListaTipoBase(listDatosVersion, DatEcoC.class);
							
					
						this.validarCondicionesEconomicas(
								importeSolicitado, 
								plazoTotal, 
								plazoCarencia, 
								plazoDiferimiento, 
								plazoDesembolso, 
								listDatosEco, 
								datoEnRango,
								esBO,
								nucExpediente,
								destinoPrincipal,
								deposito,
								colectivo, 
								datosRiesgoOrigen, 
								esSubrogacionNovacion);
						break;
					}
					case INTERES:
					{
						List<CEcc> listInteres = 
							this.getListaTipoBase(listDatosVersion, InteresC.class);
						List<CEcc> listTechosSuelosDife = 
							this.getListaTipoBase(listDatosVersion, TechosSuelosDifeC.class);	
						
						//Introducimos un nuevo parametro en la llamada de validacion
						//Ahora cuando es BO se dejará pasar cualquier dato validado
						//Además se colocará el máximo nivel de autorización
						//El parametro es el BigDecimal esBO
						List<TechosSuelosDifeC> listTechosSueloIntereses = this.validarTramosInteres(
																					bloquesDatosInteres, 
																					listInteres, 
																					listTechosSuelosDife, 
																					datoEnRango,
																					esBO,
																					nucExpediente, 
																					datosRiesgoOrigen, 
																					esSubrogacionNovacion, 
																					esNovacionSinModalidad);
						//Introducimos un nuevo parametro en la llamada de validación
						//Ahora cuando es BO se dejará pasar el dato para valores fuera de rango
						//Además se colocará el máximo nivel de autorización
						this.validarSustitutivos(
								bloquesDatosSustitutivos, 
								listTechosSuelosDife, 
								datoEnRango,
								listTechosSueloIntereses,
								esBO,
								nucExpediente, 
								datosRiesgoOrigen, 
								esSubrogacionNovacion, 
								esNovacionSinModalidad);
						break;
					}
					case SISTEMA_DE_AMORTIZACION:
					{
						List<CEcc> listCondicionesCapital = 
							this.getListaTipoBase(listDatosVersion, CondicionesCapitalC.class);
						//Llamada a la validacion de sistemas de amortizacion
						//Aqui se validan los datos para saber si estan en rango o no
						//Además se coloca el nivel correspondiente
						//Se introduce un nuevo parametro para indicar si es BO
						//En caso de ser BO se deja pasar el dato aunque esté fuera de rango
						//Además se coloca el maximo nivel de autorización 40
						this.validarSistemasAmortizacion(
								bloquesSistemaAmortizacion, 
								listCondicionesCapital, 
								datoEnRango,
								esBO,
								nucExpediente, 
								datosRiesgoOrigen, 
								esSubrogacionNovacion, 
								esNovacionSinModalidad);
						
						List<CEcc> listTratamientosAdelantos = 
							this.getListaTipoBase(listDatosVersion, AdelantoC.class);
						
						//Validar el tratamiento de adelantos
						//Aquí se realiza la validación del tratamiento de adelantos
						//Se introduce un nuevo parametro para saber si es BO o no
						//En caso de ser BO se deja pasar el dato a pesar de no estar 
						//en rango, además se coloca el máximo nivel de autorizacion
						//nivel 40
						this.validarTratamientosAdelantos(
								bloquesTratamientoAdelantos, 
								listTratamientosAdelantos, 
								datoEnRango,
								esBO,
								nucExpediente, 
								datosRiesgoOrigen, 
								esSubrogacionNovacion, 
								esNovacionSinModalidad);
						break;
					}
					case GASTOS_Y_COMISIONES:
					{
						List<CEcc> listComisiones = 
							this.getListaTipoBase(listDatosVersion, ComisionesC.class);
						//Validar los gastos y comisiones
						//Aquí se realiza la validación correspondiente a gastos y comisiones
						//Se introduce un nuevo parametro para saber si se esta tramitando
						//desde una oficina de BO, en caso de ser asi se deja pasar el dato
						//aunque no este en rango además se coloca el maximo nivel de autorizacion
						this.validarGastosComisiones(
								bloquesGastosComisiones, 
								listComisiones, 
								datoEnRango,
								esBO,
								nucExpediente, 
								datosRiesgoOrigen, 
								esSubrogacionNovacion, 
							    tipoExpediente, 
							    esNovacionSinModalidad);
						break;
					}
					default:
						break;
				}
			}
			
			contextoSalida = new IContexto[Constantes.CTE_CERO];
			
			if (paso != null)
			{
				switch (paso)
				{
					case CLASIFICACION:
					{
						break;
					}
					case CONDICIONES_ECONOMICAS:
					{
						contextoSalida = ContextoDatoEnRango.rellenarDatosContexto(datoEnRango);
						break;
					}
					case INTERES:
					case SISTEMA_DE_AMORTIZACION:							
					case GASTOS_Y_COMISIONES:
					{				
						contextoSalida = ContextoDatoEnRangoBloques.rellenarDatosContexto(datoEnRango);
						break;					
					}
					default:
						break;
				}
			}
		}
		catch (DatoEnRangoException dere)
		{
			throw new RuntimeException(
					new StringBuilder
						("ERR_VAL_010 - Error inesperado durante la validación de servicio de dato en rango: ")
					.append
						(dere.getMessage()).toString());
		}
						
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Fin SNANPM165: Servicio de dato en rango");
		}
				
		return contextoSalida;
		
	}
	
	/**
	 * Devuelve una lista de objetos CEcc que cumplan las condiciones indicadas
	 * como argumento.
	 * 
	 * @param listObjetosCEcc
	 * @param orden
	 * @param tipo
	 * @param prioridad
	 * @param tipoReferencia
	 * @return
	 */
	private List<CEcc> filtrarListaTipoBase(
			final List<CEcc> listObjetosCEcc, 
			final Integer orden, 
			final String tipo, final 
			Integer prioridad, 
			final Integer tipoReferencia, 
			boolean esSubrogacionNovacion, 
			boolean sinModalidad)
	{
		List<CEcc> filterListObjetosCEcc = new ArrayList<CEcc>(Constantes.CTE_CERO);
		
		for (CEcc objetoCEcc : listObjetosCEcc)
		{
			if (objetoCEcc instanceof AdelantoC)
			{
				AdelantoC adelanto = (AdelantoC) objetoCEcc;
				
				// Corregido el 12-04-2012
				// Para filtrar los tratamientos de adelanto lo hacemos por tipo imputación en lugar de prioridad 
				// (que es modificable). En el campo de entrada prioridad viene informado el tipo de imputación.
				if (adelanto.getAdelantoKey().getImputacion().equals(prioridad))
				{
					filterListObjetosCEcc.add(adelanto);
				}
			}
			else if (objetoCEcc instanceof ComisionesC)
			{
				ComisionesC comision = (ComisionesC) objetoCEcc;
				
				if ((comision.getComisionesKey().getIntIdOrden().equals(orden)) && 
					(comision.getComisionesKey().getIntIdTipoComision().equals(tipo)))
				{
					filterListObjetosCEcc.add(comision);
				}
			}
			else if (objetoCEcc instanceof CondicionesCapitalC)
			{
				CondicionesCapitalC condicionesCapital = (CondicionesCapitalC) objetoCEcc;
				
				if (condicionesCapital.getOrden().equals(orden))
				{
					filterListObjetosCEcc.add(condicionesCapital);
				}
			}			
			else if (objetoCEcc instanceof InteresC)
			{
				InteresC interes = (InteresC) objetoCEcc;
				
				// 2018-03-16 - Para subrogaciones y novaciones sin modalidad no filtrar por tipo
				if (esSubrogacionNovacion && sinModalidad)
				{
					if (interes.getOrden().equals(orden))
					{
						filterListObjetosCEcc.add(interes);
					}
				}
				else
				{
					if ((interes.getOrden().equals(orden)) && (interes.getTipo().equals(tipo)))
					{
						filterListObjetosCEcc.add(interes);
					}
				}
			}
			else if (objetoCEcc instanceof TechosSuelosDifeC)
			{
				TechosSuelosDifeC techosSuelosDife = (TechosSuelosDifeC) objetoCEcc;
				
				// 2018-03-16 - Para subrogaciones y novaciones sin modalidad no filtrar por tipo referencia
				if (esSubrogacionNovacion && sinModalidad)
				{
					if ((techosSuelosDife.getOrden().equals(orden)) &&
						(techosSuelosDife.getTechosSuelosDifeKey().getPrioridad().equals(prioridad)))
					{
						filterListObjetosCEcc.add(techosSuelosDife);
					}
				}
				else
				{
					if ((techosSuelosDife.getOrden().equals(orden)) && 
						(techosSuelosDife.getTechosSuelosDifeKey().getPrioridad().equals(prioridad)) &&
						(techosSuelosDife.getTipoRef().equals(tipoReferencia)))
					{
						filterListObjetosCEcc.add(techosSuelosDife);
					}
				}
			}
		}		
		
		return filterListObjetosCEcc;
	}	
	
	/**
	 * Devuelve la lista de objetos del tipo <code>tipoBase</code> que se encuentran 
	 * en la lista de versiones.
	 * 
	 * @param listVersionTablas
	 * @param tipoBase
	 * @return
	 */
	@SuppressWarnings(value = "rawtypes")
	private List<CEcc> getListaTipoBase(final List<CEcc> listVersionTablas, final Class tipoBase)
	{
		List<CEcc> listObjetosCEcc = new ArrayList<CEcc>(Constantes.CTE_CERO.intValue());
		
		for (CEcc version : listVersionTablas)
		{
			if (version.getClass().getName().equals(tipoBase.getName()))
			{
				listObjetosCEcc.add(version);
			}
		}
		
		return listObjetosCEcc;
	}	
	
	/**
	 * 
	 * @param paso
	 * @return Nombres de las tablas utilizadas en el paso actual del asistente.
	 */
	private List<String> getTablasCatalogo(final PasosAsistente paso)
	{
		List<String> tablas = new ArrayList<String>(0);
		
		switch (paso)
		{
			case CLASIFICACION:
			{
				break;
			}
			case CONDICIONES_ECONOMICAS:
			{
				// Tabla 'DATOS ECONOMICOS'.
				tablas.add(CTE_TABLA_DATOS_ECONOMICOS);
				break;
			}
			case INTERES:
			{				
				// Tabla 'CONDICIONES DE INTERES'.
				tablas.add(CTE_TABLA_COND_INTERES);
				// Tabla 'DIFERENCIALES DE INTERES'.
				tablas.add(CTE_TABLA_DIFE_INTERES);
				break;				
			}
			case SISTEMA_DE_AMORTIZACION:
			{
				// Tabla 'CONDICIONES DE CAPITAL'.
				tablas.add(CTE_TABLA_COND_CAPITAL);
				// Tabla 'TRATAMIENTO ADELANTOS PRODUCTO'.
				tablas.add(CTE_TABLA_TRATAMIENTO_ADELANTOS);
				break;
			}
			case GASTOS_Y_COMISIONES:
			{
				// Tabla 'COMISIONES'.
				tablas.add(CTE_TABLA_COMISIONES);
				break;
			}
			default:
				break;
		}
				
		return tablas;
	}
	
	/**
	 * 
	 * @param importeSolicitado
	 * @param plazoTotal
	 * @param plazoCarencia
	 * @param plazoDiferimiento
	 * @param plazoDesembolso
	 * @param listDatosEco Datos económicos contra los que se realiza la validación.
	 * @param datoEnRango Resultado de la validación.
	 */
	private void validarCondicionesEconomicas(
			final BigDecimal importeSolicitado, 
			final BigDecimal plazoTotal, 
			final BigDecimal plazoCarencia, 
			final BigDecimal plazoDiferimiento, 
			final BigDecimal plazoDesembolso, 
			final List<CEcc> listDatosEco, 
			ResultadoDatoEnRangoVO datoEnRango,
			BigDecimal esBO,
			BigDecimal nucExpediente,
			BigDecimal destinoPrincipal,
			String     deposito,
			BigDecimal colectivo, 
			InformacionRiesgoOrigenVO datosRiesgoOrigen, 
			boolean esSubrogacionNovacion)
	{
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Inicio de validación del paso 'Condiciones económicas'");
		}

		boolean esRefaccionario = UtilidadesTramitacion.esRefaccionario(nucExpediente);
		
		GestionDatoEnRango gdr = new GestionDatoEnRango();
		// Importe solicitado.
		String nivelImporteSolicitado = gdr.validarDatoEconomico(TablaAN03TB01.IMPORTE_SOLICITADO, 
						importeSolicitado, listDatosEco,destinoPrincipal,deposito,esRefaccionario,colectivo, 
						datosRiesgoOrigen, esSubrogacionNovacion);
		
		//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//		if ((nivelImporteSolicitado.equals("30") || 
//				nivelImporteSolicitado.equals("40") || 
//				nivelImporteSolicitado.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//		{
//			nivelImporteSolicitado = conversionNivelAutorizacionDTSantiagoOMadrid(nivelImporteSolicitado); // se recalcula el plazo para Red de Santiago	
//		}
		
		datoEnRango.setImporteSolicitado(nivelImporteSolicitado);
		
		// Plazo total.
		String nivelPlazoTotal = gdr.validarDatoEconomico(TablaAN03TB01.PLAZO_TOTAL, 
						new Integer(plazoTotal.intValue()), listDatosEco,destinoPrincipal,deposito,
						esRefaccionario,colectivo, datosRiesgoOrigen, esSubrogacionNovacion);
		
		//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//		if ((nivelPlazoTotal.equals("30")|| 
//				nivelPlazoTotal.equals("40")|| 
//				nivelPlazoTotal.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//		{
//			nivelPlazoTotal = conversionNivelAutorizacionDTSantiagoOMadrid(nivelPlazoTotal); // se recalcula el plazo para Red de Santiago	
//		}
		
		datoEnRango.setPlazoTotal(nivelPlazoTotal);
		
		// Plazo carencia.
		String nivelPlazoCarencia =	gdr.validarDatoEconomico(TablaAN03TB01.PLAZO_CARENCIA, 
						new Integer(plazoCarencia.intValue()), listDatosEco,destinoPrincipal,deposito,
						esRefaccionario,colectivo, datosRiesgoOrigen, esSubrogacionNovacion);
	
		//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//		if ((nivelPlazoCarencia.equals("30")|| 
//				nivelPlazoCarencia.equals("40")|| 
//				nivelPlazoCarencia.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//		{
//			nivelPlazoCarencia = conversionNivelAutorizacionDTSantiagoOMadrid(nivelPlazoCarencia); // se recalcula el plazo para Red de Santiago	
//		}
		
		datoEnRango.setPlazoCarencia(nivelPlazoCarencia);
		
		// Plazo diferimiento.
		String nivelPlazoDiferimiento = gdr.validarDatoEconomico(TablaAN03TB01.PLAZO_DIFERIMIENTO, 
						new Integer(plazoDiferimiento.intValue()), listDatosEco,destinoPrincipal,deposito,
						esRefaccionario,colectivo, datosRiesgoOrigen, esSubrogacionNovacion);
		
		//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//		if ((nivelPlazoDiferimiento.equals("30")|| 
//				nivelPlazoDiferimiento.equals("40")|| 
//				nivelPlazoDiferimiento.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//		{
//			nivelPlazoDiferimiento = conversionNivelAutorizacionDTSantiagoOMadrid(nivelPlazoDiferimiento); // se recalcula el plazo para Red de Santiago	
//		}
		
		datoEnRango.setPlazoDiferimiento(nivelPlazoDiferimiento);
		
		// Plazo desembolso.
		
		String nivelPlazoDesembolso = gdr.validarDatoEconomico(TablaAN03TB01.PLAZO_DESEMBOLSO, 
						new Integer(plazoDesembolso.intValue()), listDatosEco,destinoPrincipal,deposito,
						esRefaccionario,colectivo, datosRiesgoOrigen, esSubrogacionNovacion);
		
		//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//		if ((nivelPlazoDesembolso.equals("30") || 
//				nivelPlazoDesembolso.equals("40") || 
//				nivelPlazoDesembolso.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//		{
//			nivelPlazoDesembolso = conversionNivelAutorizacionDTSantiagoOMadrid(nivelPlazoDesembolso); // se recalcula el plazo para Red de Santiago	
//		}

		datoEnRango.setPlazoDesembolso(nivelPlazoDesembolso);
		
		if(datoEnRango.getImporteSolicitado().equals(CTE_VALOR_FUERA_RANGO)
				|| datoEnRango.getPlazoTotal().equals(CTE_VALOR_FUERA_RANGO)
				|| datoEnRango.getPlazoCarencia().equals(CTE_VALOR_FUERA_RANGO)
				|| datoEnRango.getPlazoDiferimiento().equals(CTE_VALOR_FUERA_RANGO)
				|| datoEnRango.getPlazoDesembolso().equals(CTE_VALOR_FUERA_RANGO)) {
			//Si alguno de los valores viene fuera de rango
			modificaAutorizacionCondicionesEconomicas(datoEnRango,esBO,nucExpediente);
		}
	}
	
	
	
	/**
	 * 
	 * @param bloquesGastosComisiones
	 * @param listComisiones Comisiones contra las que se realiza la validación.
	 * @param datoEnRango Resultado de la validación.
	 * @throws DatoEnRangoException
	 */
	private void validarGastosComisiones(
			List<String> bloquesGastosComisiones, 
			List<CEcc> listComisiones, 
			ResultadoDatoEnRangoVO datoEnRango,
			BigDecimal esBO,
			BigDecimal nucExpediente, 
			InformacionRiesgoOrigenVO datosRiesgoOrigen, 
			boolean esSubrogacionNovacion, 
			BigDecimal tipoExpediente, 
			boolean sinModalidad) throws DatoEnRangoException	
	{
		IContexto[] tarifasComision = null;
		List<IContexto> listaTarifasComision = null;
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitudC = gds.getUltimaVersionIncompleta(nucExpediente);
		if(null != datosSolicitudC){
			tarifasComision =	UtilidadesComun.obtencionDatosTarifa(datosSolicitudC.getProducto(), datosSolicitudC.getSubproducto(),
					datosSolicitudC.getVersionGeneral(), datosSolicitudC.getPlazoTotal().toString(), 
					datosSolicitudC.getIdTarifa(), Constantes.CTE_ORIGEN_CONSULTA_TARIFA_SOLICITUD, 
					datosSolicitudC.getImporteTotal(), datosSolicitudC.getDatosSolicitudKey().getNucExpediente(),BigDecimal.ONE,null);
		}
		
		tarifasComision = GestionDatoEnRango.filtrarTarifasComision(tarifasComision);
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Inicio de validación del paso 'Gastos y comisiones'");
		}
		
		GestionDatoEnRango gdr = new GestionDatoEnRango();
		
		try
		{
			for (String bloque : bloquesGastosComisiones)
			{
				String bloqueValidacion = Constantes.CTE_STRING_EMPTY;
				
				// Tipo de bloque (11 caracteres).
				String tipoBloque = bloque.substring(0, 11);
				bloqueValidacion += tipoBloque;
				
				// Orden (2 caracteres).
				String orden = bloque.substring(11, 13);
				bloqueValidacion += orden;
				
				// Tipo (3 caracteres).
				String tipo = bloque.substring(13, 16);
				bloqueValidacion += tipo;
				
				// Prioridad (5 caracteres).
				String prioridad = bloque.substring(16, 21);
				bloqueValidacion += prioridad;
				
				
				listaTarifasComision = new ArrayList<IContexto>();
				listaTarifasComision = GestionDatoEnRango.filtrarTarifaComisionTipoPlazoOrden(tarifasComision, orden, tipo);
				
				List<CEcc> filteredComisionesList = 
					this.filtrarListaTipoBase(
							listComisiones, 
							Integer.valueOf(orden), tipo, null, null,
							esSubrogacionNovacion,
							sinModalidad);
				/**
				 * Validar comisión se lleva el porcentaje de comisión y lo compara contra
				 * una tabla, si esta dentro del rango de un nivel de autorización devuelve
				 * el nivel de autorización correspondiente 10,20,30,40, si no está devuelve 0
				 * si esta fuera de rango devuelve -1
				 */
				// Porcentaje de comisión (8 caracteres).
				String porcentajeComision = bloque.substring(21, 29);
				porcentajeComision = 
					gdr.validarComision(
							TablaAN06TB01.PORCENTAJE_COMISION, 
							new BigDecimal(porcentajeComision), filteredComisionesList,listaTarifasComision, 
							tipo, datosRiesgoOrigen, esSubrogacionNovacion, tipoExpediente);
			
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((porcentajeComision.equals("30") || 
//						porcentajeComision.equals("40") || 
//						porcentajeComision.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					porcentajeComision = conversionNivelAutorizacionDTSantiagoOMadrid(porcentajeComision); // se recalcula el plazo para Red de Santiago	
//				}
	
				//Comprobacion si esta fuera de rango o no
				//Si es -1 esta fuera de rango, cuando sea BO dejamos pasar y 
				//Otorgamos nivel maximo de autorización
				if(porcentajeComision.equals(CTE_VALOR_FUERA_RANGO)) {
					porcentajeComision = modificaAutorizacionGastosComisiones(porcentajeComision,esBO,nucExpediente,TablaAN06TB01.PORCENTAJE_COMISION);
				}
				
				porcentajeComision = String.format("%1$8s", porcentajeComision).replace(' ', '0');
				bloqueValidacion += porcentajeComision;				
				
				// Importe mínimo de comisión (12 caracteres).
				String importeMinComision = bloque.substring(29, 41);
				importeMinComision = 
					gdr.validarComision(
							TablaAN06TB01.IMPORTE_MINIMO_COMISION, 
							new BigDecimal(importeMinComision), filteredComisionesList,listaTarifasComision, 
							tipo, datosRiesgoOrigen, esSubrogacionNovacion, tipoExpediente);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
				
//				if ((importeMinComision.equals("30") || 
//						importeMinComision.equals("40") || 
//						importeMinComision.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					importeMinComision = conversionNivelAutorizacionDTSantiagoOMadrid(importeMinComision); // se recalcula el plazo para Red de Santiago	
//				}
				
				/**
				 * Comprobacion si esta fuera de rango o no, si es -1 esta fuera de rango
				 * cuando esté fuera de rango y sea BO otorgamos el máximo nivel de autorizacion
				 */
				if(importeMinComision.equals(CTE_VALOR_FUERA_RANGO)) {
					importeMinComision = modificaAutorizacionGastosComisiones(importeMinComision, esBO,nucExpediente,TablaAN06TB01.IMPORTE_MINIMO_COMISION);
				}
				importeMinComision = String.format("%1$12s", importeMinComision).replace(' ', '0');
				bloqueValidacion += importeMinComision;
				
				// Porcentaje de adelanto (8 caracteres).
				String porcentajeAdelanto = bloque.substring(41, 49);
				porcentajeAdelanto = 
					gdr.validarComision(
							TablaAN06TB01.PORCENTAJE_ADELANTO, 
							new BigDecimal(porcentajeAdelanto), filteredComisionesList,listaTarifasComision, 
							tipo, datosRiesgoOrigen, esSubrogacionNovacion, tipoExpediente);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
				//				if ((porcentajeAdelanto.equals("30") || 
				//						porcentajeAdelanto.equals("40") || 
				//						porcentajeAdelanto.equals("50")) && (pertenceRedSantiagoOMadrid)) 
				//				{
				//					porcentajeAdelanto = conversionNivelAutorizacionDTSantiagoOMadrid(porcentajeAdelanto); // se recalcula el plazo para Red de Santiago	
				//				}
				
				/**
				 * Si el porcentaje de adelanto esta fuera  de rango y la oficina tramitadora
				 * es BO modificamos al máximo nivel de autorizacion
				 */
				if(porcentajeAdelanto.equals(CTE_VALOR_FUERA_RANGO)) {
					porcentajeAdelanto = modificaAutorizacionGastosComisiones(porcentajeAdelanto, esBO,nucExpediente,TablaAN06TB01.PORCENTAJE_ADELANTO);
				}
				porcentajeAdelanto = String.format("%1$8s", porcentajeAdelanto).replace(' ', '0');
				bloqueValidacion += porcentajeAdelanto;
				
				// Plazo de comisión (5 caracteres).
				String plazoComision = bloque.substring(49, 54);
				plazoComision = 
					gdr.validarComision(
							TablaAN06TB01.PLAZO_COMISION, 
							Integer.valueOf(plazoComision), filteredComisionesList,listaTarifasComision, 
							tipo, datosRiesgoOrigen, esSubrogacionNovacion, tipoExpediente);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((plazoComision.equals("30") || 
//						plazoComision.equals("40") || 
//						plazoComision.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					plazoComision = conversionNivelAutorizacionDTSantiagoOMadrid(plazoComision); // se recalcula el plazo para Red de Santiago	
//				}
				
				/**
				 * Si el plazo de comisión esta fuera de rango y la oficina tramitadora es
				 * BO modificamos al máximo nivel de autorización
				 */
				if(plazoComision.equals(CTE_VALOR_FUERA_RANGO)) {
					plazoComision = modificaAutorizacionGastosComisiones(plazoComision, esBO,nucExpediente,TablaAN06TB01.PLAZO_COMISION);
				}
				plazoComision = String.format("%1$5s", plazoComision).replace(' ', '0');
				bloqueValidacion += plazoComision;
				
				// Bloque validación.
				datoEnRango.addBloque(bloqueValidacion);
				// Bloque original.
				datoEnRango.addBloque(bloque);
			}
		}
		catch (StringIndexOutOfBoundsException sioobe)
		{
			throw new DatoEnRangoException(sioobe.getMessage());
		}
		catch (NumberFormatException nfe)
		{
			throw new DatoEnRangoException(nfe.getMessage());
		}
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Fin de validación del paso 'Gastos y comisiones'");
		}
	}
	
	/**
	 * 
	 * @param bloquesSistemaAmortizacion
	 * @param listCondicionesCapital Condiciones de capital contra las que se realiza la validación.
	 * @param datoEnRango Resultado de la validación.
	 * @throws DatoEnRangoException
	 */
	private void validarSistemasAmortizacion(
			List<String> bloquesSistemaAmortizacion, 
			List<CEcc> listCondicionesCapital, 
			ResultadoDatoEnRangoVO datoEnRango,
			BigDecimal esBO,
			BigDecimal nucExpediente, 
			InformacionRiesgoOrigenVO datosRiesgoOrigen, 
			boolean esSubrogacionNovacion, 
			boolean sinModalidad) throws DatoEnRangoException
	{
		
				
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Inicio de validación del paso 'Sistema de amortización'");						
		}
		
		GestionDatoEnRango gdr = new GestionDatoEnRango();
		
		try
		{
			for (String bloque : bloquesSistemaAmortizacion)
			{
				String bloqueValidacion = Constantes.CTE_STRING_EMPTY;
				
				// Tipo de bloque (11 caracteres).
				String tipoBloque = bloque.substring(0, 11);
				bloqueValidacion += tipoBloque;
				
				// Orden (3 caracteres).
				String orden = bloque.substring(11, 14);
				bloqueValidacion += orden;
				
				// Tipo (2 caracteres).
				String tipo = bloque.substring(14, 16);
				bloqueValidacion += tipo;
				
				// Prioridad (5 caracteres).
				String prioridad = bloque.substring(16, 21);
				bloqueValidacion += prioridad;
				
				List<CEcc> filteredCondicionesCapitalList = 
					this.filtrarListaTipoBase(
							listCondicionesCapital, 
							Integer.valueOf(orden), null, null, null,
							esSubrogacionNovacion, sinModalidad);
				
				// Plazo (5 caracteres).
				String plazo = bloque.substring(21, 26);
				plazo = 
					gdr.validarCondicionCapital(
							TablaAN04TB01.PLAZO, 
							Integer.valueOf(plazo), filteredCondicionesCapitalList, 
							datosRiesgoOrigen, esSubrogacionNovacion);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
				
//				if ((plazo.equals("30") || 
//						plazo.equals("40") || 
//						plazo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					plazo = conversionNivelAutorizacionDTSantiagoOMadrid(plazo);
//				}
				
				/**
				 * Si el plazo esta fuera de rango y la oficina tramitadora es BO
				 * se otorga el maximo nivel de autorizacion
				 */
				if(plazo.equals(CTE_VALOR_FUERA_RANGO)) {
					plazo = modificaAutorizacionSistemasAmortizacion(plazo, esBO,nucExpediente,TablaAN04TB01.PLAZO);
				}
	
				plazo = String.format("%1$5s", plazo).replace(' ', '0');
				bloqueValidacion += plazo;
				
				// Pago aplazado (8 caracteres).
				String pagoAplazado = bloque.substring(26, 34);
				pagoAplazado = 
					gdr.validarCondicionCapital(
							TablaAN04TB01.PAGO_APLAZADO, 
							new BigDecimal(pagoAplazado), filteredCondicionesCapitalList, 
							datosRiesgoOrigen, esSubrogacionNovacion);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((pagoAplazado.equals("30") || 
//						pagoAplazado.equals("40") || 
//						pagoAplazado.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					pagoAplazado = conversionNivelAutorizacionDTSantiagoOMadrid(pagoAplazado); 
//				}
				
				/**
				 * Si el pago aplazado está fuera de rango y la oficina tramitadora es BO
				 * se otorga el maximo nivel de autorizacion
				 */
				if(pagoAplazado.equals(CTE_VALOR_FUERA_RANGO)) {
					pagoAplazado = modificaAutorizacionSistemasAmortizacion(pagoAplazado, esBO,nucExpediente,TablaAN04TB01.PAGO_APLAZADO);
				}
				pagoAplazado = String.format("%1$8s", pagoAplazado).replace(' ', '0');
				bloqueValidacion += pagoAplazado;
				
				// Bloque validación.
				datoEnRango.addBloque(bloqueValidacion);				
				// Bloque original.
				datoEnRango.addBloque(bloque);
			}
		}
		catch (StringIndexOutOfBoundsException sioobe)
		{
			LOGGER.error(sioobe);
			throw new DatoEnRangoException(sioobe.getMessage());
		}
		catch (NumberFormatException nfe)
		{
			LOGGER.error(nfe);
			throw new DatoEnRangoException(nfe.getMessage());
		}
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Fin de validación del paso 'Sistema de amortización'");
		}
	}
	
	/**
	 * 
	 * @param bloquesDatosSustitutivos
	 * @param listTechosSuelosDife Diferenciales de interés contra los que se realiza la validación.
	 * @param datoEnRango Resultado de la validación.
	 * @oaram listTechosSueloIntereses Lista de techos y suelo asociados a los tramos de interés
	 * @throws DatoEnRangoException
	 */
	private void validarSustitutivos(
			List<String> bloquesDatosSustitutivos, 
			List<CEcc> listTechosSuelosDife, 
			ResultadoDatoEnRangoVO datoEnRango,
			List <TechosSuelosDifeC> listTechosSueloIntereses,
			BigDecimal esBO,
			BigDecimal nucExpediente, 
			InformacionRiesgoOrigenVO datosRiesgoOrigen, 
			boolean esSubrogacionNovacion, 
			boolean sinModalidad) throws DatoEnRangoException 
	{
		
		
		if(LOGGER.isDebugEnabled())
		{			
			LOGGER.debug("Inicio de validación del paso 'Interés'");
		}
		
		GestionDatoEnRango gdr = new GestionDatoEnRango();
		int indInteres = Constantes.CTE_IND_INTERES_SUSTITUTIVO;
		
		try
		{
			for (String bloque : bloquesDatosSustitutivos)
			{
				String bloqueValidacion = Constantes.CTE_STRING_EMPTY;
				
				// Tipo de bloque (11 caracteres).
				String tipoBloque = bloque.substring(0, 11);
				bloqueValidacion += tipoBloque;
				
				// Orden (5 caracteres).
				String orden = bloque.substring(11, 16);
				bloqueValidacion += orden;
				
				// Tipo (2 caracteres).
				String tipo = bloque.substring(16, 18);
				bloqueValidacion += tipo;
				
				// Prioridad (5 caracteres).
				String prioridad = bloque.substring(18, 23);
				bloqueValidacion += prioridad;
				
				// Tipo referencia (4 caracteres).
				String tipoReferencia = bloque.substring(23, 27);
				bloqueValidacion += tipoReferencia;
				
				TechosSuelosDifeC techoSueloInteres = capturarTechoSueloInteres(listTechosSueloIntereses,
																				orden);
				
				List<CEcc> filteredTechosSuelosDifeList = 
					this.filtrarListaTipoBase(listTechosSuelosDife, 
							Integer.valueOf(orden), null, Integer.valueOf(prioridad), 
							Integer.valueOf(tipoReferencia), esSubrogacionNovacion, sinModalidad);
				
				// Diferencial (11 caracteres).
				String diferencial = bloque.substring(27, 38);
				diferencial = 
					gdr.validarDiferencialInteres(
							TablaAN08TB01.DIFERENCIAL, 
							new BigDecimal(diferencial), filteredTechosSuelosDifeList, 
							Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
							esSubrogacionNovacion, indInteres);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((diferencial.equals("30") || 
//						diferencial.equals("40") || 
//						diferencial.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					diferencial = conversionNivelAutorizacionDTSantiagoOMadrid(diferencial); // se recalcula el plazo para Red de Santiago	
//				}
				
				/**
				 * Si el diferencial está fuera de rango y la oficina tramitadora es BO
				 * se otorga el máximo nivel de autorizacion
				 */
				if(diferencial.equals(CTE_VALOR_FUERA_RANGO)) {
					diferencial = modificaAutorizacionSustitutivos(diferencial, esBO,nucExpediente,TablaAN08TB01.DIFERENCIAL);
				}
				diferencial = String.format("%1$11s", diferencial).replace(' ', '0');
				bloqueValidacion += diferencial;
				
				// Validación excluyente (Diferencial mínimo máximo / Diferencial bonificado).
				if ((Constantes.CTE_STRING_COD_TRAMO_VARIABLE_BONIFICADO.equals(tipo)) || 
					(Constantes.CTE_STRING_COD_TRAMO_VARIABLE_PENALIZABLE.equals(tipo)))
				{
					// Casos de validación de 'Diferencial mínimo máximo'.
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_BONIFICADO = "03".
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_PENALIZABLE = "04".
					
					// Diferencial mínimo máximo (11 caracteres).
					String diferencialMinMax = bloque.substring(38, 49);
					diferencialMinMax = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.DIFERENCIAL_MIN_MAX, 
								new BigDecimal(diferencialMinMax), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((diferencialMinMax.equals("30") || 
//						diferencialMinMax.equals("40") || 
//						diferencialMinMax.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						diferencialMinMax = conversionNivelAutorizacionDTSantiagoOMadrid(diferencialMinMax); // se recalcula el plazo para Red de Santiago	
//					}

					/**
					 * Si el diferencial minimo maximo está fuera de rango y la oficina tramitadora
					 * es BO se coloca el maximo nivel de autorizacion
					 */
					if(diferencialMinMax.equals(CTE_VALOR_FUERA_RANGO)) {
						diferencialMinMax = modificaAutorizacionSustitutivos(diferencialMinMax, esBO,nucExpediente,TablaAN08TB01.DIFERENCIAL_MIN_MAX);
					}
					diferencialMinMax = String.format("%1$11s", diferencialMinMax).replace(' ', '0');
					bloqueValidacion += diferencialMinMax;
				}
				else if (Constantes.CTE_STRING_COD_TRAMO_VARIABLE_DIFERENCIAL_BONIFICADO.equals(tipo))
				{
					// Caso de validación de 'Diferencial bonificado'.
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_DIFERENCIAL_BONIFICADO = "05".
					
					// Diferencial bonificado (11 caracteres).
					String diferencialBonificado = bloque.substring(38, 49);
					diferencialBonificado = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.DIFERENCIAL_BONIFICADO, 
								new BigDecimal(diferencialBonificado), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
//					if ((diferencialBonificado.equals("30") || 
//						diferencialBonificado.equals("40") || 
//						diferencialBonificado.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						diferencialBonificado = conversionNivelAutorizacionDTSantiagoOMadrid(diferencialBonificado); // se recalcula el plazo para Red de Santiago	
//					}

					/**
					 * Si el diferencial bonificado está fuera de rango y la oficina tramitadora es BO 
					 * se otorga el máximo nivel de autorizacion
					 */
					if(diferencialBonificado.equals(CTE_VALOR_FUERA_RANGO)) {
						diferencialBonificado = modificaAutorizacionSustitutivos(diferencialBonificado, esBO,nucExpediente,TablaAN08TB01.DIFERENCIAL_MIN_MAX);
					}
					diferencialBonificado = String.format("%1$11s", diferencialBonificado).replace(' ', '0');
					bloqueValidacion += diferencialBonificado;
				}
				else
				{
					// Diferencial alternativo (11 caracteres).
					String diferencialAlternativo = bloque.substring(38, 49);
					/**
					 * Si el diferencial alternativo está fuera de rango y la oficina tramitadora es BO
					 * se le otorga el máximo nivel de autorizacion
					 */
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((diferencialAlternativo.equals("30") || 
//						diferencialAlternativo.equals("40") || 
//						diferencialAlternativo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//
//					{
//						diferencialAlternativo = conversionNivelAutorizacionDTSantiagoOMadrid(diferencialAlternativo); // se recalcula el plazo para Red de Santiago	
//					}
					
					if(diferencialAlternativo.equals(CTE_VALOR_FUERA_RANGO)) {
						diferencialAlternativo = modificaAutorizacion(diferencialAlternativo, esBO,nucExpediente);
					}
					bloqueValidacion += diferencialAlternativo;
				}
				
				if (techoSueloInteres != null && techoSueloInteres.getAplicaSueloInicial() == Integer.valueOf(1))
				{
					// El suelo, techo y suelo interés inicial son los del propio sustitutivo
					// Suelo (11 caracteres).
					String suelo = bloque.substring(49, 60);
					suelo = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.SUELO, 
								new BigDecimal(suelo), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((suelo.equals("30") || 
//						suelo.equals("40") || 
//						suelo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						suelo = conversionNivelAutorizacionDTSantiagoOMadrid(suelo); // se recalcula el plazo para Red de Santiago	
//					}
					
					/**
					 * Si el suelo está fuera de rango y la oficina tramitadora es BO
					 * modificamos el nivel al máximo
					 */
					if(suelo.equals(CTE_VALOR_FUERA_RANGO)) {
						suelo = modificaAutorizacionSustitutivos(suelo, esBO,nucExpediente,TablaAN08TB01.SUELO);
					}
					suelo = String.format("%1$11s", suelo).replace(' ', '0');
					bloqueValidacion += suelo;
					
					// Techo (11 caracteres).
					String techo = bloque.substring(60, 71);
					techo = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.TECHO, 
								new BigDecimal(techo), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
					
//					if ((techo.equals("30") || 
//						techo.equals("40") || 
//						techo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						techo = conversionNivelAutorizacionDTSantiagoOMadrid(techo); // se recalcula el plazo para Red de Santiago	
//					}

					techo = String.format("%1$11s", techo).replace(' ', '0');
					/**
					 * Si el techo está fuera de rango y la oficina tramitadora es BO
					 * se cambia al maximo nivel de autorizacion
					 */
					if(techo.equals(CTE_VALOR_FUERA_RANGO)) {
						techo = modificaAutorizacionSustitutivos(techo, esBO,nucExpediente,TablaAN08TB01.TECHO);
					}
					bloqueValidacion += techo;
					
					// Suelo interés inicial (11 caracteres).
					String sueloIntInicial = bloque.substring(71, 82);
					sueloIntInicial = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.SUELO_INTERES_INICIAL, 
								new BigDecimal(sueloIntInicial), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((sueloIntInicial.equals("30") || 
//						sueloIntInicial.equals("40") || 
//						sueloIntInicial.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						sueloIntInicial = conversionNivelAutorizacionDTSantiagoOMadrid(sueloIntInicial); // se recalcula el plazo para Red de Santiago	
//					}
					
					/**
					 *Si el suelo interés inicial esta fuera de rango y la oficina tramitadora es BO
					 *se otorga el máximo nivel de autorizacion
					 */
					if(sueloIntInicial.equals(CTE_VALOR_FUERA_RANGO)) {
						sueloIntInicial = modificaAutorizacionSustitutivos(sueloIntInicial, esBO,nucExpediente,TablaAN08TB01.SUELO_INTERES_INICIAL);
					}
					sueloIntInicial = String.format("%1$11s", sueloIntInicial).replace(' ', '0');
					bloqueValidacion += sueloIntInicial;
				}
				else
				{
					// El suelo, techo y suelo interés inicial son los del interés => No se realiza la validación
					bloqueValidacion += "00000000000";
					bloqueValidacion += "00000000000";
					bloqueValidacion += "00000000000";
				}
				
				// Bloque validación.
				datoEnRango.addBloque(bloqueValidacion);				
				// Bloque original.
				datoEnRango.addBloque(bloque);				
			}
		}
		catch (StringIndexOutOfBoundsException sioobe)
		{
			LOGGER.error(sioobe);
			throw new DatoEnRangoException(sioobe.getMessage());
		}
		catch (NumberFormatException nfe)
		{
			LOGGER.error(nfe);
			throw new DatoEnRangoException(nfe.getMessage());
		}
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Fin de validación del paso 'Interés'");
		}		
	}	
	
	/**
	 * Captura el TechosSueloDiferC asociado al tramo de interés
	 * @param listTechosSueloIntereses
	 * @param orden
	 * @return El techoSuelo asociado al tramo de interés concreto
	 */
	private TechosSuelosDifeC capturarTechoSueloInteres(
			List<TechosSuelosDifeC> listTechosSueloIntereses, String orden)
	{
		TechosSuelosDifeC salida = null;
		
		for (TechosSuelosDifeC techoSuelo: listTechosSueloIntereses)
		{
			final int ordenEntrada = Integer.valueOf(orden).intValue();
			final int ordenTecho = techoSuelo.getTechosSuelosDifeKey().getOrden().intValue();
			
			if (ordenEntrada == ordenTecho)
			{
				salida = techoSuelo;
			}
		}
		return salida;
	}


	/**
	 * 
	 * @param bloquesDatosInteres
	 * @param listInteres Condiciones de interés contra las que se realiza la validación.
	 * @param listTechosSuelosDife Diferenciales de interés contra los que se realiza la validación.
	 * @param datoEnRango Resultado de la validación.
	 * @return Lista de techos y suelos asociados a cada tramo de interés
	 * @throws DatoEnRangoException
	 */
	private List<TechosSuelosDifeC> validarTramosInteres(
			List<String> bloquesDatosInteres, 
			List<CEcc> listInteres, 
			List<CEcc> listTechosSuelosDife, 
			ResultadoDatoEnRangoVO datoEnRango,
			BigDecimal esBO,
			BigDecimal nucExpediente,
			InformacionRiesgoOrigenVO datosRiesgoOrigen, 
			boolean esSubrogacionNovacion, 
			boolean sinModalidad) throws DatoEnRangoException
	{
		
			
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Inicio de validación del paso 'Interés'");
		}
		
		List<TechosSuelosDifeC> salida = new ArrayList<TechosSuelosDifeC>(Constantes.CTE_CERO);
		
		GestionDatoEnRango gdr = new GestionDatoEnRango();
		int indInteres = Constantes.CTE_IND_INTERES_INTERES;
		
		
		try
		{
			for (String bloque : bloquesDatosInteres)
			{
				String bloqueValidacion = Constantes.CTE_STRING_EMPTY;
				
				// Tipo de bloque (11 caracteres).
				String tipoBloque = bloque.substring(0, 11);
				bloqueValidacion += tipoBloque;
				
				// Orden (5 caracteres).
				String orden = bloque.substring(11, 16);
				bloqueValidacion += orden;				
				
				// Tipo (2 caracteres).
				String tipo = bloque.substring(16, 18);
				bloqueValidacion += tipo;
				
				// Prioridad (5 caracteres).
				String prioridad = bloque.substring(18, 23);
				bloqueValidacion += prioridad;				
				
				List<CEcc> filteredInteresList = 
					this.filtrarListaTipoBase(listInteres, 
							Integer.valueOf(orden), tipo, null, null, 
							esSubrogacionNovacion, sinModalidad);
							
				// Plazo (5 caracteres).
				String plazo = bloque.substring(23, 28);
								
				plazo = gdr.validarCondicionInteres(TablaAN07TB01.PLAZO, 
						Integer.valueOf(plazo), filteredInteresList, 
						Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
						esSubrogacionNovacion);				
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((plazo.equals("30") || 
//						plazo.equals("40") || 
//						plazo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					plazo = conversionNivelAutorizacionDTSantiagoOMadrid(plazo); // se recalcula el plazo para Red de Santiago	
//				}
								
				/**
				 * Si el plazo está fuera de rango y la oficina tramitadora es BO
				 * se modifica al nivel maximo de autorizacion
				 */
				if(plazo.equals(CTE_VALOR_FUERA_RANGO)) {
					plazo = modificaAutorizacionCondicionInteres(plazo, esBO,nucExpediente,TablaAN07TB01.PLAZO);
				}
				plazo = String.format("%1$5s", plazo).replace(' ', '0');
				bloqueValidacion += plazo;				
				
				// Tipo referencia (4 caracteres).
				String tipoReferencia = bloque.substring(28, 32);
				bloqueValidacion += tipoReferencia;
				
				List<CEcc> filteredTechosSuelosDifeList = 
					this.filtrarListaTipoBase(listTechosSuelosDife, 
							Integer.valueOf(orden), null, Integer.valueOf(prioridad), 
							Integer.valueOf(tipoReferencia), esSubrogacionNovacion, sinModalidad);
				
				if (filteredTechosSuelosDifeList.size() > 0)
					salida.add((TechosSuelosDifeC) filteredTechosSuelosDifeList.get(0));
				
				// Validación excluyente (Interés / Diferencial).
				if ((Constantes.CTE_STRING_COD_TRAMO_FIJO.equals(tipo)) || 
					(Constantes.CTE_STRING_COD_TRAMO_FIJO_PENALIZABLE.equals(tipo)) || 
					(Constantes.CTE_STRING_COD_TRAMO_FIJO_REFERENCIADO.equals(tipo)))
				{
					// Casos de validación de 'Interés':
					// Constantes.CTE_STRING_COD_TRAMO_FIJO = "00".
					// Constantes.CTE_STRING_COD_TRAMO_FIJO_PENALIZABLE = "01".
					// Constantes.CTE_STRING_COD_TRAMO_FIJO_REFERENCIADO = "06".
					
					// Interés (11 caracteres).
					String interes = bloque.substring(32, 43);
					interes = 
						gdr.validarCondicionInteres(
								TablaAN07TB01.INTERES, 
								new BigDecimal(interes), filteredInteresList, 
								Integer.valueOf(orden).intValue(), 
								datosRiesgoOrigen, esSubrogacionNovacion);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((interes.equals("30") || 
//						interes.equals("40") || 
//						interes.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						interes = conversionNivelAutorizacionDTSantiagoOMadrid(interes); // se recalcula el plazo para Red de Santiago	
//					}
					
					/**
					 * Si el interés esta fuera de rango y la oficina tramitadora es 
					 * BO se deja pasar y se otorga el máximo nivel de autorizacion
					 */
					if(interes.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBO)) {
						interes = modificaAutorizacionCondicionInteres(interes, esBO,nucExpediente,TablaAN07TB01.INTERES);
					}
					interes = String.format("%1$11s", interes).replace(' ', '0');
					bloqueValidacion += interes;
				}
				else
				{
					// Casos de validación de 'Diferencial':
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE = "02".
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_BONIFICADO = "03".
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_PENALIZABLE = "04".
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_DIFERENCIAL_BONIFICADO = "05".
					
					// Diferencial (11 caracteres).
					String diferencial = bloque.substring(32, 43);
					diferencial = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.DIFERENCIAL, 
								new BigDecimal(diferencial), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((diferencial.equals("30") || 
//						diferencial.equals("40") || 
//						diferencial.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						diferencial = conversionNivelAutorizacionDTSantiagoOMadrid(diferencial); // se recalcula el plazo para Red de Santiago	
//					}
									
					/**
					 * Si el diferenial está fuera de rango y la oficina tramitadora es BO
					 * se otorga el máximo nivel de autorizacion
					 */
					if(diferencial.equals(CTE_VALOR_FUERA_RANGO)) {
						diferencial = modificaAutorizacionDiferencialInteres(diferencial, esBO,nucExpediente,TablaAN08TB01.DIFERENCIAL);
					}
					diferencial = String.format("%1$11s", diferencial).replace(' ', '0');
					bloqueValidacion += diferencial;
				}
				
				// Validación excluyente (Diferencial mínimo máximo / Diferencial bonificado).
				if ((Constantes.CTE_STRING_COD_TRAMO_VARIABLE_BONIFICADO.equals(tipo)) || 
					(Constantes.CTE_STRING_COD_TRAMO_VARIABLE_PENALIZABLE.equals(tipo)))
				{
					// Casos de validación de 'Diferencial mínimo máximo'.
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_BONIFICADO = "03".
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_PENALIZABLE = "04".
					
					// Diferencial mínimo máximo (11 caracteres).
					String diferencialMinMax = bloque.substring(43, 54);
					diferencialMinMax = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.DIFERENCIAL_MIN_MAX, 
								new BigDecimal(diferencialMinMax), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((diferencialMinMax.equals("30") || 
//						diferencialMinMax.equals("40") || 
//						diferencialMinMax.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						diferencialMinMax = conversionNivelAutorizacionDTSantiagoOMadrid(diferencialMinMax); // se recalcula el plazo para Red de Santiago	
//					}
									
					/**
					 * Si el diferencial esta fuera de rango y la oficina tramitadora es BO otorgamos
					 * el máximo nivel de autorizacion 
					 */
					if(diferencialMinMax.equals(CTE_VALOR_FUERA_RANGO)) {
						diferencialMinMax = modificaAutorizacionDiferencialInteres(diferencialMinMax, esBO,nucExpediente,TablaAN08TB01.DIFERENCIAL_MIN_MAX);
					}
					diferencialMinMax = String.format("%1$11s", diferencialMinMax).replace(' ', '0');
					bloqueValidacion += diferencialMinMax;					
				}
				else if (Constantes.CTE_STRING_COD_TRAMO_VARIABLE_DIFERENCIAL_BONIFICADO.equals(tipo))
				{
					// Caso de validación de 'Diferencial bonificado'.
					// Constantes.CTE_STRING_COD_TRAMO_VARIABLE_DIFERENCIAL_BONIFICADO = "05".
					
					// Diferencial bonificado (11 caracteres).
					String diferencialBonificado = bloque.substring(43, 54);
					diferencialBonificado = 
						gdr.validarDiferencialInteres(
								TablaAN08TB01.DIFERENCIAL_BONIFICADO, 
								new BigDecimal(diferencialBonificado), filteredTechosSuelosDifeList, 
								Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
								esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((diferencialBonificado.equals("30") || 
//						diferencialBonificado.equals("40") || 
//						diferencialBonificado.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						diferencialBonificado = conversionNivelAutorizacionDTSantiagoOMadrid(diferencialBonificado); // se recalcula el plazo para Red de Santiago	
//					}
					
					/**
					 * Si el diferencialBonificado está fuera de rango y la oficina tramitadora es BO
					 * otorgamos el máximo nivel de autorización
					 */
					if(diferencialBonificado.equals(CTE_VALOR_FUERA_RANGO)) {
						diferencialBonificado = modificaAutorizacionDiferencialInteres(diferencialBonificado, esBO,nucExpediente,TablaAN08TB01.DIFERENCIAL_BONIFICADO);
					}
					diferencialBonificado = String.format("%1$11s", diferencialBonificado).replace(' ', '0');
					bloqueValidacion += diferencialBonificado;					
				}
				else
				{
					// Diferencial alternativo (11 caracteres).
					String diferencialAlternativo = bloque.substring(43, 54);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((diferencialAlternativo.equals("30") || 
//						diferencialAlternativo.equals("40") || 
//						diferencialAlternativo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						diferencialAlternativo = conversionNivelAutorizacionDTSantiagoOMadrid(diferencialAlternativo); // se recalcula el plazo para Red de Santiago	
//					}

					/**
					 * Si el diferencial alternativo está fuera de rango y la oficina tramitadora es BO
					 * se otorga el maximo nivel de autorizacion
					 */
					if(diferencialAlternativo.equals(CTE_VALOR_FUERA_RANGO)) {
						diferencialAlternativo = modificaAutorizacion(diferencialAlternativo, esBO,nucExpediente);
					}
					bloqueValidacion += diferencialAlternativo;					
				}
				
				// Validación suelo y techo (sólo se validará para tipos de interés
				// variables.
				if ((Constantes.CTE_STRING_COD_TRAMO_FIJO.equals(tipo)) || 
					(Constantes.CTE_STRING_COD_TRAMO_FIJO_PENALIZABLE.equals(tipo)) || 
					(Constantes.CTE_STRING_COD_TRAMO_FIJO_REFERENCIADO.equals(tipo)))
				{
					// Suelo (11 caracteres).
					bloqueValidacion += "00000000000";
					// Techo (11 caracteres).
					bloqueValidacion += "00000000000";
					// Suelo interés inicial (11 caracteres).
					bloqueValidacion += "00000000000";
				}
				else
				{
					// Suelo (11 caracteres).
					String suelo = bloque.substring(54, 65);
					suelo = gdr.validarDiferencialInteres(TablaAN08TB01.SUELO, 
							new BigDecimal(suelo), filteredTechosSuelosDifeList, 
							Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
							esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((suelo.equals("30") || 
//						suelo.equals("40") || 
//						suelo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						suelo = conversionNivelAutorizacionDTSantiagoOMadrid(suelo); // se recalcula el plazo para Red de Santiago	
//					}
					
					/**
					 * Si el suelo esta fuera de rango y es BO la oficina tramitadora
					 * Colocamos el maximo nivel de autorización
					 */
					if(suelo.equals(CTE_VALOR_FUERA_RANGO)) {
						suelo = modificaAutorizacionDiferencialInteres(suelo, esBO,nucExpediente,TablaAN08TB01.SUELO);
					}
					suelo = String.format("%1$11s", suelo).replace(' ', '0');
					bloqueValidacion += suelo;				
					
					// Techo (11 caracteres).
					String techo = bloque.substring(65, 76);
					techo = 
						gdr.validarDiferencialInteres(
							TablaAN08TB01.TECHO, 
							new BigDecimal(techo), filteredTechosSuelosDifeList, 
							Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
							esSubrogacionNovacion, indInteres);
					
					//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//					if ((techo.equals("30") || 
//						techo.equals("40") || 
//						techo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//					{
//						techo = conversionNivelAutorizacionDTSantiagoOMadrid(techo); // se recalcula el plazo para Red de Santiago	
//					}
					
					/**
					 * Si el techo está fuera de rango y la oficina tramitadora
					 * es BO nos devuelve el máximo nivel de autorizacion
					 */
					if(techo.equals(CTE_VALOR_FUERA_RANGO)) {
						techo = modificaAutorizacionDiferencialInteres(techo, esBO,nucExpediente,TablaAN08TB01.TECHO);
					}
					techo = String.format("%1$11s", techo).replace(' ', '0');
					bloqueValidacion += techo;
					
					/*
					 * Corregido el 01-Febrero-2012
					 * El sueloIntInicial solamente se debe validar si 
					 * sueloAplicaSobreIntInicial está marcado (1)
					 */
					// Suelo aplica sobre interés inicial (1 caracter)
					String sueloAplicaSobreIntInicial = bloque.substring(108, 109);
					// Suelo interés inicial (11 caracteres).
					String sueloIntInicial = bloque.substring(76, 87);
					if (-1 == Constantes.CTE_CERO.compareTo(Integer.parseInt(sueloAplicaSobreIntInicial)))
					{
						sueloIntInicial = 
							gdr.validarDiferencialInteres(
									TablaAN08TB01.SUELO_INTERES_INICIAL, 
									new BigDecimal(sueloIntInicial), filteredTechosSuelosDifeList, 
									Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
									esSubrogacionNovacion, indInteres);
						
						//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//						if ((sueloIntInicial.equals("30") || 
//						sueloIntInicial.equals("40") || 
//						sueloIntInicial.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//						{
//							sueloIntInicial = conversionNivelAutorizacionDTSantiagoOMadrid(sueloIntInicial); // se recalcula el plazo para Red de Santiago	
//						}
						
						/**
						 * Si el suelo interes inicial está fuera de rango y la oficina tramitadora
						 * es BO se coloca el máximo nivel de autorizacion
						 */
						if(sueloIntInicial.equals(CTE_VALOR_FUERA_RANGO)) {
							sueloIntInicial = modificaAutorizacionDiferencialInteres(sueloIntInicial, esBO,nucExpediente,TablaAN08TB01.SUELO_INTERES_INICIAL);
						}
						sueloIntInicial = String.format("%1$11s", sueloIntInicial).replace(' ', '0');
						bloqueValidacion += sueloIntInicial;
					}
					else
					{
						sueloIntInicial = String.format("%1$11s", "0").replace(' ', '0');
						bloqueValidacion += sueloIntInicial;
					}
				}
				
				// Demora sobre capital (8 caracteres).
				String demoraCapital = bloque.substring(87, 95);
				demoraCapital = 
					gdr.validarCondicionInteres(
							TablaAN07TB01.DEMORA_SOBRE_CAPITAL, 
							new BigDecimal(demoraCapital), filteredInteresList, 
							Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
							esSubrogacionNovacion);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((demoraCapital.equals("30") || 
//						demoraCapital.equals("40") || 
//						demoraCapital.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					demoraCapital = conversionNivelAutorizacionDTSantiagoOMadrid(demoraCapital); // se recalcula el plazo para Red de Santiago	
//				}
				
				/**
				 * Si la demora sobre capital está fuera de rango y es BO se coloca 
				 * el máximo nivel de autorizacion
				 */
				if(demoraCapital.equals(CTE_VALOR_FUERA_RANGO)) {
					demoraCapital = modificaAutorizacionCondicionInteres(demoraCapital, esBO,nucExpediente,TablaAN07TB01.DEMORA_SOBRE_CAPITAL);
				}
				demoraCapital = String.format("%1$8s", demoraCapital).replace(' ', '0');
				bloqueValidacion += demoraCapital;				
				
				// Demora sobre intereses (8 caracteres).
				String demoraIntereses = bloque.substring(95, 103);				
				demoraIntereses = 
					gdr.validarCondicionInteres(
							TablaAN07TB01.DEMORA_SOBRE_INTERESES, 
							new BigDecimal(demoraIntereses), filteredInteresList, 
							Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
							esSubrogacionNovacion);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((demoraIntereses.equals("30") || 
//						demoraIntereses.equals("40") || 
//						demoraIntereses.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					demoraIntereses = conversionNivelAutorizacionDTSantiagoOMadrid(demoraIntereses); // se recalcula el plazo para Red de Santiago	
//				}
				
				/**
				 * Demora de interés, si la demora de interes está fuera de rango y
				 * la oficina tramitadora es BO se coloca el máximo nivel de autorización
				 */
				if(demoraIntereses.equals(CTE_VALOR_FUERA_RANGO)) {
					demoraIntereses = modificaAutorizacionCondicionInteres(demoraIntereses, esBO,nucExpediente,TablaAN07TB01.DEMORA_SOBRE_INTERESES);
				}
				demoraIntereses = String.format("%1$8s", demoraIntereses).replace(' ', '0');
				bloqueValidacion += demoraIntereses;
				
				// Número de períodos de revisión (5 caracteres).
				String periodosRevision = bloque.substring(103, 108);
				periodosRevision = 
					gdr.validarCondicionInteres(
							TablaAN07TB01.NUM_PERIODOS_REVISION, 
							Integer.valueOf(periodosRevision), filteredInteresList,
							Integer.valueOf(orden).intValue(), datosRiesgoOrigen, 
							esSubrogacionNovacion);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((periodosRevision.equals("30") || 
//						periodosRevision.equals("40") || 
//						periodosRevision.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					periodosRevision = conversionNivelAutorizacionDTSantiagoOMadrid(periodosRevision); // se recalcula el plazo para Red de Santiago	
//				}
				
				/**
				 * Si los periodos de revision están fuera de rango y la oficina tramitadora
				 * es BO se coloca el máximo nivel de autorizacion
				 */
				if(periodosRevision.equals(CTE_VALOR_FUERA_RANGO)) {
					periodosRevision = modificaAutorizacionCondicionInteres(periodosRevision, esBO,nucExpediente,TablaAN07TB01.NUM_PERIODOS_REVISION);
				}
				periodosRevision = String.format("%1$5s", periodosRevision).replace(' ', '0');
				bloqueValidacion += periodosRevision;
				
				// Bloque validación.
				datoEnRango.addBloque(bloqueValidacion);
				// Bloque original.
				datoEnRango.addBloque(bloque);				
			}
		}
		catch (StringIndexOutOfBoundsException sioobe)
		{
			LOGGER.error(sioobe);
			throw new DatoEnRangoException(sioobe.getMessage());
		}
		catch (NumberFormatException nfe)
		{
			LOGGER.error(nfe);
			throw new DatoEnRangoException(nfe.getMessage());
		}
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Fin de validación del paso 'Interés'");
		}
		
		return salida;
	}
	
	/**
	 * 
	 * @param bloquesTratamientoAdelantos 
	 * @param listTratamientosAdelantos Tratamientos de adelantos contra los que se realiza la validación.
	 * @param datoEnRango Resultado de la validación.
	 * @throws DatoEnRangoException 
	 */
	private void validarTratamientosAdelantos(
			List<String> bloquesTratamientoAdelantos, 
			List<CEcc> listTratamientosAdelantos, 
			ResultadoDatoEnRangoVO datoEnRango,
			BigDecimal esBO,
			BigDecimal nucExpediente, 
			InformacionRiesgoOrigenVO datosRiesgoOrigen, 
			boolean esSubrogacionNovacion, 
			boolean sinModalidad) throws DatoEnRangoException
	{
		
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Inicio de validación del paso 'Sistema de amortización'");						
		}
		
		GestionDatoEnRango gdr = new GestionDatoEnRango();
		
		try
		{
			for (String bloque : bloquesTratamientoAdelantos)
			{
				String bloqueValidacion = Constantes.CTE_STRING_EMPTY;
				
				// Tipo de bloque (11 caracteres).
				String tipoBloque = bloque.substring(0, 11);
				bloqueValidacion += tipoBloque;
				
				// Orden (3 caracteres).
				String orden = bloque.substring(11, 14);
				bloqueValidacion += orden;
				
				// Tipo (2 caracteres).
				String tipo = bloque.substring(14, 16);
				bloqueValidacion += tipo;
				
				// Prioridad (3 caracteres).
				String prioridad = bloque.substring(16, 19);
				bloqueValidacion += prioridad;
				
				// Importe mínimo (16 caracteres).
				String importeMinimo = bloque.substring(19, 35);
				
				// Tipo imputación (1 caracter)
				String imputacion = bloque.substring(35, 36);
				
				List<CEcc> filteredTratamientosAdelantosList = 
					this.filtrarListaTipoBase(
							listTratamientosAdelantos, 
							null, null, Integer.valueOf(imputacion), null, 
							esSubrogacionNovacion, sinModalidad);
				

				importeMinimo = 
					gdr.validarTratamientoAdelantos(
							TablaAN13TB01.IMPORTE_MINIMO, 
							new BigDecimal(importeMinimo), filteredTratamientosAdelantosList, 
							datosRiesgoOrigen, esSubrogacionNovacion);
				
				//20160405: modificación para regular el nivel de autorización de la red de DT Santiago 
//				if ((importeMinimo.equals("30") || 
//						importeMinimo.equals("40") || 
//						importeMinimo.equals("50")) && (pertenceRedSantiagoOMadrid)) 
//				{
//					importeMinimo = conversionNivelAutorizacionDTSantiagoOMadrid(importeMinimo); // se recalcula el plazo para Red de Santiago	
//				}
				
				/**
				 * Si el importe minimo esta fuera de rango y la oficina tramitadora es BO
				 * se coloca el maximo nivel de autorizacion
				 */
				if(importeMinimo.equals(CTE_VALOR_FUERA_RANGO)) {
					importeMinimo = modificaAutorizacionTratamientoAdelantos(imputacion, esBO,nucExpediente,TablaAN13TB01.IMPORTE_MINIMO);
				}
				importeMinimo = String.format("%1$16s", importeMinimo).replace(' ', '0');
				bloqueValidacion += importeMinimo;
				
				bloqueValidacion += imputacion;
				
				// Bloque validación.
				datoEnRango.addBloque(bloqueValidacion);
				// Bloque original.
				datoEnRango.addBloque(bloque);
			}
		}
		catch (StringIndexOutOfBoundsException sioobe)
		{
			LOGGER.error(sioobe);
			throw new DatoEnRangoException(sioobe.getMessage());
		}
		catch (NumberFormatException nfe)
		{
			LOGGER.error(nfe);
			throw new DatoEnRangoException(nfe.getMessage());
		}
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Fin de validación del paso 'Sistema de amortización'");
		}
	}
	
	/**
	 * Obtiene los datos de la versión para todas las tablas especificadas.
	 * @param codProducto Código del producto
	 * @param codSubproducto Código del subproducto
	 * @param codColectivo Código del colectivo
	 * @param versionGeneral Versión general del subproducto
	 * @param tablas Lista con los nombres de tablas a consultar
	 * @return Lista de objetos CEcc con los datos de todos los niveles del producto
	 * consultados para la tabla. Devuelve los datos generales (en las tablas en que
	 * es posible encontrarlos) si no existen datos específicos para el subproducto
	 * especificado.
	 */
	private List<CEcc> obtenerDatosVersion(Integer codProducto, Integer codSubproducto, 
			Integer codColectivo, Integer versionGeneral, List<String> tablas)
	{
		List<CEcc> listaRes = new ArrayList<CEcc>(Constantes.CTE_CERO);
		
		if (tablas != null && Constantes.CTE_CERO != tablas.size())
		{
			for (String tabla : tablas)
			{
				List<String> listaTablas = new ArrayList<String>(Constantes.CTE_CERO);
				listaTablas.add(tabla);
				List<CEcc> listDatosVersion = 
					obtenerDatosVersion(codProducto, codSubproducto, codColectivo, versionGeneral, tabla, false); 
				
				// Si no devuelve resultados y es una de las tablas que se pueden referenciar
				// con datos generales, buscamos con el subproducto 0
				if ((listDatosVersion == null || Constantes.CTE_CERO == listDatosVersion.size()) &&
						(	tabla.equalsIgnoreCase(CTE_TABLA_COND_CAPITAL) ||
							tabla.equalsIgnoreCase(CTE_TABLA_COND_INTERES) ||
							tabla.equalsIgnoreCase(CTE_TABLA_DIFE_INTERES) ||
							tabla.equalsIgnoreCase(CTE_TABLA_COMISIONES) ||
							tabla.equalsIgnoreCase(CTE_TABLA_TRATAMIENTO_ADELANTOS) ||
							tabla.equalsIgnoreCase(CTE_TABLA_DATOS_ECONOMICOS)))
				{
					listDatosVersion = 
						obtenerDatosVersion(codProducto, codSubproducto, codColectivo, versionGeneral, tabla, true);
				}
				
				listaRes.addAll(listDatosVersion);
			}
		}
		
		return listaRes;
	}

	/**
	 * Obtiene los datos de la versión para una tabla seleccionada
	 * @param codProducto Código del producto
	 * @param codSubproducto Código del subproducto (o bien 0 para datos generales)
	 * @param codColectivo Código del colectivo
	 * @param versionGeneral Versión general del subproducto
	 * @param tabla Nombre de la tabla a consultar
	 * @param datosGenerales Flag para indicar si queremos buscar datos generales (true)
	 * o datos específicos del subproducto (false)
	 * @return Lista de objetos CEcc con los datos de todos los niveles del producto
	 * consultados para la tabla.
	 */
	private List<CEcc> obtenerDatosVersion(Integer codProducto, Integer codSubproducto, 
			Integer codColectivo, Integer versionGeneral, String tabla, boolean datosGenerales)
	{
		List<CEcc> listaRes = new ArrayList<CEcc>(Constantes.CTE_CERO);
		
		if (!UtilidadesTramitacion.isBlankOrNull(tabla))
		{
			// Si tenemos un subproducto específico llamamos al método obtenerDatosVersion de
			// la clase de catálogo GestionVersiones.
			if (!datosGenerales)
			{
				// Cogemos los datos de comisiones para el producto
				if (CTE_TABLA_COMISIONES.equalsIgnoreCase(tabla))
				{
					if(codColectivo.equals(new Integer(0)))					
						listaRes = this.obtenerDatosVersionComisiones(codProducto, codSubproducto, codColectivo, versionGeneral);
					else {
						final List<String> listaTablas = new ArrayList<String>(Constantes.CTE_CERO);
						listaTablas.add(tabla);
						listaRes.addAll(
							GestionVersiones.obtenerDatosVersion(codProducto, codSubproducto, codColectivo, versionGeneral, listaTablas));
					}
					
				}
				// Para cualquier otro tipo de dato
				else
				{
					final List<String> listaTablas = new ArrayList<String>(Constantes.CTE_CERO);
					listaTablas.add(tabla);
					listaRes.addAll(
							GestionVersiones.obtenerDatosVersion(codProducto, codSubproducto, codColectivo, versionGeneral, listaTablas)
					);
				}
			}
			else {
				VersionesC version = GestionVersiones.obtenerVersion(
						codProducto, codSubproducto, versionGeneral, codColectivo); 
				
				// Cogemos los datos generales de comisiones para el producto
				if (CTE_TABLA_COMISIONES.equalsIgnoreCase(tabla))
				{
					// Ya se han devuelto en el paso anterior (hay que hacerlo tipo por tipo de comisión)
				}
				// Cogemos los datos generales de condiciones de capital para el producto
				else if (CTE_TABLA_COND_CAPITAL.equalsIgnoreCase(tabla))
				{
					listaRes.addAll(GestionConCapital.obtenerRegistrosVersion(
							codProducto, Constantes.CTE_CERO, version.getAn04tb01(), false));
				}
				// Cogemos los datos generales de condiciones de interés para el producto
				else if (CTE_TABLA_COND_INTERES.equalsIgnoreCase(tabla))
				{
					listaRes.addAll(GestionInteres.obtenerRegistrosVersion(
							codProducto, Constantes.CTE_CERO, codColectivo, version.getAn07tb01(), false));
				}
				// Cogemos los datos generales de datos económicos para el producto
				else if (CTE_TABLA_DATOS_ECONOMICOS.equalsIgnoreCase(tabla))
				{
					listaRes.addAll(GestionDatEco.obtenerDatsEcoVersion(
							codProducto, Constantes.CTE_CERO, version.getAn03tb01(), codColectivo));
				}
				// Cogemos los datos generales de diferenciales de interés para el producto
				else if (CTE_TABLA_DIFE_INTERES.equalsIgnoreCase(tabla))
				{
					listaRes.addAll(GestionTechosSuelosDife.obtenerRegistrosVersion(
							codProducto, Constantes.CTE_CERO, codColectivo, version.getAn08tb01(), false));
				}
				// Cogemos los datos generales de tratamiento de adelantos para el producto
				else if (CTE_TABLA_TRATAMIENTO_ADELANTOS.equalsIgnoreCase(tabla))
				{
					listaRes.addAll(GestionAdelanto.obtenerAdelantosSubproducto(
							codProducto, Constantes.CTE_CERO, version.getAn13tb01(), false));
				}
			}
		}
		
		return listaRes;
	}

	/**
	 * Obtiene los datos de la versión para las tablas de comisiones
	 * @param codProducto Código del producto
	 * @param codSubproducto Código del subproducto (o bien 0 para datos generales)
	 * @param codColectivo Código del colectivo
	 * @param versionGeneral Versión general del subproducto
	 * @return Lista de objetos CEcc con los datos de todos los niveles del producto
	 * consultados para la comisión.
	 */	
	private List<CEcc> obtenerDatosVersionComisiones(Integer codProducto, Integer codSubproducto, 
			Integer codColectivo, Integer versionGeneral)
	{
		List<CEcc> listaRes = new ArrayList<CEcc>(Constantes.CTE_CERO);
		VersionesC version = GestionVersiones.obtenerVersion(
					codProducto, codSubproducto, versionGeneral, codColectivo);
				
		List<ComisionesC> listaCom = new ArrayList<ComisionesC>(Constantes.CTE_CERO);

		Integer[] tiposComision = GestionComisiones.getTiposComisionInteger();
		for(int i=0; i<tiposComision.length; i++) {
			Integer tipoComis = tiposComision[i];
			
			// Comisiones de apertura				
			listaCom = GestionComisiones.obtenerTipoComisionTodosNiveles(+
					codProducto, codSubproducto, version.getAn06(tipoComis), 
					tipoComis, codColectivo);
			if (listaCom == null || Constantes.CTE_CERO == listaCom.size())
			{
				listaCom = GestionComisiones.obtenerTipoComisionTodosNiveles(+
					codProducto, Constantes.CTE_CERO, version.getAn06(tipoComis), 
					tipoComis, codColectivo);
			}
			listaRes.addAll(listaCom);
		}		
		
		return listaRes;
	}
	
	/**
	 * 
	 * @param nivelAutorizacion
	 * @param esBackOffice
	 * @return
	 */
	public String modificaAutorizacion(String nivelAutorizacion,BigDecimal esBackOffice,BigDecimal nucExpediente) {
		
		if(nivelAutorizacion.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBackOffice) &&(esBackOffice.toString()).equals(CTE_COMPROBACION_ES_BO)) {
			nivelAutorizacion = NIVEL_MAXIMO_AUTORIZACION;
		}
		
		return nivelAutorizacion;
		
	}
	
	/**
	 * 
	 * @param nivelAutorizacion
	 * @param esBackOffice
	 * @param nucExpediente
	 * @param campoValidar
	 * @return
	 */
	public String modificaAutorizacionGastosComisiones(String nivelAutorizacion,BigDecimal esBackOffice,BigDecimal nucExpediente,final TablaAN06TB01 campoValidar) {
		
		if(nivelAutorizacion.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBackOffice) &&  (esBackOffice.toString()).equals(CTE_COMPROBACION_ES_BO)) {
			nivelAutorizacion = NIVEL_MAXIMO_AUTORIZACION;
		}else if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
			GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
			//Llamar a la funcion de comprobacion de Gastos Comisiones
			nivelAutorizacion = gvbo.modificaAutorizacionGastosComisionesNoBackOffice(nivelAutorizacion, nucExpediente, campoValidar,NIVEL_MAXIMO_AUTORIZACION);
		}
		
		return nivelAutorizacion;
	}
	
	/**
	 * 
	 * @param nivelAutorizacion
	 * @param esBackOffice
	 * @param nucExpediente
	 * @param campoValidar
	 * @return
	 */
	public String modificaAutorizacionSistemasAmortizacion(String nivelAutorizacion,BigDecimal esBackOffice,BigDecimal nucExpediente,final TablaAN04TB01 campoValidar) {
		
		if(nivelAutorizacion.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBackOffice) && (esBackOffice.toString()).equals(CTE_COMPROBACION_ES_BO)) {
			nivelAutorizacion = NIVEL_MAXIMO_AUTORIZACION;
		}else if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
			//Llamar a la funcion de comprobacion de Sistemas de amortizacion
			GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
			nivelAutorizacion = gvbo.modificaAutorizacionSistemasAmortizacionNoBackOffice(nivelAutorizacion, nucExpediente, campoValidar,NIVEL_MAXIMO_AUTORIZACION);
		}
		
		return nivelAutorizacion;
	}
	
	/**
	 * 
	 * @param nivelAutorizacion
	 * @param esBackOffice
	 * @param nucExpediente
	 * @param campoValidar
	 * @return
	 */
	public String modificaAutorizacionSustitutivos(String nivelAutorizacion,BigDecimal esBackOffice,BigDecimal nucExpediente,final TablaAN08TB01 campoValidar) {
		
		if(nivelAutorizacion.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBackOffice) && (esBackOffice.toString()).equals(CTE_COMPROBACION_ES_BO)) {
			nivelAutorizacion = NIVEL_MAXIMO_AUTORIZACION;
		}else if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
			//Llamar a la funcion de comprobacion de amortizacion sustitutivos
			GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
			nivelAutorizacion = gvbo.modificaAutorizacionSustitutivosNoBackOffice(nivelAutorizacion, nucExpediente, campoValidar,NIVEL_MAXIMO_AUTORIZACION);
		}
		
		return nivelAutorizacion;
	}
	
	/**
	 * 
	 * @param nivelAutorizacion
	 * @param esBackOffice
	 * @param nucExpediente
	 * @param campoValidar
	 * @return
	 */
	public String modificaAutorizacionCondicionInteres(String nivelAutorizacion,BigDecimal esBackOffice,BigDecimal nucExpediente,final TablaAN07TB01 campoValidar) {
		
		if(nivelAutorizacion.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBackOffice) && (esBackOffice.toString()).equals(CTE_COMPROBACION_ES_BO)) {
			nivelAutorizacion = NIVEL_MAXIMO_AUTORIZACION;
		}else if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
			//Llamar a la funcion de comprobacion de condiciones interes
			GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
			nivelAutorizacion = gvbo.modificaAutorizacionCondicionInteresNoBackOffice(nivelAutorizacion, nucExpediente, campoValidar,NIVEL_MAXIMO_AUTORIZACION);
		}
		
		return nivelAutorizacion;
	}
	
	/**
	 * 
	 * @param nivelAutorizacion
	 * @param esBackOffice
	 * @param nucExpediente
	 * @param campoValidar
	 * @return
	 */
	public String modificaAutorizacionDiferencialInteres(String nivelAutorizacion,BigDecimal esBackOffice,BigDecimal nucExpediente,final TablaAN08TB01 campoValidar) {
		
		if(nivelAutorizacion.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBackOffice) && (esBackOffice.toString()).equals(CTE_COMPROBACION_ES_BO)) {
			nivelAutorizacion = NIVEL_MAXIMO_AUTORIZACION;
		}else if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
			//Llamada a la funcion de comprobacion de diferencial de interes
			GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
			nivelAutorizacion = gvbo.modificaAutorizacionDiferencialInteresNoBackOffice(nivelAutorizacion, nucExpediente, campoValidar,NIVEL_MAXIMO_AUTORIZACION);
		}
		
		return nivelAutorizacion;
	}
	
	/**
	 * 
	 * @param nivelAutorizacion
	 * @param esBackOffice
	 * @param nucExpediente
	 * @param campoValidar
	 * @return
	 */
	public String modificaAutorizacionTratamientoAdelantos(String nivelAutorizacion,BigDecimal esBackOffice,BigDecimal nucExpediente,final TablaAN13TB01 campoValidar) {
		
		if(nivelAutorizacion.equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBackOffice) && (esBackOffice.toString()).equals(CTE_COMPROBACION_ES_BO)) {
			nivelAutorizacion = NIVEL_MAXIMO_AUTORIZACION;
		}else if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
			//Llamada a la funcion de comprobacion de tratamiento de adelantos
			GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
			nivelAutorizacion = gvbo.modificaAutorizacionTratamientoAdelantosNoBackOffice(nivelAutorizacion, nucExpediente, campoValidar,NIVEL_MAXIMO_AUTORIZACION);
		}
		
		return nivelAutorizacion;
	}
	
	/**
	 * 
	 * @param datoEnRango
	 * @param esBO
	 */
	private void modificaAutorizacionCondicionesEconomicas(ResultadoDatoEnRangoVO datoEnRango,BigDecimal esBO,BigDecimal nucExpediente) {
		
		//if((!UtilidadesTramitacion.isBlankOrNull(esBO))&&(esBO.toString()).equals(CTE_COMPROBACION_ES_BO)) {
				/**
				* Si el importe solicitado devuelve un -1 es decir esta fuera de rango,
				* y la oficina tramitadora es BO se modifica por el maximo nivel de autorizacion
				*/
				if(datoEnRango.getImporteSolicitado().equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBO) && (esBO.toString()).equals(CTE_COMPROBACION_ES_BO)) {
					datoEnRango.setImporteSolicitado(NIVEL_MAXIMO_AUTORIZACION);
				}else if((datoEnRango.getImporteSolicitado().equals(CTE_VALOR_FUERA_RANGO)) && !UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
						//Invocamos al metodo de modificacion de autorizacion
						GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
						datoEnRango = gvbo.modificaAutorizacionCondicionesEconomicasNoBackOffice(nucExpediente, datoEnRango,NIVEL_MAXIMO_AUTORIZACION);
				}
		
				/**
				 * Si el dato en rango devuelve un -1 para el campo indicado y la oficina tramitadora es BO 
				 */
				if(datoEnRango.getPlazoTotal().equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBO) && (esBO.toString()).equals(CTE_COMPROBACION_ES_BO)) {
					datoEnRango.setPlazoTotal(NIVEL_MAXIMO_AUTORIZACION);
				}else if((datoEnRango.getPlazoTotal().equals(CTE_VALOR_FUERA_RANGO)) && !UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
						//Invocamos al metodo de modificacion de autorizacion	
						GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
						datoEnRango = gvbo.modificaAutorizacionCondicionesEconomicasNoBackOffice(nucExpediente, datoEnRango,NIVEL_MAXIMO_AUTORIZACION);
				}
		
				/**
				 * Si el dato en rango devuelve un -1 para el campo indicado y la oficina tramitadora es
				 * BO se pone el maximo nivel de autorizacion
				 */
				if(datoEnRango.getPlazoCarencia().equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBO) && (esBO.toString()).equals(CTE_COMPROBACION_ES_BO)) {
					datoEnRango.setPlazoCarencia(NIVEL_MAXIMO_AUTORIZACION);
				}else if((datoEnRango.getPlazoCarencia().equals(CTE_VALOR_FUERA_RANGO)) && !UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
						//Invocamos al metodo de modificacion de autorizacion	
						GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
						datoEnRango = gvbo.modificaAutorizacionCondicionesEconomicasNoBackOffice(nucExpediente, datoEnRango,NIVEL_MAXIMO_AUTORIZACION);
				
				}
		
				/**
				 * Si el plazo de difirimiento devuelve un valor fuera de rango y la oficina es BO
				 */
				if(datoEnRango.getPlazoDiferimiento().equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBO) && (esBO.toString()).equals(CTE_COMPROBACION_ES_BO)) {
					datoEnRango.setPlazoDiferimiento(NIVEL_MAXIMO_AUTORIZACION);
				}else if((datoEnRango.getPlazoDiferimiento().equals(CTE_VALOR_FUERA_RANGO)) && !UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
						//Invocamos al metodo de modificacion de autorizacion	
						GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
						datoEnRango = gvbo.modificaAutorizacionCondicionesEconomicasNoBackOffice(nucExpediente, datoEnRango,NIVEL_MAXIMO_AUTORIZACION);
				
				}
		
				/**
				 * Si el plazo de desembolso esta fuera de rango y la oficina tramitadora es BO
				 */
				if(datoEnRango.getPlazoDesembolso().equals(CTE_VALOR_FUERA_RANGO) && !UtilidadesTramitacion.isBlankOrNull(esBO) && (esBO.toString()).equals(CTE_COMPROBACION_ES_BO)) {
					datoEnRango.setPlazoDesembolso(NIVEL_MAXIMO_AUTORIZACION);
				}else if((datoEnRango.getPlazoDesembolso().equals(CTE_VALOR_FUERA_RANGO)) && !UtilidadesTramitacion.isBlankOrNull(nucExpediente)) {
						//Invocamos al metodo de modificacion de autorizacion	
						GestionVersionBackOffice gvbo = new GestionVersionBackOffice();
						datoEnRango = gvbo.modificaAutorizacionCondicionesEconomicasNoBackOffice(nucExpediente, datoEnRango,NIVEL_MAXIMO_AUTORIZACION);
					
				}

		//}
	}
	
	/**
	 * 
	 * Este método rebaja el nivel de autorización necesario para la red de Santiago
	 * 
	 * @param nivel
	 * @return nivel "rebajado"
	 * 
	 * 20161226: se comenta porque ahora se van a meter nuevas tarifas para toda España. Puede que en un futuro
	 * se vuelva sólo a implantar para Santiago y Madrid. 
	 * 
	 * */
	
//	private String conversionNivelAutorizacionDTSantiagoOMadrid(String nivel)
//	{
//		
//		if ((nivel.equals(Constantes.CTE_NIVEL_DIVISION.toString()) || (nivel.equals(Constantes.CTE_NIVEL_DIR_GENERAL.toString()))))
//		{
//			nivel = Constantes.CTE_NIVEL_TERRITORIAL.toString();
//		}
//		else if (nivel.equals(Constantes.CTE_NIVEL_TERRITORIAL.toString()))
//		{
//			nivel = Constantes.CTE_NIVEL_ZONA.toString();
//		}
//		
//		return nivel;
//	}
	
	
	/**
	 * Metodo que llama al servicio CGAL_307 (Consulta de centros). Si el centro a consutar pertenece a la red
	 * de DT Santiago, es decir, (campo CG057C051  (Codigo Comarca ) = 04), devuelve true.
	 * 
	 * @param nuc
	 * @return boolean (true = es oficina de la red de Santiago)
	 * 
	 * 
	 * 20161226: se comenta porque ahora se van a meter nuevas tarifas para toda España. Puede que en un futuro
	 * se vuelva sólo a implantar para Santiago y Madrid. 
	 * */
	
//	private boolean esCentroSantiagoOMadrid(BigDecimal nuc)
//	{
//		boolean perteneceDTSantiago = false;
//		boolean pertenecePilotoMadrid = false;
//		boolean resultado = false;
//		String centro = "";
//			
//		 if (!UtilidadesTramitacion.isBlankOrNull(nuc)) // en caso de que el nuc venga informado
//		 {
//			final GestionDatosSolicitud gds = new GestionDatosSolicitud();
//			// se recupera la última versión (no puede ser la completa porque fallaría en altas)
//			final DatosSolicitudC datosSolicitud = gds.getUltimaVersionIncompleta(nuc);
//		
//			if (null != datosSolicitud)
//			{
//				centro = datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud().toString();
//			}
//			else
//			{
//				ServicioNegocio.rollback(
//						Constantes.CTE_VERSION_INCOMPLETA_NO_RECUPERADA,
//						null,
//						null, 
//						null
//						);
//			}
//
//		 // invocación a CGAL_307 para saber si el centro es de la red de DTSantiago
//		 
//			final IDatosEntradaTx datosEntradaConsultaCentro = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(),
//					Constantes.CTE_APLIC_CGAL, Constantes.CTE_CO_DATOS_CENTRO);
//
//			datosEntradaConsultaCentro.addCampo(Constantes.CTE_CAMPO_CENTRO, centro.toString());
//
//			IContexto[] contextosCentro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaCentro);
//
//			for (IContexto recupCodComarca : contextosCentro)
//			{
//				if (recupCodComarca.getString(Constantes.CTE_CAMPO_CGAL).equals(Constantes.CTE_CODIGO_COMARCA))
//				{
//					perteneceDTSantiago = true;
//				}
//				if (recupCodComarca.getString(Constantes.CTE_CAMPO_ZONA).equals(Constantes.CTE_CODIGO_ZONA_MADRID))
//				{
//					pertenecePilotoMadrid = true;
//				}
//			}
//		 }
//
//		 if ((perteneceDTSantiago) || (pertenecePilotoMadrid))	// si es una de las dos comunidades devolvemos true.
//		 {
//			 resultado = true;
//		 }
//	
//		 return resultado;	
//	}
}
