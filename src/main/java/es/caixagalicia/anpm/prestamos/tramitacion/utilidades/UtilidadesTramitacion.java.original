/**
 * Aplicacion de Activo
 * Caixa Galicia © 2009-2010
 * 
 */
package es.caixagalicia.anpm.prestamos.tramitacion.utilidades;

import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.sql.Timestamp;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang.StringUtils;

import es.caixagalicia.anpm.prestamos.autorizaciones.persistencia.DatosAutorizacionC;
import es.caixagalicia.anpm.prestamos.autorizaciones.persistencia.DatosAutorizacionEng;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.parametro.ParametroC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.version.VersionEng;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.version.VersionesC;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Utilidades;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.enotario.utilidades.UtilidadesEnotario;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.comisiones.ComisionC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.desembolso.DesembolsoC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.gastosadic.GastosAdicionalesC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.gastosadic.GastosAdicionalesEng;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionesInteresC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionGastosFinanciados;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionRiesgoOrigen;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.CondicionesInteresAltaSrv;
import es.caixagalicia.ifrt.contextos.ContextoFactory;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.IFRTRollbackException;
import es.caixagalicia.ifrt.core.IRegistro;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.fechas.DateHelper;
import es.caixagalicia.ifrt.log.LogHelper;
import es.caixagalicia.ifrt.mail.Mail;
import es.caixagalicia.ifrt.mail.sender.IMailSender;
import es.caixagalicia.ifrt.mail.sender.MailSenderFactory;
import es.caixagalicia.ifrt.mainframe.ctgfacade.CtgFacade;
import es.caixagalicia.ifrt.parametros.Configuracion;
import es.caixagalicia.ifrt.util.Helper;

/**
 * 
 * @author F001329
 *
 */
public final class UtilidadesTramitacion
{
    // Cambiar el estado de las tareas
    private static final String CTE_EEXPR114     = "EEXPR114";
    private static final String E_CTX_EE114CON   = "EE114CON";
	private static final String E_R114_OPERACION = "EE114C010";
	private static final String EXP_OPE_MODIFICAR = "M";
    private static final String E_R114_NUC       = "EE114C020";
    private static final String E_R114_PROCESO   = "EE114C030";
    private static final String E_R114_ESTADO    = "EE114C040";
    private static final String E_R114_TIMESTAMP = "EE114C050";
    private static final String E_R114_TERMINAL  = "EE114C060";
	//private static final String TERMINAL 		= "I000";
    private static final String E_R114_USUARIO   = "EE114C070";
    private static final String E_R114_COD_ERROR = "EE114C080";
    //private static final String E_R114_TEX_ERROR = "EE114C090";
    
    private static CtgFacade ctgFacade = new CtgFacade();
    
	private final static LogHelper LOGGER = LogHelper.getLog(UtilidadesTramitacion.class);
	
	//	Cuenta contable de la aplicacion .
	private static final Integer ID_CUENTA_ANPM = Integer.valueOf(507);
	//Codigo operacion del servicio de consulta del tipo de expediente: ANPM_179	
	private static final Integer ID_COOP_CONSULTA_TIPO_EXPEDIENTE = Integer.valueOf(179);
	//Campo Tipo expediente
	private static final String NOMBRE_CAMPO_TIPO_EXPEDIENTE = "TIPO_EXPEDIENTE"; // OBLIGATORIO
	//Contexto Tipo expediente
	private static final String CONTEXTO_CONS_TIPO_EXP = "ANPMN079";
	
	private static final String CONTEXTO_CONS_TIPO_EXP_CODIGO = "ANPMN079010";
	
	//private static final Integer CTE_CC_CONSULTA_FCLI = Integer.parseInt("555");
	//private static final Integer CTE_CO_CONSULTA_FCLI_NUC = Integer.parseInt("722");
	public static final String CTE_NUC_SOLICITUD = "NUC";
	//private static final String CTE_TIPO_PERSONA_NR_FCLI722= "FC722C0060";//char
	public static final String CTE_NIF_EXPEDIENTE = "FC722C0050";  // char
	public static final String CTE_RELACION_NUC = "FC722C0020";
	public static final String CTE_SECUENCIA_RELACION_NUC = "FC722C0030";
	
	public static final String CTE_RELACION_TITULAR = "01";
	public static final String CTE_SECUENCIA_PRIMER_TITULAR = "001";
	public static final String CTE_TIPO_PERSONA_FISICA_1 = "1";
	public static final String CTE_TIPO_PERSONA_JURIDICA_0 = "0";
	public static final BigDecimal CTE_BID_DESTINO_5021 = new BigDecimal(5021);
	
	/*CONSTANTES CONTEXTO SUBPRODUCTO*/
	private static final String CTE_CTX_PRODUCTO = "ANPMN001";
	private static final String CTE_CTX_PRODUCTO_CALCULO_FIN_MES = "ANPMN001350";
	private static final String CTE_CTX_PRODUCTO_DIA_SALTO = "ANPMN001360";
	private static final String CTE_CTX_PRODUCTO_FRMA_PGO_CRRTJE = "ANPMN001370";
	
	private static final String CTE_CTX_SUBPRODUCTO = "ANPMN002";
	private static final String CTE_CTX_SUBPRODUCTO_CADUCIDAD_PRECIO = "ANPMN002680";
	private static final String CTE_CTX_SUBPRODUCTO_IND_FORMA_CALCULO_DEMORAS = "ANPMN002710";
	private static final String CTE_CTX_SUBPRODUCTO_IND_COBRO_RECIBO_OTRA_ENTIDAD = "ANPMN002720";
	
	
	// Constantes llamada ANPMR208
	private static final String CTE_CTX_PROGRAMA_ANPMR208 = "ANPMR208";
	
	private static final String CTE_CTX_BONIF = "ANPMN439";
	private static final String CTE_CTX_BONIF_PRODUCTO = "ANPMN439010";
	private static final String CTE_CTX_BONIF_SUBPRODUCTO = "ANPMN439020";
	private static final String CTE_CTX_BONIF_ID_TARIFA = "ANPMN439040";
	private static final String CTE_CTX_BONIF_VERSION_GENERAL = "ANPMN439050";
	private static final String CTE_CTX_BONIF_NUC_EXPEDIENTE = "ANPMN439060";
	private static final String CTE_CTX_BONIF_PERIODICIDAD_INTERES = "ANPMN439070";	
	private static final String CTE_CTX_BONIF_BONIFICACION_MAXIMA = "ANPMN439110";
	private static final String CTE_CTX_BONIF_CODIGO_RETORNO = "ANPMN439120";
	private static final String CTE_CTX_BONIF_CODIGO_ERROR = "ANPMN439130";
	private static final String CTE_CTX_BONIF_DESCRIPCION_ERROR = "ANPMN439140"; 
	
	private static final String CTE_CTX_BONIF_MATRIZ_BONIFICACIONES_PRODUCTO = "ANPMN439100";
	private static final Integer CTE_CTX_BONIF_LONG_MATRIZ_BONIFICACIONES_PRODUCTO = Integer.valueOf(300);
	
	private static final String CTE_CMPO_CTX_TIPO_PRESCRIPTOR = "EE273C0070";
	

	/**
	 * Metodo que comprueba que una cadena no sea una sucesion de espacios en blanco.
	 * @param str cadena de entrada
	 * @return <code>boolean</code>
	 */
	public static boolean isEmptyOrNullString(final String str)
	{
		boolean ret = false;		
		
		if (str == null)
		{
			ret = true;
		}
		else
		{
			boolean success = true;
			
			char[] chars = str.toCharArray();			
			final int length = chars.length;
			
			for (int cont = 0; cont < length; cont++)
			{
				if (chars[cont] != ' ')
				{
					success = false;
					break;
				}
			}
			
			ret = success;
		}
		
		return ret;
	}
	
	/**
	 * Devuelve el importe de la comision calculandolo dependiendo del indicador de capitalizacion
	 * si el indicador de capitalizacion es 1- Se coge el campo importe solicitado si e 0 - Se coge el importe total
	 * 
	 * @param contextoDatosSolicitud
	 * @param contextoComisiones
	 * @return BigDecimal --> Importe de la comision.
	 */
	public static BigDecimal importeComision(IContexto contextoDatosSolicitud,IContexto contextoComisiones) {

		//Campos obtenidos del contexto de comisiones
		final String strIndicadorCapitalizacion = "ANPMN053230";
		final String strComPorcentajeComision = "ANPMN053070";
		//Campos obtenidos del contexto de datos solicitud
		final String strSolImporteTotal = "ANPMN050630";
		final String strSolSolicitado = "ANPMN050580";
		
		BigDecimal importePartidaCalculoComision = BigDecimal.ZERO;
		BigDecimal importeComision = BigDecimal.ZERO;
		BigDecimal indicadorCapitalizacion = contextoComisiones.getBigDecimal(strIndicadorCapitalizacion);
		BigDecimal porcentajeComision = contextoComisiones.getBigDecimal(strComPorcentajeComision);

		//Si se capitaliza la comision de apertura
		if(0 == indicadorCapitalizacion.compareTo(BigDecimal.ONE)) {
			//Si el indicador de comision de apertura es uno entonces se coge el importe solicitado
			importePartidaCalculoComision = contextoDatosSolicitud.getBigDecimal(strSolSolicitado);
		}else {
			//Sino se coge el importe total 
			importePartidaCalculoComision = contextoDatosSolicitud.getBigDecimal(strSolImporteTotal);
		}

		importeComision = getImporteComision(importePartidaCalculoComision, porcentajeComision);

		return importeComision;
	}
	
	/**
	 * Rellena con ceros la parte entera y la parte decimal
	 * @param pOriginal
	 * @param tamañoEntero
	 * @param tamañoDecimal
	 * @return
	 */
	public static String rellenarCerosBigDecimal(String pOriginal, int tamanoEntero, int tamanoDecimal)
	{
		final int posicionPunto = pOriginal.indexOf(".");
		String parteEntera = "";
		String parteDecimal = "";
		String salida = "";
		if (posicionPunto == -1)
		{
			String sFinalEntero = rellenarCerosDelante(pOriginal, tamanoEntero);
			String sFinalDecimal = rellenarCerosDetras(parteDecimal, tamanoDecimal);
			
			salida = String.format("%s.%s", sFinalEntero, sFinalDecimal);
		}
		else
		{
			parteEntera = pOriginal.substring(0, posicionPunto);
			parteDecimal = pOriginal.substring(posicionPunto + 1);
			
			String sFinalEntero = rellenarCerosDelante(parteEntera, tamanoEntero);
			String sFinalDecimal = rellenarCerosDetras(parteDecimal, tamanoDecimal);
			
			salida = String.format("%s.%s", sFinalEntero, sFinalDecimal);
		}
		return salida;
	}	
	
	/**
	 * @param pOriginal
	 * @param pTam
	 * @return
	 */
	public static String rellenarCerosDelante(String pOriginal, int pTam)
	{
		int i = 0;
		
		String sFinal = "";
		
		
		for (i = pOriginal.length(); i < pTam; i++)
		{
			sFinal = "0" + sFinal;
		}
		
		sFinal = sFinal + pOriginal;
		
		return sFinal;
	}	
	
	/**
	 * @param pOriginal
	 * @param pTam
	 * @return
	 */
	public static String rellenarCerosDetras(String pOriginal, int pTam)
	{
		int i = 0;
		
		String sFinal = "";
		
		
		for (i = pOriginal.length(); i < pTam; i++)
		{
			sFinal = sFinal + "0";
		}
		
		pOriginal +=  sFinal;
		
		return pOriginal;
	}
	
	/**
	 * Busca un contexto determinado dentro de una lista de contextos
	 * resultantes de la invocacion de una transacción.
	 * @param lCtx, lista de contextos de salida.
	 * @param nombreCtx, nombre del contexto buscado.
	 * @return IContexto, contexto buscado si existe; null en caso contrario.
	 */
	public static final IContexto getContexto(IContexto[] lCtx, String nombreCtx)
	{
		IContexto resultado = null;
		
		for (IContexto ctx : lCtx) 
		{
			if (ctx.getNombre().equalsIgnoreCase(nombreCtx))
			{
				resultado = ctx;
				break;
			}
		}
		
		return resultado;
	}
	
	/**
	 * Devuelve un array de contextos con el nombre recibido como parámetro, 
	 *  sacados del array de contextos recibido como parámetro.
	 * @param arrayContextos
	 * @param nombreCtx
	 * @return arrayContextosBuscados
	 */
	public static final IContexto[] getContextos(IContexto[] arrayContextos, String nombreCtx)
	{
		IContexto[] arrayContextosBuscados = null;
		List<IContexto> listaContextosBuscados = new ArrayList<IContexto>(IConstantesTramitacion.CTE_TAM_INICIAL_ARRAYS);
		
		for (IContexto ctx : arrayContextos)
		{
			if (nombreCtx.equals(ctx.getNombre()))
			{
				listaContextosBuscados.add(ctx);
			}
		}
		arrayContextosBuscados = listaContextosBuscados.toArray(new IContexto[listaContextosBuscados.size()]);
		
		return arrayContextosBuscados;
	}
	
	
	/**
	 * Devuelve una lista de contextos con el nombre recibido como parámetro, 
	 *  sacados de la lista de contextos recibida como parámetro.
	 * @param arrayContextos
	 * @param nombreCtx
	 * @return arrayContextosBuscados
	 */
	public static final List<IContexto> getContextos(List<IContexto> listaContextos, String nombreCtx)
	{
		List<IContexto> listaContextosBuscados = new ArrayList<IContexto>();

		for (IContexto ctx : listaContextos)
		{
			if (nombreCtx.equals(ctx.getNombre()))
			{
				listaContextosBuscados.add(ctx);
			}
		}
		
		return listaContextosBuscados;
	}
	
	
	/**
	 * 
	 * @param flotante Valor a formatear
	 * @param parteEntera Número de dígitos enteros que tendrá el valor formateado
	 * @param parteDecimal Número de dígitos decimales que tendrá el valor formateado
	 * @param bConPorcentajeFinal Si true se añade el símbolo porcentaje al final
	 * @return Flotante formateado con parte entera 
	 */
	public static String bigDecimalToString(BigDecimal flotante, int iParteEntera, int iParteDecimal, boolean bConPorcentajeFinal)
	{
		final NumberFormat formatter = NumberFormat.getInstance(Locale.getDefault());
		formatter.setMinimumFractionDigits(iParteDecimal);
		formatter.setMaximumIntegerDigits(iParteEntera);
		String result = formatter.format(flotante);
		if (bConPorcentajeFinal)
		{
			result += Constantes.SIGNO_PORCENTAJE;
		}
		return result;
	}
	
	/** Convierte un valor String en un BigDecimal
	 * @param formattedString Cadena a formatear
	 * @param locale Configuracion regional
	 * */
	public static BigDecimal stringToBigDecimal(final String formattedString,
                                                 final Locale locale)
    {
        final DecimalFormatSymbols symbols;
        final char                 groupSeparatorChar;
        final String               groupSeparator;
        final char                 decimalSeparatorChar;
        final String               decimalSeparator;
        String                     fixedString;
        final BigDecimal           number;

        symbols              = new DecimalFormatSymbols(locale);
        groupSeparatorChar   = symbols.getGroupingSeparator();
        decimalSeparatorChar = symbols.getDecimalSeparator();

        if(groupSeparatorChar == '.')
        {
            groupSeparator = "\\" + groupSeparatorChar;
        }
        else
        {
            groupSeparator = Character.toString(groupSeparatorChar);
        }

        if(decimalSeparatorChar == '.')
        {
            decimalSeparator = "\\" + decimalSeparatorChar;
        }
        else
        {
            decimalSeparator = Character.toString(decimalSeparatorChar);
        }

        //Eliminamos los caracteres no numericos
        fixedString = formattedString.replaceAll("[^\\d.,]", "");
        fixedString = fixedString.trim().replaceAll(groupSeparator , "");
        fixedString = fixedString.replaceAll(decimalSeparator , ".");
        number      = new BigDecimal(fixedString);

        return (number);
    }
	
	public static final String CTE_DATELOWEST = "0001-01-01 00:00:00";
	private static final String NOMBRE_CLASE = UtilidadesTramitacion.class.getSimpleName();
	
	/**
	 * Si el dato es nulo devuelve la cadena vacía.
	 * @param dato
	 * @return
	 */
	public static String comprobarDatoNull(String dato)
	{
		String resultado = StringUtils.EMPTY;
		if (null != dato)
		{
			resultado = dato.trim();
		}
		return resultado;
	}
	/**
	 * Si el dato es nulo devuelve la cadena por defecto.
	 * @param dato
	 * @return
	 */
	public static String comprobarDatoNull(String dato, String strPorDefecto)
	{
		String resultado = StringUtils.EMPTY;
		if (null != dato)
		{
			resultado = dato.trim();
		}
		else
		{
			resultado = strPorDefecto;
		}
		return resultado;
	}
	
	/**
	 * Si el dato es nulo devuelve un 0.
	 * @param dato
	 * @return
	 */
	public static BigDecimal comprobarDatoNull(BigDecimal dato)
	{
		BigDecimal resultado = BigDecimal.ZERO;
		if (null != dato)
		{
			resultado = dato;
		}
		return resultado;
	}
	
	/**
	 * Si el dato es nulo devuelve un 0.
	 * @param dato
	 * @return
	 */
	public static Integer comprobarDatoNull(Integer dato)
	{
		Integer resultado = new Integer(0);
		if (null != dato)
		{
			resultado = dato;
		}
		return resultado;
	}
	
	public static BigDecimal calcularContravalor(String divisaOrigen, BigDecimal importeOrigen, String divisaDestino)
	{
		BigDecimal contravalor = null;
		ContravalorTO contravalorTO = null;
		AbstractItal ital = AbstractItal.fromEntidad(ServicioNegocio.getContexto().getEntidad());
		
		if ((StringUtils.isBlank(divisaOrigen)) ||
			(StringUtils.isBlank(divisaDestino)))
		{
			contravalor = null;
		}
		else if (divisaOrigen.equals(divisaDestino))
		{
			contravalor = importeOrigen;
		}
		else
		{
			contravalorTO = new ContravalorTO();
			contravalorTO = ital.calculaContravalor(
				divisaOrigen,
				importeOrigen,
				divisaDestino,
				IConstantesSolicitud.CTE_TIPO_CAMBIO_FIXING);
			contravalor = contravalorTO.getImporteVenta();
		}
		
		return contravalor;
	}
	
	/**
	 * Método que comprueba que el valor de un determinado parámetro no sea nulo
	 * 
	 * @param obParametro El parámetro que deseamos comprobar que no sea nulo
	 * @param strNombreParametroIn El nombre del parámetro que deseamos comprobar si
	 * es o no nulo
	 */
	private static void comprobarParametroNulo(
			Object obParametro, 
			String strNombreParametroIn)				
	{
		comprobarParametroNulo(obParametro, strNombreParametroIn, null);
	}

	
	/**
	 * Metodo que obtiene un objeto que permite escribir mensajes 
	 * en el LOG de la plataforma
	 * 
	 * @param nombreClase Nombre de la clase desde la que se van a escribir
	 * los mensajes
	 * 
	 * @return Un objeto que permitira escribir mensajes en el LOG de la 
	 * plataforma
	 */
	public static LogHelper getLoggerANPM(String nombreClase)
	{
		LogHelper LOGERANPM = null;
		String clase = "Utilidades";
		
		if (StringUtils.isNotBlank(nombreClase))
		{
			clase = nombreClase.trim();
		}
		
		LOGERANPM = LogHelper.getLog(clase + ".class");
		
		return LOGERANPM;
	}
	
	/**
	 * Método que comprueba que el parámetro utilizado como argumento en la 
	 * invocación al método no sea nulo. Si es nulo se lanza una excepción y 
	 * se hace rollback del servicio de negocio 
	 * 
	 * @param obParametro El parámetro que deseamos comprobar si es o no nulo
	 * @param strNombreParametroIn El nombre del parámetro que deseamos 
	 * comprobar si es nulo
	 * @param strNombreClaseIn Nombre de la clase desde la que se invoca al método
	 */
	public static void comprobarParametroNulo(Object obParametro, 
			String strNombreParametroIn, 
			String strNombreClaseIn)
	{
		String strMensaje = null;
		LogHelper obLogHelper = null;
		String strNombreClase = null;
		String strNombreParametro = null;	
		String[] descripcionParams = new String[2];
		
		//El parámetro que deseamos comprobar si es o no nulo es nulo		
		if (null == obParametro)
		{
			/**
			 * Si no se utiliza como argumento de llamada el nombre de la clase
			 * desde la que se realiza la comprobación, por defecto cogemos el 
			 * nombre de la clase de utilidades  
			 */
			strNombreClase = strNombreClaseIn;
			
			if (StringUtils.isBlank(strNombreClase))
			{
				strNombreClase = NOMBRE_CLASE;
			}
			
			/**
			 * Si no se utiliza como argumento de llamada el nombre del parámetro
			 * que se desea comprobar, por defecto tomamos como nombre el nombre
			 * del parámetro del método
			 */ 
			
			strNombreParametro = strNombreParametroIn;
			
			if (StringUtils.isBlank(strNombreParametro))
			{
				strNombreParametro = "obParametro";
			}
			
			/**
			 * Instanciamos el objeto que nos permitirá escribir mensajes en el LOG
			 * de la plataforma
			 */			
			obLogHelper = getLoggerANPM(strNombreClase);
			
			//Escribimos un mensaje en el LOG de la plataforma
			if (obLogHelper.isDebugEnabled())
			{
				strMensaje = String.format("El valor del parámetro %s no puede ser nulo", 
						strNombreParametro);
				
				obLogHelper.warn(strMensaje);
			}
			
			// Definimos los parámetros del mensaje de error
			descripcionParams [0] = strNombreParametro;
			descripcionParams [1] = strNombreClaseIn;

			//Lanzamos una excepcion y hacemos rollback del servicio de negocio
			ServicioNegocio.rollback(CodigosError.CTE_CLAVE_MENSAJE_PARAMETRO_NULO, 
					null, descripcionParams, null);	
		}		
	}
	
	
	/**
	 * Metodo para obtener la moneda de la entidad
	 * 
	 * @return String con la moneda
	 */
	public static String obtenerMonedaEntidad()
	{
		String moneda = IConstantesSolicitud.MONEDA_EURO;

		if (StringUtils.isNotBlank(
				ServicioNegocio.getContexto().getMoneda()))
		{
			moneda = ServicioNegocio.getContexto().getMoneda().trim();
		}

		//Comprobamos si ha sido posible obtener el valor del parametro de configuracion
		errorIsNullorEmpty(moneda, "Moneda Entidad", NOMBRE_CLASE);

		return moneda;
	}
	
	/**
	 * Metodo que valida que un string no sea nulo ni vacio si, no se cumple da error
	 * de dato vacio.
	 * 
	 * @param inValor Valor que queremos comprogar
	 * @param inNombreParaError Nombre del campo que estamos validando por si hay error
	 * @param inNombreClase nombre clase
	 * 
	 */
	public static void errorIsNullorEmpty(String inValor, String inNombreParaError,
		String inNombreClase)
	{
		String valor = null;
		String nombreParaError = "inValor";
		String nombreClase = NOMBRE_CLASE;
		
		if (StringUtils.isNotBlank(inValor))
		{
			valor = inValor.trim();
		}
		
		if (StringUtils.isNotBlank(inNombreClase))
		{
			nombreClase = inNombreClase.trim();
		}
		
		if (StringUtils.isNotBlank(inNombreParaError))
		{
			nombreParaError = inNombreParaError.trim();
		}
		
		comprobarParametroNulo(valor, nombreParaError, nombreClase);
	}

		/**
	 * Metodo que comprueba si dos bigdecimal son iguales y contienen el mismo
	 * valor sin revisar si son null o la precision
	 *	
	 * @param dcValor1 El primero de los valores
	 * @param dcValor2 El segundo de los valores
	 * @return true si los valores son iguales y false en caso contrario 
	 * 
	 */
	public static boolean contieneMismoValor(BigDecimal dcValor1, BigDecimal dcValor2)
	{
		boolean resultado = true;
		
		if (((null == dcValor1) && (null != dcValor2)) ||
			((null != dcValor1) && (null == dcValor2)) ||
			((null != dcValor1) && (null != dcValor2) &&
			 (0 != dcValor1.compareTo(dcValor2))))
		{
			resultado = false;
		}
		
		return resultado;
	}
	
	/**
	 * Metodo que comprueba si dos Dates son iguales y contienen el mismo
	 * valor sin revisar si son null o la precision
	 *	
	 * @param dcValor1 El primero de los valores
	 * @param dcValor2 El segundo de los valores
	 * @return true si los valores son iguales y false en caso contrario 
	 * 
	 */
	public static boolean contieneMismoValor(Date dcValor1, Date dcValor2)
	{
		boolean resultado = true;
		
		if (((null == dcValor1) && (null != dcValor2)) ||
			((null != dcValor1) && (null == dcValor2)) ||
			((null != dcValor1) && (null != dcValor2) &&
			 (0 != dcValor1.compareTo(dcValor2))))
		{
			resultado = false;
		}
		
		return resultado;
	}
	
	/**
	 * Metodo que comprueba si dos String son iguales y contienen el mismo
	 * valor sin revisar si son null ni es sensitive
	 *	
	 * @param strValor1 El primero de los valores
	 * @param strValor2 El segundo de los valores
	 * @return true si los dos valores son iguales y false en caso contrario  
	 * 
	 */
	public static boolean contieneMismoValor(String strValor1, String strValor2)
	{
		boolean resultado = true;
		
		if (((null == strValor1) && (null != strValor2)) ||
			((null != strValor1) && (null == strValor2)) ||
			((null != strValor1) && (null != strValor2) &&
			 (!strValor1.equalsIgnoreCase(strValor2))))
		{
			resultado = false;
		}
		
		return resultado;
	}

	
	/**
	 * Método que confecciona un mensaje multiidioma para un error producido
	 * durante la invocación a un servicio de negocio
	 * 
	 * @param inCtaContable La cuenta contable del servicio en el que se produjo
	 * el error
	 * @param inCodOperacion El codigo de operacion del servicio en el que se 
	 * produjo el error
	 * @param strCodigoErrorIn El código del error producido 
	 * @param strDescErrorIn La descripción del error producido
	 */
	public static void confeccionarMensajeErrorInvServNeg(
			Integer inCtaContable, 
			Integer inCodOperacion, 
			String strCodigoErrorIn, 
			String strDescErrorIn)
	{
		final String strNombreParCta = "inCtaContable";
		final String strNombreParOp = "inCodOperacion";
		String strCodigoError = StringUtils.EMPTY;
		String strDescError = StringUtils.EMPTY;
		String[] descripcionParams = new String[4]; 
		
		
		//Comprobamos que el valor de los parámetros oblogatorios no sea nulo
		comprobarParametroNulo(inCtaContable, strNombreParCta);
		comprobarParametroNulo(inCodOperacion, strNombreParOp);
						
		//Comprobamos si se nos envía el código y la descripcion del error
		if (StringUtils.isNotBlank(strCodigoErrorIn))
		{
			strCodigoError = strCodigoErrorIn.trim();
		}
				
		if (StringUtils.isNotBlank(strDescErrorIn))
		{
			strDescError = strDescErrorIn.trim();
		}
		
		// Definimos los parámetros del mensaje de error
		descripcionParams [0] = inCtaContable.toString();
		descripcionParams [1] = inCodOperacion.toString();
		descripcionParams [2] = strCodigoError;
		descripcionParams [3] = strDescError;
		
		//Lanzamos una excepcion y hacemos rollback del servicio de negocio
		ServicioNegocio.rollback(CodigosError.CLAVE_MENSAJE_ERROR_INV_SERV_NEG, 
				null, descripcionParams, null);		
	}	
	
	/**
	 * Método que confecciona un mensaje multiidioma para un error producido
	 * durante la invocación a un servicio de negocio
	 * 
	 * @param inCtaContable La cuenta contable del servicio de negocio donde
	 * se produce el error
	 * @param inCodOperacion El código de operación del servicio de negocio donde
	 * se produce el error
	 */
	public static void confeccionarMensajeErrorInvServNeg(
			Integer inCtaContable, 
			Integer inCodOperacion)
	{
		confeccionarMensajeErrorInvServNeg(
				inCtaContable, 
				inCodOperacion, 
				null, null);
	}
	
	public static BigDecimal mayor(BigDecimal a, BigDecimal b)
	{
		BigDecimal mayor = null;
		if (0 < a.compareTo(b))
		{
			mayor = a;
		}
		else
		{
			mayor = b;
		}
		return mayor;
	}
	
	public static BigDecimal mayor(BigDecimal a, BigDecimal b,BigDecimal c)
	{
		BigDecimal mayor = null;
		if (0 < a.compareTo(b) && 0 < a.compareTo(c) )
		{
			mayor = a;
		}
		else if(0 < b.compareTo(a) && 0 < b.compareTo(c))
		{
			mayor = b;
		}else{
			mayor = c;
		}
		
		return mayor;
	}

	/**
	 * Obtiene el valor de un parámetro de la tabla de parámetros generales de la aplicación (AN82, ParametroC).
	 * Devuelve siempre el primer nombre que encuentra, aunque haya más de un resultado.
	 * 
	 * @param agrupacion
	 * @param nombre
	 * 
	 * @return codigoEntidadEvo
	 */
	public static String obtenerValorParametroUnico(String agrupacion, String nombre)
	{
		String valor = null;
		IDatosEntradaTx datosEntradaBusquedaParametro = null;
		IContexto[] arrayContextosBusquedaParametro = null;
		
		/*Obtenemos el código de entidad de EVO*/
		datosEntradaBusquedaParametro = ServicioNegocio.getPrograma(
			ServicioNegocio.getContexto(),
			IConstantesSolicitud.CTE_SN_BUSQ_PARAM_CC,
			IConstantesSolicitud.CTE_SN_BUSQ_PARAM_CO);
		
		if (! StringUtils.isBlank(agrupacion))
		{
			datosEntradaBusquedaParametro.addCampo(
				IConstantesSolicitud.CTE_SN_BUSQ_PARAM_ENT_AGRUP,
				agrupacion);
		}
		
		if (! StringUtils.isBlank(nombre))
		{
			datosEntradaBusquedaParametro.addCampo(
				IConstantesSolicitud.CTE_SN_BUSQ_PARAM_ENT_NOMBRE,
				nombre);
		}
		
		arrayContextosBusquedaParametro = ServicioNegocio.invocarServicio(
			ServicioNegocio.getContexto(),
			datosEntradaBusquedaParametro);
		
		if (! isBlankOrNull(arrayContextosBusquedaParametro))
		{
			valor = comprobarDatoNull(
				arrayContextosBusquedaParametro[0].getString(IConstantesSolicitud.CTE_SN_BUSQ_PARAM_SAL_VALOR));
		}
		return valor;
	}
	
	/**
	 * Obtiene los valores de un parámetro de la tabla de parámetros generales de la aplicación (AN82, ParametroC).
	 * 
	 * @param agrupacion
	 * @param nombre
	 * 
	 * @return codigoEntidadEvo
	 */
	public static List<String> obtenerListaValoresParametro(String agrupacion, String nombre)
	{
		String valor = null;
		List<String> listaValores = new ArrayList<String>(1);
		IDatosEntradaTx datosEntradaBusquedaParametro = null;
		IContexto[] arrayContextosBusquedaParametro = null;
		
		/*Obtenemos el código de entidad de EVO*/
		datosEntradaBusquedaParametro = ServicioNegocio.getPrograma(
			ServicioNegocio.getContexto(),
			IConstantesSolicitud.CTE_SN_BUSQ_PARAM_CC,
			IConstantesSolicitud.CTE_SN_BUSQ_PARAM_CO);
		
		if (! StringUtils.isBlank(agrupacion))
		{
			datosEntradaBusquedaParametro.addCampo(
				IConstantesSolicitud.CTE_SN_BUSQ_PARAM_ENT_AGRUP,
				agrupacion);
		}
		
		if (! StringUtils.isBlank(nombre))
		{
			datosEntradaBusquedaParametro.addCampo(
				IConstantesSolicitud.CTE_SN_BUSQ_PARAM_ENT_NOMBRE,
				nombre);
		}
		
		arrayContextosBusquedaParametro = ServicioNegocio.invocarServicio(
			ServicioNegocio.getContexto(),
			datosEntradaBusquedaParametro);
		
		if (! isBlankOrNull(arrayContextosBusquedaParametro))
		{
			for (IContexto contextoBusqParam : arrayContextosBusquedaParametro)
			{
				valor = comprobarDatoNull(
					contextoBusqParam.getString(IConstantesSolicitud.CTE_SN_BUSQ_PARAM_SAL_VALOR));
				listaValores.add(valor);
			}
			
		}
		return listaValores;
	}
	
	
	
	/**
	 * Comprueba si el objeto es nulo o vacío.
	 * <br/>
	 * En el caso de las cadenas de caracteres {@link String} mira si hay algun caracter no blanco.
	 * <br/>
	 * En el caso de las fechas {@link Date} se compara con la fecha mas baja en Java.
	 * <br/>
	 * En el caso de las colecciones, {@link Collection} {@link Set} {@link Map},
	 * mira si esta no tiene elementos.
	 * <br/>
	 * En el caso de los datos arquitectura se resuelve su valor y se comprueba si esta vacio
	 * 
	 * @param obj - Objeto a comprobar
	 * @return Cierto si el objeto es nulo o vacío
	 */
	public static boolean isBlankOrNull(final Object obj)
	{
		boolean ret = false;
		
		if (obj == null) 
		{
			ret = true;
		}
		else if (obj instanceof String) 
		{
			ret = (obj == null) || "".equals(((String) obj).trim());
		}
		else if (obj instanceof Boolean)
		{
			ret = false;
		}
		else if (obj instanceof Character)
		{
			ret = Character.isWhitespace(((Character) obj).charValue());
		}
		else if (obj instanceof Number)
		{
			ret = false;
		}
		else if (obj instanceof Date)
		{
			final java.util.Date dLow = Timestamp.valueOf(CTE_DATELOWEST);
			ret = dLow.after((Date) obj) || dLow.equals(obj);
		}
		else 
		{
			ret = 0 == length(obj);
		}
		
		return ret;
	}
	
	/**
	 * Averigual el numero de elementos de una coleccion o el numero de caracteres
	 * de una cadena de texto (si el objeto es un {@link String} o un {@link StringBuffer}
	 * 
	 * @param obj - objeto a comprobar su longitud
	 * @return Longitud del objecto
	 * @throws IllegalArgumentException  - si el objeto no es compatible
	 */
	@SuppressWarnings("rawtypes")
	public static int length(final Object obj)
	{
		int l;
		
		if (obj == null) 
		{
			l = 0;
		}
		else if (obj instanceof String) 
		{
			l = ((String) obj).length();
		}
		else if (obj instanceof StringBuffer) 
		{
			l = ((StringBuffer) obj).length();
		}
		else if (obj instanceof Collection) 
		{
			l = ((Collection) obj).size();
		}
		else if (obj instanceof Map) 
		{
			l = ((Map) obj).size();
		}
		else if (obj instanceof Set) 
		{
			l = ((Set) obj).size();
		}
		else
		{
			int count = 0;
			if (obj instanceof Iterator)
			{
				final Iterator it = (Iterator) obj;
				boolean bHayMas = it.hasNext();
				while (bHayMas) 
				{
					it.next();
					bHayMas = it.hasNext();
					count++;
				}
				l = count;
			}
			else if (obj instanceof Enumeration)
			{
				Enumeration en = (Enumeration) obj;
				boolean bHayMas = en.hasMoreElements(); 
				while (bHayMas) 
				{
					en.nextElement();
					bHayMas = en.hasMoreElements();
					count++;
				}
				l = count;
			}
			else
			{
				try 
				{
					l = Array.getLength(obj);
				} 
				catch (IllegalArgumentException e) 
				{
					throw new IllegalArgumentException(
							"Inconsistent Object Type: " + obj.getClass());
				}
			}
		}
		return l;
	}
	
	
	/**
	 * Método que comprueba si el servicio de negocio que se está ejecutando se encuentra
	 * en un entorno de EVO (preexplotacion/explotación).
	 * Para ello consulta la tabla AN82TB01 para obtener el código de entidad de EVO y
	 * lo compara con el código de la entidad donde se está ejecutando, obtenido mediante
	 * el parámetro de configuración ANPMCFG_ENTIDAD_COD.
	 * 
	 *  
	 * @return true si se está ejecutando en un entorno de EVO, false en caso contrario.
	 */
	public static boolean esEntornoEvo()
	{
		/*String codigoEntidadActual = null;
		String codigoEntidadEvo = null;
		
		/*Obtenemos el código de la entidad en la que se está ejecutando el servicio
		codigoEntidadActual = Configuracion.getInstance().getValor(
			IConstantesSolicitud.CTE_APLICACION_COD_ENT_ACT,
			IConstantesSolicitud.CTE_GRUPO_CONFIG_COD_ENT_ACT,
			IConstantesSolicitud.CTE_PARAM_CONFIG_COD_ENT_ACT).trim();

		if(LOGGER.isDebugEnabled()) {
			LOGGER.debug("PARAMETRO_EVO parametro de configuracion, aplicacion ANPM, grupo ENTIDAD, parametro COD : ".concat(codigoEntidadActual));

		}
		
		
		/*Obtenemos el código de entidad de EVO de la tabla de parámetros generales de la aplicación (AN82, ParametroC)
		codigoEntidadEvo = UtilidadesTramitacion.obtenerValorParametroUnico(
			IConstantesSolicitud.CTE_PARAMETRO_AGRUPACION_GENERAL,
			IConstantesSolicitud.CTE_PARAMETRO_NOMBRE_CODIGO_ENTIDAD_EVO);
		
	 if (LOGGER.isDebugEnabled())
		{	
		LOGGER.debug("PARAMETRO_EVO codigo entidad EVO sacado de la CAG.AN82TB01: ".concat(codigoEntidadEvo));
		}
		
		return codigoEntidadActual.equals(codigoEntidadEvo);*/
		
		// Modificación previa a la eliminación de este método y de esEntornoAbanca
		return false;
	}
	
	public static boolean esEntornoAbanca()
	{
		/*String codigoEntidadActual = null;
		String codigoEntidadAbanca = null;
		
		/*Obtenemos el código de la entidad en la que se está ejecutando el servicio
		codigoEntidadActual = Configuracion.getInstance().getValor(
			IConstantesSolicitud.CTE_APLICACION_COD_ENT_ACT,
			IConstantesSolicitud.CTE_GRUPO_CONFIG_COD_ENT_ACT,
			IConstantesSolicitud.CTE_PARAM_CONFIG_COD_ENT_ACT).trim();

		/*Obtenemos el código de entidad de ABANCA de la tabla de parámetros generales de la aplicación (AN82, ParametroC)
		codigoEntidadAbanca = UtilidadesTramitacion.obtenerValorParametroUnico(
			IConstantesSolicitud.CTE_PARAMETRO_AGRUPACION_GENERAL,
			"CO_ENT_ABA");
	  if (LOGGER.isDebugEnabled())
		{	
		  LOGGER.debug("PARAMETRO_EVO parametro de configuracion, aplicacion ANPM, grupo ENTIDAD, parametro COD : ".concat(codigoEntidadActual));
		}
		
		return codigoEntidadAbanca.equals(codigoEntidadActual);*/
		
		// Modificación previa a la eliminación de este método y el de esEntornoEvo;
		return true;
	}
	
	
	/**
	 * 
	 * @param idContexto nombre del contexto a buscar
	 * @param aContextos
	 * @return Retorna un array de contextos que coincidan con el nombre que se pasa como parametro
	 */
	public static IContexto[] getArrayContexto(String idContexto, IContexto[] aContextos)
	{
		List<IContexto> lstContexto = new ArrayList<IContexto>(0);
		for (IContexto contexto : aContextos)
		{
			if (idContexto.equals(contexto.getNombre()))
			{
				lstContexto.add(contexto);
			}
		}
		return lstContexto.toArray(new IContexto[0]);
	}

	
	/**
	 * Método que trunca un String al tamaño indicado.
	 * @param str
	 * @param tamano
	 * @return resultado string truncado.
	 */
	public static String truncar(String str, int tamano)
	{
		String resultado = StringUtils.EMPTY;
		str = comprobarDatoNull(str);
		if (! StringUtils.isBlank(str))
		{
			if (str.length() > tamano)
			{
				resultado = str.substring(0, tamano);
			}
			else
			{
				resultado = str;
			}
		}
		return resultado;
	}

	
	public static void enviarCorreo(String[] destinatarios, String asunto,
			String remitente, String remitenteNombre, String codPlantilla,
			Map<String, Object> model)
	{
		IMailSender mailSender = MailSenderFactory.getInstance();
		Mail mail = new Mail();
		
		mail.setTo(destinatarios);
		
		mail.setSubject(asunto);
		
		if (! StringUtils.isBlank(remitente))
		{
			mail.setFrom(remitente);
		}
		
		if (! StringUtils.isBlank(remitenteNombre))
		{
			mail.setFromName(remitenteNombre);
		}
		mail.getTemplate().setIdApp(Constantes.CTE_ANPM);
		
		mail.getTemplate().setCodPlantilla(codPlantilla);
		
		if (null != model)
		{
			mail.getTemplate().setData(model);
		}

		mail.setHtmlType();
		
		mailSender.deliverMail(mail);

	}
	
	/**
	 * Método que envía correo en caso de error en una operación por e-Notario. En el cuerpo del mensaje 
	 * se incluye el mensaje que se le pase como parámetro a través de su clave error. También recibe como
	 * parámetro el medio de formalización, si no es e-Notario (1) no hace nada.
	 * 
	 * @param error
	 * @param medioFormalizacion
	 */
	public static void enviarCorreo(int error, DatosSolicitudC solicitud, String[] mensajeDesc)
	{
		if( 1 == solicitud.getMedioFormalizacion().intValue())
		{
			UtilidadesComun.enviarCorreo(
									"MAIL_FORM", 
								    "NUC: "
								    + solicitud.getDatosSolicitudKey().getNucExpediente().toString()
								    + ", CCC: "
								    + UtilidadesEnotario.getContratoPrestamo(solicitud)
								    + ", ERROR: "
								    + new IFRTRollbackException(error, null, mensajeDesc, null, 0).getDescripcion());
		}
	}
	
	/**
	 * Sobrecarga del método para cuando no es necesario un array de parámetros para el mensaje de error. 
	 * 
	 * @param error
	 * @param medioFormalizacion
	 */
	public static void enviarCorreo(int error, DatosSolicitudC solicitud)
	{
		enviarCorreo(error, solicitud, null);
	}
	
	/**
	 * Devuelve el contexto GUSUN023 información de un usuario invocando el servicio GUSU_046.
	 * 
	 * @param codUsuario
	 * @return
	 */
	public static IContexto obtenerCtxDetalleUsuario(String codUsuario)
	{
		IContextoEjecucion ctxEjecucion = ServicioNegocio.getContexto();
		IContexto ctxDetalleUsuario = null;
		
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		
		datosEntrada = ServicioNegocio.getPrograma(
			ctxEjecucion,
			Constantes.CTE_SN_DETALLE_USUARIO_CC,
			Constantes.CTE_SN_DETALLE_USUARIO_CO
			);
		
		datosEntrada.addCampo("CODIGO_USUARIO", codUsuario);
		
		resultado = ServicioNegocio.invocarServicio(
			ctxEjecucion,
			datosEntrada);
		
		if (! isBlankOrNull(resultado))
		{
			ctxDetalleUsuario = resultado[0];
		}
		
		
		return ctxDetalleUsuario;
	}
	
	/**
	 * Borramos las solicitudes incompletas que pueda haber invocando el ANPM_176
	 * @param bidNucExpediente
	 */
	public static void borrarSolicitudesIncompletas(BigDecimal bidNucExpediente)
	{
		IDatosEntradaTx datosEntrada = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_CC_BORRAR_SOLIC_INCOMP,
			Constantes.CTE_CO_BORRAR_SOLIC_INCOMP);
		
		datosEntrada.addCampo("NUC", bidNucExpediente);
		
		ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntrada);
	}	
	
	/**
	 * Proceso que actualiza los datos de la solicitud ANPM 
	 * en tabla registro reapertura (llama al programa EEXPR526)
	 * @param operacion
	 * @param nuc	
	 */
	public static void actualizarTablaReaperturasExpediente(String operacion, BigDecimal nuc)
	{
		final Integer CTE_CC = new Integer(502);
		final Integer CTE_CO = new Integer(996);
			
		IContextoEjecucion contextoEjecucion = null;
		IDatosEntradaTx datosEntradaSN = null;
		          
		contextoEjecucion = ServicioNegocio.getContexto();
		
		datosEntradaSN = ServicioNegocio.getPrograma(contextoEjecucion, CTE_CC, CTE_CO);
		
		datosEntradaSN.addCampo(0, operacion);
		datosEntradaSN.addCampo(1, nuc);		
	
		ServicioNegocio.invocarServicio(contextoEjecucion, datosEntradaSN);
	}
	
	
	/**
	 * Se llama al servicio EEXP_273 que actualiza el estado de la tarea
	 * @param datosSolicitud
	 */
	public static void actualizarEstadoTarea(BigDecimal nuc, BigDecimal codigoProceso, String estadoTarea)
	{
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("INICIO Actualizar estado de la tarea");
		}
		
		/*Finalmente se va a invocar al programa host EEXPR114*/
		
		IContexto ctxEntrada = null;
		Timestamp timestamp = null;
		String timestampStr = null;
		IContextoEjecucion ctxEjecucion = null;
		
		timestamp = DateHelper.getInstance().askTimestampFromDB2();
		timestampStr = DateHelper.timestampToString(timestamp, DateHelper.FORMATO_DB2_TIMESTAMP);
		ctxEjecucion = ServicioNegocio.getContexto();
		
		/*Informamos el contexto de entrada*/
        ctxEntrada = ContextoFactory.getInstance().getContexto(E_CTX_EE114CON);
        ctxEntrada.put(E_R114_OPERACION, EXP_OPE_MODIFICAR);
        ctxEntrada.put(E_R114_NUC, nuc);
        ctxEntrada.put(E_R114_PROCESO, codigoProceso);
        ctxEntrada.put(E_R114_ESTADO, estadoTarea);
        ctxEntrada.put(E_R114_TIMESTAMP, timestampStr);
        ctxEntrada.put(E_R114_TERMINAL, ctxEjecucion.getTerminal());
        ctxEntrada.put(E_R114_USUARIO, ctxEjecucion.getUsuario());
        //ctxEntrada.put(E_R114_COD_ERROR, BigDecimal.ZERO);
        //ctxEntrada.put(E_R114_TEX_ERROR, StringUtils.EMPTY); 
        
        /*Invocamos el EEXPR114*/
        IContexto[] salidaServicio = ctgFacade.invocarProgramaCics(ctxEntrada, CTE_EEXPR114);

        if ((null == salidaServicio) || (!BigDecimal.ZERO.equals(salidaServicio[0].getBigDecimal(E_R114_COD_ERROR))))
		{
			ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_CAMBIO_ESTADO_EEXP,
									 null,
									 new String[] {nuc.toString()},
									 null);
		}
		
	}
	
	/**
	 * Servicio que devuelve el IBAN de la cuenta o el IBAN del préstamo a partir de la 
	 * tira recibida (puede estar formada por el número de cuenta o el número de la solicitud) y el código del país.
	 * @param tira
	 * @param codigoPais
	 */
	
	public static String consultaIban(String tira, String codigoPais)
	{
			
		final Integer CTE_CC = new Integer(100);
		final Integer CTE_CO = new Integer(332);
		
		final String CTE_CTX_IBAN = "CG073CON";
	    final String CTE_CAMPO_IBAN = "CG073C0010";
			
		IContextoEjecucion contextoEjecucion = null;
		IDatosEntradaTx datosEntradaSN = null;		
		String strIban = "";
		          
		contextoEjecucion = ServicioNegocio.getContexto();
		
		datosEntradaSN = ServicioNegocio.getPrograma(contextoEjecucion, CTE_CC, CTE_CO);
		
		datosEntradaSN.addCampo(2, tira);
		datosEntradaSN.addCampo(3, codigoPais);		
			
		IContexto[] datos = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntradaSN);		
		
		IContexto ctx = UtilidadesTramitacion.getContexto(datos, CTE_CTX_IBAN);
		if (ctx != null)
		{
			 strIban = ctx.getString(CTE_CAMPO_IBAN);			
		}		
		return strIban;
	}	
	
	/**
	 * Devuelve true si se cumple que es un tipo de intrés de los tipos 3,4 u 5
	 * falso en otro caso
	 * @param tipoInteres
	 * @return boolean
	 */
	public static boolean esBonificable(final IContexto[] aContextoInteres) {
		
		//Tipo condicion de interés
		final String strIntPropTipoInteres = "ANPMN052080";
		
		for(IContexto contextoIntereses:aContextoInteres) {
			if(contextoIntereses.getString(strIntPropTipoInteres).equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_BONIFICABLE) || 
				contextoIntereses.getString(strIntPropTipoInteres).equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_CON_DIFER_BONIF) ||
					contextoIntereses.getString(strIntPropTipoInteres).equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_PENALIZABLE)) {
					
				return true;
			}
		}
		
		
		return false;
	}
	
	
	public static boolean esBonificable(final List<CondicionesInteresC> lstCondicionesInteres) {
		
		for(CondicionesInteresC condicionInteres:lstCondicionesInteres) {
			if(condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_BONIFICABLE) || 
					condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_CON_DIFER_BONIF) ||
					condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_PENALIZABLE)) {
					
				return true;
			}
		}
		
		
		return false;
	}
	
	/** Indica si un expediente es hipotecario. Devuelve True si el expediente es hipotecario, false en otro caso 
	 * @param bidTipoExpediente Codigo del tipo de expediente
	 */
	public static boolean esHipotecario(final BigDecimal bidTipoExpediente)
	{
		boolean esHipotecario = false;
		String codExpediente;
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("INICIO esHipotecario");
		}
		// Servicio de edicion de datos de formalizacion de una solicitud DatosSolicitudFormalizacionEdicionSrv
		final IDatosEntradaTx datosTipoExpedienteSrv = 
			ServicioNegocio.getPrograma(
					ServicioNegocio.getContexto(), 
					ID_CUENTA_ANPM, 
					ID_COOP_CONSULTA_TIPO_EXPEDIENTE);		
		datosTipoExpedienteSrv.addCampo(
				NOMBRE_CAMPO_TIPO_EXPEDIENTE, UtilidadesTramitacion.bigDecimalToString(bidTipoExpediente, 4, 0, false));
		
		final IContexto[] aContextoSolicitud = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosTipoExpedienteSrv);
		
		IContexto ctx = UtilidadesTramitacion.getContexto(aContextoSolicitud, CONTEXTO_CONS_TIPO_EXP);
		if (ctx != null)
		{
			codExpediente = aContextoSolicitud[0].getString(CONTEXTO_CONS_TIPO_EXP_CODIGO);
			if (codExpediente.equals("H"))
			{
				esHipotecario = true;
			}
		}
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("FIN esHipotecario");
		}		
		return esHipotecario;
	}
	
	
	
	/**
	 * Consulta si un tipo de expediente es hipotecario o personal 
	 * @param tipoExpediente
	 * @return
	 */
	public static boolean esHipotecario2(BigDecimal tipoExpediente)
	{     
		String tipo="";
		boolean esHipotecario = false;

		GestionDatosSolicitud gds = new GestionDatosSolicitud();

		if (null != tipoExpediente){
			tipo=gds.obtenerTipoExpediente(tipoExpediente.toString());
		}

		if (tipo.equals("H")){
			esHipotecario = true;
		}


		return esHipotecario;
	}
 

	
	/**
	 * Método que consulta la tabla de parámetros (CG32TB01) a través del
	 * servicio CGAL_373 (CC 100).
	 * Si no hay ninguna fila o hay más de una lanza un rollback.
	 * 
	 * @param tabla columna CG320010
	 * @param claveDentroTabla columna CG320020
	 * @param lanzarRollback, en caso de que no exista el parámetro, si este parámetro
	 * 			está a true se lanza rollback, en caso contrario devuelve null.
	 * @return Devuelve el contexto CG151CON.
	 */
	public static IContexto getParametroUnico(String tabla, String claveDentroTabla, boolean lanzarRollback)
	{
		IDatosEntradaTx datosEntradaConsultaParam = null;
		IContexto[] resultadoConsultaParam = null;
		IContexto resultado = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		
		datosEntradaConsultaParam = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_CC_GESTION_PARAM,
			Constantes.CTE_CO_GESTION_PARAM);
		
		datosEntradaConsultaParam.addCampo(
			Constantes.CTE_INT_CERO, Constantes.CTE_STR_C);
		datosEntradaConsultaParam.addCampo(
			Constantes.CTE_INT_UNO, tabla);
		
		datosEntradaConsultaParam.addCampo(
			Constantes.CTE_INT_DOS, claveDentroTabla);
		
		resultadoConsultaParam = ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntradaConsultaParam);
		
		if (lanzarRollback)
		{
			if (isBlankOrNull(resultadoConsultaParam))
			{
				ServicioNegocio.rollback(
					CodigosError.CTE_PARAMETRO_NO_EXISTE,
					null,
					new String[] {tabla, claveDentroTabla},
					null);
			}
			if (! BigDecimal.ZERO.equals(resultadoConsultaParam[0].getBigDecimal("CG151C010")))
			{
				ServicioNegocio.rollback(
					CodigosError.CTE_PARAMETRO_NO_EXISTE,
					null,
					new String[] {tabla, claveDentroTabla},
					null);
			}
			resultado = resultadoConsultaParam[0];
		}
		else
		{
			if ((! isBlankOrNull(resultadoConsultaParam)) &&
				BigDecimal.ZERO.equals(resultadoConsultaParam[0].getBigDecimal("CG151C010")))
			{
				resultado = resultadoConsultaParam[0];
			}
			//si no existe devolvemos nulo.
		}
		return resultado;
	}
	
	/**
	 * Método que consulta la tabla de parámetros (CG32TB01) a través del
	 * servicio CGAL_373 (CC 100).
	 * Si no hay ninguna fila o hay más de una lanza un rollback.
	 * 
	 * @param tabla columna CG320010
	 * @param claveDentroTabla columna CG320020
	 * @return Devuelve el campo CG151C160 del contexto CG151CON (columna CG320140).
	 */
	public static String getParametroUnicoIndicador2(String tabla, String claveDentroTabla, boolean lanzarRollback)
	{
		IContexto contexto = null;
		String ind1 = null;
		
		contexto = getParametroUnico(tabla, claveDentroTabla, lanzarRollback);
		
		if (null != contexto)
		{
			ind1 = contexto.getString("CG151C160").trim();
		}
		
		return ind1;
	}	
	
	/**
	 * Invocamos el ANPM_438 para saber si el prescriptor del expediente es Idealista.
	 * 
	 * @param nucExpediente
	 * @return
	 */
	public static boolean tienePrescriptorIdealista(BigDecimal nucExpediente)
	{
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		boolean prescriptorEsIdealista = false;
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_COMPR_PRESCR_EXPEDIENTE_CC,
			Constantes.CTE_SN_COMPR_PRESCR_EXPEDIENTE_CO);
		
		datosEntrada.addCampo("NUC_EXPEDIENTE", nucExpediente);
		
		resultado = ServicioNegocio.invocarServicio(
			contextoEjecucion, datosEntrada);
		
		if ((! UtilidadesTramitacion.isBlankOrNull(resultado)) &&
			(0 == Constantes.CTE_IND_PRESCRIPTOR_IDEALISTA.compareTo(resultado[0].getBigDecimal("ANPMN438020"))))
		{
			prescriptorEsIdealista = true;
		}
		return prescriptorEsIdealista;
		
	}
	

	/**
	 * Invocamos el ANPM_538 para saber si el prescriptor del expediente es Idealista.
	 * 
	 * @param nucExpediente
	 * @return
	 */
	private static boolean tienePrescriptorAbancaWeb(BigDecimal nucExpediente)
	{
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		boolean prescriptorEsAbancaWeb = false;
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_COMPR_PRESCR_EXPEDIENTE_CC,
			Constantes.CTE_SN_COMPR_PRESCR_EXPEDIENTE_CO);
		
		datosEntrada.addCampo("NUC_EXPEDIENTE", nucExpediente);
		
		resultado = ServicioNegocio.invocarServicio(
			contextoEjecucion, datosEntrada);
		
		if ((! UtilidadesTramitacion.isBlankOrNull(resultado)) &&
			(0 == Constantes.CTE_IND_PRESCRIPTOR_ABANCAWEB.compareTo(resultado[0].getBigDecimal("ANPMN438020"))))
		{
			prescriptorEsAbancaWeb = true;
		}
		return prescriptorEsAbancaWeb;
		
	}
	
	/**
	 * Método que controla si es necesario cambiar el centro contable (= oficina tramitadora).
	 * Los expedientes que fueron dados de alta con prescriptor externo (Idealista, Abanca Web, Multicrédito Web,
	 * no se pueden formalizar teniendo la oficina virtual (806) como oficina tramitadora
	 * 
	 * Se controla el centro contable si el tipo prescriptor es externo, concretamente si es Idealista o Abanca Web,
	 * o si el tipo prescriptor es Web.
	 * 
	 * @param nuc
	 * @return
	 */
	public static boolean controlCentroContable(BigDecimal nuc, BigDecimal tipoPrescriptorEEXP)
	{
		boolean control = false;
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitud = null;
		BigDecimal tipoPrescriptorSolic = null;
		

		//Tenemos dos tipos de prescriptor:
		// - el que llega como parámetro de entrada de este servicio, que lo envía la dll correspondiente que a su vez lo recibió del contexto EE034CON,
		//		debidamente traducido desde la nomenclatura EEXP a la nomenclatura ANPM (ver AN02404X.OBTENER_TIPO_PRESCR_ANPM$).
		// - El que está guardado en la solicitud, AN250290.
		//Si no tenemos solicitud en la 25 --> CRITERIO ANTIGUO: TIPO PRESCRIPTOR EE034CON = 2 Y CONCRETAMENTE IDEALISTA O ABANCA WEB*/
		//Si tenemos solicitud en la 25, depende: Si el TIPO PRESCRIPTOR GUARDADO ES 9 --> Se controla centro contable por ser Multicrédito Web*/
		//									 Si el TIPO PRESCRIPTOR GUARDADO NO ES 9: CRITERIO ANTIGUO.*/
		//Cuando el tipo prescriptor AN250290 = 9 es porque la solicitud nació por el ANPM_400 llamado desde el batch de EEXP: alta automática, 
		//	no va a cambiar el tipo prescriptor.
		//La solicitud puede ser completa o incompleta, depende de si estamos en un alta de tramitación o en una modificación de tram o de preform.*/
		datosSolicitud = gds.getUltimaVersion(nuc);
		
		if ((null == datosSolicitud))
		{
			control = ((0 == Constantes.CTE_TIPO_PRESCRIPTOR_EXTERNO.compareTo(tipoPrescriptorEEXP)) &&
				(tienePrescriptorIdealista(nuc) ||
				 tienePrescriptorAbancaWeb(nuc))
			);
		}
		else
		{
			tipoPrescriptorSolic = datosSolicitud.getTipoPrescriptor();
			/*20151127 Si hay solicitud, actualizamos el centro contable si el tipo prescriptor que ya tiene la solicitud es Web o
			 * si el tipo prescriptor que nos envía EEXP es Web*/
			if ((0 == Constantes.CTE_TIPO_PRESCRIPTOR_WEB.compareTo(tipoPrescriptorSolic)) ||
				(0 == Constantes.CTE_TIPO_PRESCRIPTOR_WEB.compareTo(tipoPrescriptorEEXP)))
			{
				control = true;
			}
			else
			{
				control = ((0 == Constantes.CTE_TIPO_PRESCRIPTOR_EXTERNO.compareTo(tipoPrescriptorEEXP)) &&
					(tienePrescriptorIdealista(nuc) ||
					 tienePrescriptorAbancaWeb(nuc))
				);
			}
		}
		
		return control;
	}
	
	
	/**
	 * Al finalizar la solicitud hay que comprobar si la solicitud tiene depósito y han introducido 
	 * importe en el concepto de "otros destinos", entonces hay que enviar un correo electrónico a 
	 * Laura Alvarez Conde y al buzón "disposicionprestamoscreditos@abanca.com", que se parametrizará 
	 * en la tabla AN82TB01 se creará la agrupación CORREO_DEPOSITO, con los datos del remitente, 
	 * asunto y destinatario. Asunto: " Alta con disposición en otros destinos", en el cuerpo  
	 * " Para el expediente XXXXX se ha dado de alta disposiciones en el concepto "otros destinos".*/
	public static void enviarCorreoDepositos(DatosSolicitudC datosSolicitud)
	{
		List<DesembolsoC> listaDesembolsos = new ArrayList<DesembolsoC>(1);
		List<String> listaDestinatarios = new ArrayList<String>(1);
		String asunto = null;
		String remitenteNombre = null;
		String autor = null;
/*
		String mensaje = null;
		String remitenteDir = null;
		IContexto ctxDetalleUsuario = null;
*/
		if (null != datosSolicitud)
		{
			listaDesembolsos = datosSolicitud.getDesembolsos();
			
			if (! UtilidadesTramitacion.isBlankOrNull(listaDesembolsos))
			{
				//buscamos el desembolso "Otros destinos", id desembolso = 6
				for (DesembolsoC desembolso : listaDesembolsos)
				{
					if (Constantes.CTE_BID_6.equals(desembolso.getDesembolsoKey().getBidIdConcepto()))
					{
						//si el importe es mayor que 0 enviamos correo.
						if (0 > BigDecimal.ZERO.compareTo(desembolso.getBidImporte()))
						{
							/*
							UtilidadesTramitacion.enviarCorreo(
								destinatarios, asunto, remitente, remitenteNombre, codPlantilla, mensaje);
								
								Los destinatarios, String[], los podemos tener en:
								   * la tabla de parametros de ANPM AN82TB01 (se accede invocando el ANPM_075)
								   * 	AGRUPACION: CORREO_DEPOSITO, no cabe: MAIL_DPOS
								   * 	PARAMETRO: DESTINOS
								   * 	VALOR: en principio svillar@externos.abanca.com; g000857@externos.abanca.com
								   * 	VALORES FINALES: 
								   * 		- disposicionprestamoscreditos@abanca.com DE MOMENTO NO
								   *  		- Laura Alvarez Conde

								asunto
								   * la tabla de parametros de ANPM AN82TB01 (se accede invocando el ANPM_075)
								   * 	AGRUPACION: CORREO_DEPOSITO, no cabe: MAIL_DPOS
								   * 	PARAMETRO: ASUNTO
								   * 	VALOR: "Alta con disposición en otros destinos"
								remitente:
								   - es el propio usuario que está ejecutando el servicio, mirar cómo se puede
								   obtener su correo en la documentación del CGDN.
								remitenteNombre: lo mismo.
								codPlantilla: crear plantilla.
								mensaje: 
								   * la tabla de parametros de ANPM AN82TB01 (se accede invocando el ANPM_075)
								   * 
								   * en el mensaje hay que parametrizar al menos el NUC.
								   * 	AGRUPACION: CORREO_DEPOSITO, no cabe: MAIL_DPOS
								   * 	PARAMETRO: MENSAJE
								   * 	VALOR: Para el expediente XXXXX se ha dado de alta disposiciones en el concepto "otros destinos"
								   * Finalmente se añade a la plantilla del correo.
								
								
							*/
							
							listaDestinatarios = UtilidadesTramitacion.obtenerListaValoresParametro(
								Constantes.CTE_AGRUP_MAIL_DPOS, Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_DESTINOS);
							asunto = UtilidadesTramitacion.obtenerValorParametroUnico(
								Constantes.CTE_AGRUP_MAIL_DPOS, Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_ASUNTO);
							autor = UtilidadesTramitacion.obtenerValorParametroUnico(
								Constantes.CTE_AGRUP_MAIL_DPOS, Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_AUTOR);
							/*
							mensaje = UtilidadesTramitacion.obtenerValorParametroUnico(
								Constantes.CTE_AGRUP_MAIL_DPOS, Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_MENSAJE);
							*/
							
							if (UtilidadesTramitacion.isBlankOrNull(listaDestinatarios))
							{
								ServicioNegocio.rollback(
									CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO,
									null,
									new String[] {Constantes.CTE_AGRUP_MAIL_DPOS,
												Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_DESTINOS},
									null);
							}
							else if (StringUtils.isBlank(asunto)) 
							{
								ServicioNegocio.rollback(
									CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO,
									null,
									new String[] {Constantes.CTE_AGRUP_MAIL_DPOS,
												Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_ASUNTO},
									null);
							}
							else if (StringUtils.isBlank(autor)) 
							{
								ServicioNegocio.rollback(
									CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO,
									null,
									new String[] {Constantes.CTE_AGRUP_MAIL_DPOS,
												Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_AUTOR},
									null);
							}
							/*
							else if (StringUtils.isBlank(mensaje))
							{
								ServicioNegocio.rollback(
									Constantes.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO,
									null,
									new String[] {Constantes.CTE_AGRUP_MAIL_DPOS,
												Constantes.CTE_AGRUP_MAIL_DPOS_PARAM_MENSAJE},
									null);
							}
							*/
							/*
							ctxDetalleUsuario = UtilidadesTramitacion.obtenerCtxDetalleUsuario(ServicioNegocio.getContexto().getUsuario());
							
							if (null != ctxDetalleUsuario)
							{
								remitenteDir = UtilidadesTramitacion.comprobarDatoNull(
									ctxDetalleUsuario.getString("GUSUN023060"));
								//remitenteNombre = UtilidadesTramitacion.comprobarDatoNull(ctxDetalleUsuario.getString(""));
							}
							
							if (StringUtils.isBlank(remitenteDir))
							{
								ServicioNegocio.rollback(
									Constantes.CTE_ERROR_DIR_USUARIO,
									null,
									new String[] {ServicioNegocio.getContexto().getUsuario()},
									null);
							}
							*/
							Map<String, Object> model = new HashMap<String, Object>(1);
							
							/*Parametrizamos el nuc en la plantilla*/
							model.put("PARAM_1", datosSolicitud.getDatosSolicitudKey().getNucExpediente().toString());
							
							UtilidadesTramitacion.enviarCorreo(
								listaDestinatarios.toArray(new String[listaDestinatarios.size()]),
								asunto,
								autor,
								remitenteNombre,
								Constantes.CTE_MAIL_DPOS_COD_PLANTILLA,
								model);
							
						}
					}
				}
			}
		}
	}
	
	/**
	 * Determina a traves del contexto de datos de solicitud si es uina solicitud de eNotario
	 * @param contextoDatosSolicitud
	 * @return
	 */
	public static boolean esEnotario(IContexto contextoDatosSolicitud){
	
		final String strSolMedioFormalizacion 			= "ANPMN050955";
		
		boolean esEnotario = false;
		BigDecimal medioFormalizacion = contextoDatosSolicitud.getBigDecimal(strSolMedioFormalizacion);
		
		if(!UtilidadesTramitacion.isBlankOrNull(medioFormalizacion)){
			if(0 == medioFormalizacion.compareTo(BigDecimal.ZERO)){
				return esEnotario;
			}else if(0 == medioFormalizacion.compareTo(BigDecimal.ONE)){
				esEnotario = true;
				return esEnotario;
			}
		}else{
			return esEnotario;
		}
		
		return esEnotario;
	}
	
		/**
	 * Comprueba si es multicredito 48h con el segundo parametro informado comprobará tb el nivel de subproducto,
	 * si esta a nulo solo  comprueba el nivel de producto
	 * @param producto
	 * @return
	 */
	public static boolean esMulticredito48H(String producto,String subproducto) {
		
		final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(
				ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_PARAMETRO,IConstantesTramitacion.CTE_CO_CONSULTA_PARAMETRO);
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_CAMPO_PARAMETRO, producto);
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_AGRUPACION_PARAMETRO, "MULTIC48");
		
		final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
		
		if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0
				&& !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR))) {
				//Si viene informado el campo del subproducto
				if(!UtilidadesTramitacion.isBlankOrNull(subproducto)) {
					if(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR).equals(subproducto)) {
						return true;
					}else {
						return false;
					}
				}else {
					if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR))) {
						return true;
					}else {
						return false;
					}
				}
		}
		return false;
	}
	
	/**
	 * Consulta la edad maxima en la tabla CAG.AN82TB01 (campo ANPMN031050 ) y la compara con los meses totales
	 * @param MesesTotales
	 */
	public static boolean esEdadMaxima(BigDecimal MesesTotales) 
	{
		BigDecimal edadMaxima = null;
		BigDecimal numeroMeses=new BigDecimal(12);
		boolean edadMaximaSuperada = false;
		final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(
				ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_PARAMETRO,IConstantesTramitacion.CTE_CO_CONSULTA_PARAMETRO);
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_CAMPO_PARAMETRO, "EDAD");
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_AGRUPACION_PARAMETRO, "EDAD_MAX");
		
		final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
		
		if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0
				&& !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR))) {
				//Si viene informado el campo del subproducto
				edadMaxima = new BigDecimal(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR));
				}
		if (edadMaxima.multiply(numeroMeses).compareTo(MesesTotales)==-1)
		{	
			edadMaximaSuperada = true;
		}	
		
		return edadMaximaSuperada;
	}
	
	/**
	 * Método que comprueba si una solicitud entra por Solicitud-Contrato.
	 * Entra por S-C si el producto se encuentra en la tabla de parámetros CG32TB01,
	 * tabla CG320010 = 'PSC' y el importe de la solicitud es menor que el que viene en la tabla.
	 * 
	 * 
	 * @param datosSolicitud
	 * @return
	 */
	public static String comprobarSolicitudContrato(DatosSolicitudC datosSolicitud)
	{
		BigDecimal codProducto = null;
		String codProductoStr = null;
		IContexto parametroProductoCompromiso = null;
		BigDecimal parametroImporteProducto = null;
		BigDecimal indFormalizarAlConceder = null;
		
		String indSolicitudContrato = Constantes.CTE_STR_N;
		
		codProducto = datosSolicitud.getProducto();
		codProductoStr = StringUtils.leftPad(
			codProducto.toString(),
			Constantes.CTE_INT_CUATRO,
			Constantes.CTE_CHAR_CERO);
		
		//Obtenemos la fila de la CG32 para saber si hay que obtener el compromiso o no.
		// Si no existe la fila para el producto que recibe quiere decir que no se obtiene el compromiso.
		parametroProductoCompromiso = UtilidadesTramitacion.getParametroUnico(
			Constantes.CTE_CLAVE_PREST_SOLIC_CONTR,
			codProductoStr,
			false);
		
		if (null != parametroProductoCompromiso)
		{
			//Ahora comprobamos si el importe total no supera el limite establecido en la columna importe1 de la tabla.
			parametroImporteProducto = parametroProductoCompromiso.getBigDecimal("CG151C110");
			indFormalizarAlConceder = parametroProductoCompromiso.getBigDecimal("CG151C130");
			
			//Si el importe total de la solicitud es menor que el que viene parametrizado se obtiene el compromiso.
			if ((0 >= datosSolicitud.getImporteTotal().compareTo(parametroImporteProducto)) &&
				(0 == BigDecimal.ONE.compareTo(indFormalizarAlConceder)))
			{
				indSolicitudContrato = Constantes.CTE_STR_S;
			}
		}
		return indSolicitudContrato;
	}
	
	/**
	 * Este metodo comprueba que el estado de la solicitud permite que se impriman sus documentos
	 * Se invoca antes de realizar la impresion de Info Previa,Poliza,Oferta Vinculante y FIPER	
	 * @return verdadero si se puede imprimir, falo en otro caso
	 */
	public static boolean impresionPermitida(String estadoSolicitud) {
		
		boolean impresionPermitida = false;
		
		//Si el estado de la solicitud es concedida o sin resolver
		//se pueden imprimir los documentos sino no
		if(estadoSolicitud.equals(Constantes.CTE_ESTADO_SOL_CONCEDIDA) 
				|| estadoSolicitud.equals(Constantes.CTE_ESTADO_SOL_SIN_RESOLVER)) {
			impresionPermitida = true;
		}else {
			impresionPermitida = false;
		}
		
		
		return impresionPermitida;
	}
	
	/**
	 * Devuelve los clientes asociados a un nuc
	 * @param nucExpediente
	 */
	public static IContexto[] consultarParticipantesPorNuc(BigDecimal nucExpediente) {
		//Inicializar los campos del SR
		IDatosEntradaTx datosEntradaTX = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_CLIENTES,
				IConstantesTramitacion.CTE_CO_CONSULTA_POR_CONTRATO);
		//Añadir el nuc como campo de entrada del servicio de negocio
		datosEntradaTX.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_CONSULTA_POR_CONTRATO, nucExpediente);
		
		//Invocar el srv
		IContexto[] salidaConsultaClientePorContrato = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTX);
		
		return salidaConsultaClientePorContrato;
	}
	
	/**
	 * Consulta un cliente por su numero de cliente dandonos informacion relevante sobre el mismo
	 * @param numeroCliente
	 * @param aplicacion
	 * @param relacion
	 * @return los datos del cliente
	 */
	public static IContexto[] consultarContratosPorCliente(BigDecimal numeroCliente,String aplicacion,String relacion) {
		//Inicializamos los campos del SRV
		IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_CLIENTES,
				IConstantesTramitacion.CTE_CO_CONSULTA_CUENTAS_POR_CLIENTE);
		//Campo de entrada numero de cliente
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_CONSULTA_POR_CLIENTE, numeroCliente);
		if(!UtilidadesTramitacion.isBlankOrNull(aplicacion)) {
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_CONSULTA_POR_CONTRATO_APLICACION, aplicacion.trim());
		}
		if(!UtilidadesTramitacion.isBlankOrNull(relacion)) {
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_TIPO_TITULARIDAD, relacion.trim());
		}
		//Se pasa este parametro de entrada para que saque todos los resultados no solo los 20 primeros
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_CONSULTA_NUMERO_DE_REGISTROS, BigDecimal.ZERO);
		
		
		//Invocar el srv
		IContexto[] salidaCuentasPorCliente = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
		
		return salidaCuentasPorCliente;
	}
	
	/**
	 * Tenemos que comprobar que alguno de los clientes tenga una tarjeta contratada
	 * Si es el caso tenemos que actualizar el concepto tarjeta, se hace dentro de la propia funcion
	 * si no es asi no se hace nada y se carga el gasto
	 */
	public static boolean comprobarTarjetaCliente(BigDecimal nuc, BigDecimal codProducto) {
		//Aqui deberemos comprobar que la cuenta es de alguno de los titulares del prestamo, si es asi ya es true de lo contrario falso
		BigDecimal numeroCliente = null;
		IContexto[] contratosCliente = null;
		boolean encontrado = false;
		
		
		
		//Comprobamos los clientes asociados a este contrato
		IContexto[] clientesEnContrato = consultarParticipantesPorNuc(nuc);
		
		for(IContexto cliente:clientesEnContrato) {
			//Comprobar que el cliente a comprobar es titular
			if(cliente.getString(IConstantesTramitacion.CTE_CTX_RELACION_CLIENTE).equals(Constantes.CTE_STR_01)) {
				numeroCliente = cliente.getBigDecimal(IConstantesTramitacion.CTE_CTX_NUMERO_CLIENTE);
				contratosCliente =  consultarContratosPorCliente(numeroCliente,
		    		Constantes.CTE_CONSULTA_CONTRATOS_CLIENTE_APLICACION, Constantes.CTE_CONSULTA_RELACION_CLIENTE);
				if(null != contratosCliente && contratosCliente.length >= 1 
						&& contratosCliente[0].getString(IConstantesTramitacion.CTE_CTX_CONSULTA_CONTRATOS_ERROR).equals(Constantes.CTE_STR_0)) {
					//Si tiene tarjeta actualizamos la tabla 44
					
					//TODO: PROVISIONAL: QUITAR CUANDO SE REALICE EL PASE: QUITAR EL IF QUE COMPARA PRODUCTOS Y EL COD-PRODUCTO 
					// QUE SE LE PASA AL MÉTODO
					
					/*if(0 != new BigDecimal (5005).compareTo(codProducto) 
					&& 0 != new BigDecimal (5036).compareTo(codProducto)) 
					{*/
						actualizarGastoAdicional(nuc);
					/*}*/
					
					/*if(compruebaGastosTarjeta(nuc, codProducto))
					{
						actualizarGastoAdicional(nuc);
					}*/
					
					//Si lo encontramos ya devolvemos la ejecución
					return true;
				}
			}
		}
		 
		return encontrado;
	}
	
	/**
	 * Actualiza el gasto adicional en su concepto tarjeta
	 * Indicamos que no aplica tae y que su importe es 0
	 * @param nuc
	 */
	public static void actualizarGastoAdicional(BigDecimal nuc) {
		//Crear los objetos correspondientes para realizar la busqueda
		GastosAdicionalesEng gastosAdicionalesDao = new GastosAdicionalesEng();
		GastosAdicionalesC gastoAdicional = gastosAdicionalesDao.obtenerGastoAdicional(nuc, new BigDecimal(7));
		if(null != gastoAdicional) {
			//Buscamos el gasto adicional tarjeta idConcepto = 7
			//gastoAdicional.setAplicaTAE(Constantes.CTE_STR_N);
			gastoAdicional.setAplicaTAENormal(Constantes.CTE_STR_0);
			gastoAdicional.setImporte(BigDecimal.ZERO);
			//Actualizar la tupla de base de datos
			gastoAdicional.update();
		}
	}
	
	
			/**
	 * Comprueba si es multicredito 48h con el segundo parametro informado comprobará tb el nivel de subproducto,
	 * si esta a nulo solo  comprueba el nivel de producto
	 * @param producto
	 * @return
	 */
//	public static BigDecimal consultaNumeroPeriodosRestar(BigDecimal idConcepto) {
//		
//		BigDecimal numeroPeriodosRestar = BigDecimal.ZERO;
//		
//		final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(
//				ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_PARAMETRO,IConstantesTramitacion.CTE_CO_CONSULTA_PARAMETRO);
//		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_CAMPO_PARAMETRO, idConcepto.toString());
//		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_AGRUPACION_PARAMETRO, "GASTOSADIC");
//		
//		final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
//		
//		if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0
//				&& !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR))) {
//				//Si viene informado el campo del subproducto
//				numeroPeriodosRestar = new BigDecimal(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR));
//				return numeroPeriodosRestar;
//		}
//		
//		return numeroPeriodosRestar;
//	}
	
	
	
	public static BigDecimal consultaNumeroPeriodosRestar(List<ParametroC> listaParamPeriodosRestar, BigDecimal idConcepto)
	{
		BigDecimal periodosARestar = BigDecimal.ZERO;

		for (ParametroC parametro : listaParamPeriodosRestar)
		{

			if (0 == idConcepto.compareTo(new BigDecimal(parametro.getStrParametro().trim())))
			{
				periodosARestar = new BigDecimal(parametro.getStrValor().trim());
				break;
			}
		}

		return periodosARestar;
	}
	
				/**
	 * Comprueba si es multicredito 48h con el segundo parametro informado comprobará tb el nivel de subproducto,
	 * si esta a nulo solo  comprueba el nivel de producto
	 * @param producto
	 * @return
	 */
	public static String consultaFechaInicioTarjeta() {
		
		String fechaInicioTarjeta = new String();
		
		final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(
				ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_PARAMETRO,IConstantesTramitacion.CTE_CO_CONSULTA_PARAMETRO);
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_CAMPO_PARAMETRO, "F_INITARJE");
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_AGRUPACION_PARAMETRO, "GENERAL");
		
		final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
		
		if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0
				&& !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR))) {
				//Si viene informado el campo del subproducto
				fechaInicioTarjeta = aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR);
				return fechaInicioTarjeta;
		}
		
		return fechaInicioTarjeta;
	}
	
	
	/**
	 * Método que calcula el importe del gasto adicional por cada año del préstamo, es el que se guarda en la AN44TB01 partiendo
	 * del importe que nos envía Simulación.
	 * 
	 * @param importeTotalSimulacion
	 * @param idConcepto
	 * @param plazoSolic
	 * @return
	 */
	public static BigDecimal calcularImporteGastoAdicional(
		BigDecimal importeTotalSimulacion, BigDecimal idConcepto, BigDecimal plazoSolic, BigDecimal numPeriodosGasto, BigDecimal periodosARestar)
	{
		MathContext mc = new MathContext(17, RoundingMode.HALF_UP);
		BigDecimal importeGastoAdicPorAno = null;
		
		BigDecimal numeroMesesPagoGasto = null;
		BigDecimal numeroAnosPagoGasto = null;
						
		if (0 == BigDecimal.ONE.compareTo(numPeriodosGasto))
		{
			importeGastoAdicPorAno = importeTotalSimulacion;
		}
		else
		{
			/*para calcular el importe que guardamos en la AN44TB01 aplicamos la fórmula:
			 * periodicidad = 12; //meses en un año.
		 *     numeroAñosPagoGasto = (plazoMesesSolic - periodosARestar)/periodicidad;
		 *     Importe a guardar = importeTotal/numeroAñosPagoGasto;
			
			*/
			//periodosARestar = UtilidadesTramitacion.consultaNumeroPeriodosRestar(idConcepto);
			if (0 < periodosARestar.compareTo(plazoSolic))
			{
				// 2016-04-21 - Si el numero de periodos a restar es mayor que el plazo -->
				// el importe del gasto por anho se pone a 0.
				importeGastoAdicPorAno = BigDecimal.ZERO;
			}
			else
			{
				numeroMesesPagoGasto = plazoSolic.subtract(periodosARestar);
				numeroAnosPagoGasto = numeroMesesPagoGasto.divide(Constantes.CTE_BID_12, mc);
				/*20151020 Si el número de años de pago es cero, el importe del gasto es cero.*/
				/*Esto puede ocurrir cuando el plazo del préstamo es igual que el número de períodos a restar.*/
				if (0 == BigDecimal.ZERO.compareTo(numeroAnosPagoGasto))
				{
					importeGastoAdicPorAno = BigDecimal.ZERO;
				}
				else
				{
					importeGastoAdicPorAno = importeTotalSimulacion.divide(numeroAnosPagoGasto, mc);
				}
			}
		}
		
		return importeGastoAdicPorAno;
	}
	
	
	/**
	 * Llamada a expediente electronico para consultar la fecha de incio del mismo
	 * @param producto
	 * @return
	 */
	public static String consultaFechaInicioExpediente(BigDecimal nucExpediente) 
	{
		
		String fechaInicioExpediente = new String();
		
		final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(
				ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_EXPEDIENTE, 
				IConstantesTramitacion.CTE_CO_CONSULTA_DATOS_EXPEDIENTE);
		//datosEntradaConsultaParametro.addCampo(, nucExpediente);
		datosEntradaConsultaParametro.addCampo(0, nucExpediente);
		
		final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), 
				datosEntradaConsultaParametro);
		
		if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && 
				aContextoParametro.length > 0 && 
				!UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].
						getString(IConstantesTramitacion.CTXTO_DATOS_EXPEDIENTE_FECHA))) 
		{
				//Si viene informado el campo del subproducto
				fechaInicioExpediente = aContextoParametro[0].
						getString(IConstantesTramitacion.CTXTO_DATOS_EXPEDIENTE_FECHA);
				return fechaInicioExpediente;
		}
		
		return fechaInicioExpediente;
	}
	
	
	/**
	 * Método que obtiene la fecha de inicio de un expediente, a partir de la salida
	 * del servicio EEXP_272. 
	 * 
	 * @param salidaEEXP272 salida del servicio EEXP_272 (array de contextos EE273CON)
	 * @return fecha de inicio de un expediente
	 */
	public static String consultaFechaInicioExpediente(IContexto[] salidaEEXP272) 
	{	
		String fechaInicioExpediente = new String();
		
		if(!UtilidadesTramitacion.isBlankOrNull(salidaEEXP272) && 
				salidaEEXP272.length > 0 && 
				!UtilidadesTramitacion.isBlankOrNull(salidaEEXP272[0].
						getString(IConstantesTramitacion.CTXTO_DATOS_EXPEDIENTE_FECHA))) 
		{
				//Si viene informado el campo del subproducto
				fechaInicioExpediente = salidaEEXP272[0].
						getString(IConstantesTramitacion.CTXTO_DATOS_EXPEDIENTE_FECHA);
				return fechaInicioExpediente;
		}
		
		return fechaInicioExpediente;
	}	
	
	
	/**
	 * Comprueba si un expediente es valido para que se carguen los gastos adicionales de tarjeta
	 * Si es valido para cargar los datos entonves nos va a devolver verdadero
	 * @param nucExpediente
	 * @return
	 */
	public static boolean compruebaValidezCargoTarjeta(BigDecimal nucExpediente) 
	{
		boolean esValido = false;
		
		Date fechaInicioTarjeta = DateUtils.getSoloFecha(DateUtils.parseDate(
				consultaFechaInicioTarjeta(), DateUtils.FORMATO_FECHA_AMERICANO));
		Date fechaInicioExpediente = DateUtils.getSoloFecha(DateUtils.parseDate(
				consultaFechaInicioExpediente(nucExpediente), DateUtils.FORMATO_FECHA_EEXP));
		
		if(DateUtils.isDateGreater(fechaInicioExpediente, fechaInicioTarjeta)) 
		{
			esValido = true;
		}
		
		return esValido;
	}
	
	
	/**
	 * Comprueba si un expediente es valido para que se carguen los gastos adicionales de tarjeta
	 * Si es valido para cargar los datos entonves nos va a devolver verdadero
	 * @param nucExpediente
	 * @return
	 */
	public static boolean compruebaValidezCargoTarjeta(String strFechaInicioExpediente) 
	{
		boolean esValido = false;
		
		Date fechaInicioTarjeta = DateUtils.getSoloFecha(DateUtils.parseDate(
				consultaFechaInicioTarjeta(), DateUtils.FORMATO_FECHA_AMERICANO));
		
		Date fechaInicioExpediente = DateUtils.getSoloFecha(DateUtils.parseDate(
				strFechaInicioExpediente, DateUtils.FORMATO_FECHA_EEXP));
		
		if(DateUtils.isDateGreater(fechaInicioExpediente, fechaInicioTarjeta)) 
		{
			esValido = true;
		}
		
		return esValido;
	}
	
	
	/**
	 * Servicio que comprueba si el usuario o centro operante tienen permisos BO,
	 * para ello los obtiene del contexto de ejecución e invoca el CGAL_362 (ámbitos), para saber
	 * si tienen permiso o no, primero consulta por centro, y si por centro no tiene permisos luego
	 * consulta por usuario.
	 * 
	 * @return
	 */
	public static boolean esBO()
	{
		boolean tienePermisos = false;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		String usuario = comprobarDatoNull(contextoEjecucion.getUsuario());
		String oficina = comprobarDatoNull(contextoEjecucion.getOficina());
		
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		
		
		/*Llamamos al CGAL_362 consultando por oficina*/
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_APLIC_CGAL,
			Constantes.CTE_COD_CONS_PERMISOS);
		
		datosEntrada.addCampo(0, Constantes.CTE_COD_CONS_PERM_ID_APL);
		datosEntrada.addCampo(1, Constantes.CTE_COD_CONS_PERM_TIPO_ENT);
		datosEntrada.addCampo(2, Constantes.CTE_COD_CONS_PERM_IDENT_ENT);
		datosEntrada.addCampo(3, oficina);
		
		resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
		
		if ((! isBlankOrNull(resultado)) &&
			(0 == Constantes.CTE_STR_S.compareTo(resultado[0].getString(Constantes.CTE_COD_CONS_PERM_SAL_TIENE_PERM))))
		{
			tienePermisos = true;
		}
		else
		{
			/*Volvemos a llamar al CGAL_362 pero consultando por usuario*/
			datosEntrada = null;
			
			/*Llamamos al CGAL_362 consultando por usuario*/
			datosEntrada = ServicioNegocio.getPrograma(
				contextoEjecucion,
				Constantes.CTE_APLIC_CGAL,
				Constantes.CTE_COD_CONS_PERMISOS);
			
			datosEntrada.addCampo(0, Constantes.CTE_COD_CONS_PERM_ID_APL);
			datosEntrada.addCampo(1, Constantes.CTE_COD_CONS_PERM_TIPO_ENT);
			datosEntrada.addCampo(2, Constantes.CTE_COD_CONS_PERM_IDENT_ENT_RECURSO);
			datosEntrada.addCampo(4, usuario);
			
			resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
			
			if ((! isBlankOrNull(resultado)) &&
				(0 == Constantes.CTE_STR_S.compareTo(resultado[0].getString(Constantes.CTE_COD_CONS_PERM_SAL_TIENE_PERM))))
			{
				tienePermisos = true;
			}
		}
		
		return tienePermisos;
	}
	
	
	
	
	
	
	public static boolean esBONuevo()
	{
		boolean tienePermisos = false;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		String usuario = comprobarDatoNull(contextoEjecucion.getUsuario());
		String oficina = comprobarDatoNull(contextoEjecucion.getOficina());
		
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		
		
		/*Llamamos al CGAL_362 consultando por oficina*/
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_APLIC_CGAL,
			Constantes.CTE_COD_CONS_PERMISOS);
		
		datosEntrada.addCampo(0, Constantes.CTE_COD_CONS_PERM_ID_APL);
		datosEntrada.addCampo(1, Constantes.CTE_COD_CONS_PERM_TIPO_ENT_NEW);
		datosEntrada.addCampo(2, Constantes.CTE_COD_CONS_PERM_TIPO_ENT);
		datosEntrada.addCampo(3, oficina);
		datosEntrada.addCampo(4, usuario);
		
		resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
		
		if ((! isBlankOrNull(resultado)) &&
			(0 == Constantes.CTE_STR_S.compareTo(resultado[0].getString(Constantes.CTE_COD_CONS_PERM_SAL_TIENE_PERM))))
		{
			tienePermisos = true;
		}
		return tienePermisos;
	}
	
	
	
	
	
	/**
	 * Método que obtiene la fecha de alta del expediente, recibe los datos del
	 * servicio EEXP_272
	 * 
	 * 
	 * @param nuc
	 * @return
	 */
	public static java.sql.Date obtenerFechaAltaExpediente(BigDecimal nuc)
	{
		java.sql.Date fechaAlta = null;
		String fechaAltaStr = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CC,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CO);
		
		datosEntrada.addCampo(0, nuc);
		
		resultado = ServicioNegocio.invocarServicio(
			contextoEjecucion, datosEntrada);
		
		
		if (! UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			fechaAltaStr = UtilidadesTramitacion.comprobarDatoNull(
				resultado[0].getString(Constantes.CTE_SN_CONSULTA_EXPEDIENTE_SAL_FECHA_ALTA));
		}
		
		if (! StringUtils.isBlank(fechaAltaStr))
		{
			fechaAlta = DateHelper.stringASqlDate(fechaAltaStr, DateHelper.FORMATO_YYYYMMDD);
		}
		
		return fechaAlta;
	}
	
	
	/**
	 * Obtiene los datos de un expediente llamando al servicio EEXP_272.
	 * 
	 * @param nuc NUC para el que se obtendran los datos del expediente.
	 * @return array de contextos con un contexto EE273CON que contendra los datos
	 *         del expediente.
	 */
	public static IContexto[] obtenerDatosExpediente(BigDecimal nuc)
	{
		// Inicializaciones
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
	
		// Rellenar campos de entrada
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CC,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CO);
		
		datosEntrada.addCampo(0, nuc);
		
		// Llamada EEXP_272
		resultado = ServicioNegocio.invocarServicio(
			contextoEjecucion, datosEntrada);
		
		// Devolver resultado
		return resultado;
	}	
	
	
	/**
	 * Método que obtiene la oficina contable de un expediente de las tablas de EEXP, 
	 * recibe los datos del servicio EEXP_272 
	 * 
	 * @param nuc
	 * @return
	 */
	public static BigDecimal obtenerOficinaContableEEXP(BigDecimal nuc)
	{
		BigDecimal oficinaContable = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CC,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CO);
		
		datosEntrada.addCampo(0, nuc);
		
		resultado = ServicioNegocio.invocarServicio(
			contextoEjecucion, datosEntrada);
		
		
		if (! UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			oficinaContable = resultado[0].getBigDecimal(Constantes.
					CTE_SN_CONSULTA_EXPEDIENTE_SAL_CENTRO_TRAMITADOR);
		}
		
		return oficinaContable;
	}	

	
	/**
	 * Método que obtiene el tipo de prescriptor de un expediente, a partir de la salida
	 * del servicio EEXP_272. 
	 * 
	 * @param salidaEEXP272 salida del servicio EEXP_272 (array de contextos EE273CON).
	 * @return tipo de prescriptor del expediente.
	 */
	public static BigDecimal obtenerOficinaContableEEXP(IContexto[] salidaEEXP272)
	{
		BigDecimal oficinaContable = null;
		
		if (! UtilidadesTramitacion.isBlankOrNull(salidaEEXP272))
		{
			oficinaContable = salidaEEXP272[0].getBigDecimal(Constantes.
					CTE_SN_CONSULTA_EXPEDIENTE_SAL_CENTRO_TRAMITADOR);
		}
		
		return oficinaContable;
	}		
	
	
	/**
	 * Método que obtiene la oficina contable de un expediente de las tablas de EEXP, 
	 * recibe los datos del servicio EEXP_272.
	 * 
	 * @param nuc
	 * @return
	 */
	public static String obtenerTipoPrescriptorEEXP(BigDecimal nuc)
	{
		String tipoPrescriptor = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultado = null;
		
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CC,
			Constantes.CTE_SN_CONSULTA_EXPEDIENTE_CO);
		
		datosEntrada.addCampo(0, nuc);
		
		resultado = ServicioNegocio.invocarServicio(
			contextoEjecucion, datosEntrada);
		
		
		if (! UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			tipoPrescriptor = resultado[0].getString(Constantes.CTE_SN_CONSULTA_EXPEDIENTE_SAL_TIPO_PRESCRIPTOR);
			
			tipoPrescriptor = UtilidadesComun.comprobarDatoNull(tipoPrescriptor);
		}
		
		return tipoPrescriptor;
	}	
	
	
	/**
	 * Método que obtiene el tipo de prescriptor de un expediente, a partir de la salida
	 * del servicio EEXP_272. 
	 * 
	 * @param salidaEEXP272 salida del servicio EEXP_272 (array de contextos EE273CON).
	 * @return tipo de prescriptor del expediente.
	 */
	public static String obtenerTipoPrescriptorEEXP(IContexto[] salidaEEXP272)
	{
		String tipoPrescriptor = null;
		
		if (! UtilidadesTramitacion.isBlankOrNull(salidaEEXP272))
		{
			tipoPrescriptor = salidaEEXP272[0].getString(Constantes.CTE_SN_CONSULTA_EXPEDIENTE_SAL_TIPO_PRESCRIPTOR);
			tipoPrescriptor = UtilidadesComun.comprobarDatoNull(tipoPrescriptor);
		}
		
		return tipoPrescriptor;
	}	
	
	
	/**
	 * Traducimos el tipo prescriptor de la nomenclatura EEXP a la nomenclatura ANPM.
	 * 
	 * @return
	 */
	public static BigDecimal traducirTipoPrescriptor(String tipoPrescriptorEEXP)
	{
		BigDecimal tipoPrescriptorANPM = null;
		
		if (Constantes.CTE_TIPO_PRESCR_EEXP_OFICINA.equals(tipoPrescriptorEEXP))
		{
			tipoPrescriptorANPM = Constantes.CTE_TIPO_PRESCR_ANPM_OFICINA;
		}
		else if (Constantes.CTE_TIPO_PRESCR_EEXP_PYMES.equals(tipoPrescriptorEEXP))
		{
			tipoPrescriptorANPM = Constantes.CTE_TIPO_PRESCR_ANPM_PYMES;
		}
		else if (Constantes.CTE_TIPO_PRESCR_EEXP_EXTERNO.equals(tipoPrescriptorEEXP))
		{
			tipoPrescriptorANPM = Constantes.CTE_TIPO_PRESCR_ANPM_EXTERNO;
		}
		else if (Constantes.CTE_TIPO_PRESCR_EEXP_WEB.equals(tipoPrescriptorEEXP))
		{
			tipoPrescriptorANPM = Constantes.CTE_TIPO_PRESCR_ANPM_WEB;
		}
		else
		{
			tipoPrescriptorANPM = ConstantesComun.CTE_BID_0;
		}
		
		return tipoPrescriptorANPM;
	}
	
	
	/**
	 * Este metodo consulta el prescriptor por nuc
	 * @param nuc
	 * @return
	 */
	public static Integer consultarPrescriptor(BigDecimal nuc){
		
		BigDecimal prescriptor = null;
		
		IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_PRESCRIPTOR,
				IConstantesTramitacion.CTE_CO_CONSULTA_PRESCRIPTOR);
		
		//Anahdimnos el campo de entrada del nuc
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_CONSULTA_PRESCRIPTOR_NUC, nuc);
		
		//Invocar el srv
		IContexto[] salidaConsultaPrescriptor = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
		
		prescriptor = salidaConsultaPrescriptor[0].getBigDecimal(IConstantesTramitacion.CTE_CPO_SALIDA_CONSULTA_PRESCRIPTOR);
		
		return prescriptor.intValue();
	}
	
		/**
	 * Este metodo consulta el prescriptor por nuc
	 * @param nuc
	 * @return
	 */
	public static IContexto[] compruebaRelacionPrescriptorProducto(BigDecimal idProducto,BigDecimal idPrescriptor,BigDecimal idSubproducto,BigDecimal idTarifa){
		
		IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_RELACION_PRESCRIPTOR_PRODUCTO,
				IConstantesTramitacion.CTE_CO_CONSULTA_RELACION_PRESCRIPTOR_PRODUCTO);
		
		//Anahdimnos el campo de entrada del nuc
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_RELACION_PRESCRIPTOR_PRODUCTO_IDPROD, idProducto);
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_RELACION_PRESCRIPTOR_PRODUCTO_IDPRESCRIPTOR, idPrescriptor);
		
		if (null != idSubproducto)
		{
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_RELACION_PRESCRIPTOR_PRODUCTO_IDSUBPRODUCTO, idSubproducto);
		}
		
		if (null != idTarifa)
		{
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_RELACION_PRESCRIPTOR_PRODUCTO_IDTARIFA, idTarifa);
		}
		
		//Invocar el srv
		IContexto[] salidaConsultaPrescriptor = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
		
		return salidaConsultaPrescriptor;
	}
	
		/**
	 * Filtramos los productos que coincidenc on el perscriptor.
	 * @param listaProd
	 * @param codPrescriptor
	 * @return
	 */
	public static boolean esPrescriptorValido(BigDecimal nuc, Integer idProducto,Integer idSubproducto,BigDecimal prescriptorSolicitud,BigDecimal idTarifa)
	{
		
		boolean esValido = true;
		
		// Consultamos el codigo de prescriptor para el nuc correspondiente.
		//Integer codigoPrescriptor = UtilidadesTramitacion.consultarPrescriptor(nuc).intValue();
		
		// 20151006 Tampoco aplica el tipo prescriptor externo cuando es = 9.
		// Es decir, esto solo aplica cuando tipo prescriptor = 2, externo.
		if ((prescriptorSolicitud != null) &&
			(prescriptorSolicitud.intValue() != 0) &&
			(0 != Constantes.CTE_TIPO_PRESCRIPTOR_WEB.compareTo(prescriptorSolicitud)))
		{
			//El prescriptor es por defecto no valido al ser distinto de cero
			esValido = false;	
						
		 	// Si el codigo de prescriptor es 0, no aplica.Devolvemos todos los posibles productos.
			BigDecimal bidCodigoProducto = new BigDecimal(idProducto);
		
			// Objeto que reconocera los subproductos relacionados
			IContexto[] subproductosRelacionadosList = null;
		
			 // Tenemos el codigo del prescriptor y el codigo del producto y con ello 
			//  obtenemos los subproductos validos
			subproductosRelacionadosList =  UtilidadesTramitacion.compruebaRelacionPrescriptorProducto(
					bidCodigoProducto, obtenerTipoPrescriptor(nuc),new BigDecimal(idSubproducto),idTarifa);
		
			// Si el subproducto que estoy contratando esta entre los subproductos posibles 
			// contratables para ese prescriptor entonces es un prescriptor valido
			for(IContexto subproductoRelacionadoContexto : subproductosRelacionadosList) 
			{
				Integer codigoSubproductoRelacionado = subproductoRelacionadoContexto.
						getBigDecimal(Constantes.CTE_CTX_SUBPRODUCTO).intValue();
			
				if(!UtilidadesTramitacion.isBlankOrNull(idSubproducto) && 
						idSubproducto.equals(codigoSubproductoRelacionado)) 
				{
							esValido = true;
				}		
			}	
		}
			
		return esValido;
	}
	
	
	/**
	 * Para obtener el prescriptor invocamos el CGAL_316 y comparamos el prescriptor con los 
	 * que haya establecidos en el grupo de configuración ANPMCFG_PRESCRIPTOR.
	 * @param nucExpediente
	 * @return
	 */
	public static BigDecimal obtenerTipoPrescriptor(BigDecimal nucExpediente)
	{
		IDatosEntradaTx datosEntradaConsultaNuc = null;
		IContexto[] resultadoConsultaNuc = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		//BigDecimal indPrescriptor = Constantes.CTE_IND_PRESCRIPTOR_NA;
		
		BigDecimal clavePrescriptor = null;
		
		datosEntradaConsultaNuc = ServicioNegocio.getPrograma(
			contextoEjecucion,
			IConstantesTramitacion.CTE_SN_CONSULTA_NUC_CC,
			IConstantesTramitacion.CTE_SN_CONSULTA_NUC_CO);
		//datosEntradaConsultaNuc.addCampo(0, Constantes.CTE_ANPM);
		datosEntradaConsultaNuc.addCampo(1, nucExpediente);
		
		resultadoConsultaNuc = ServicioNegocio.invocarServicio(
			contextoEjecucion, datosEntradaConsultaNuc);
		
		if (UtilidadesTramitacion.isBlankOrNull(resultadoConsultaNuc))
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_CONSULTA_NUC_NO_CTX,
				null,
				new String[] {nucExpediente.toString()},
				null);
		}
		else if (0 == Constantes.CTE_BID_100.compareTo(
			resultadoConsultaNuc[0].getBigDecimal(IConstantesTramitacion.CTE_SN_CONSULTA_NUC_SAL_COD_ERR)))
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_CONSULTA_NUC_NO_EXISTE,
				null,
				new String[] {nucExpediente.toString()},
				null);
		}
		else if (0 != BigDecimal.ZERO.compareTo(
			resultadoConsultaNuc[0].getBigDecimal(IConstantesTramitacion.CTE_SN_CONSULTA_NUC_SAL_COD_ERR)))
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_CONSULTA_NUC,
				null,
				new String[] {nucExpediente.toString()},
				null);
		}
		else
		{
			clavePrescriptor = resultadoConsultaNuc[0].getBigDecimal(IConstantesTramitacion.CTE_SN_CONSULTA_NUC_SAL_CLAVE_PRESCR);
		}
		
		return clavePrescriptor;
	}
	
	
//	/**
//	 * Obtiene la clave de prescriptor para un NUC, llamando al servicio CGAL_316.
//	 * 
//	 * @param nuc NUC para el que se obtendra la clave de prescriptor.
//	 * @return clave de prescriptor para el NUC indicado en la entrada.
//	 */
//	public static BigDecimal obtenerClavePrescriptor(BigDecimal nucExpediente)
//	{
//		// Inicializaciones
//		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
//		BigDecimal clavePrescriptor = null;
//		
//		// Parametros de entrada
//		IDatosEntradaTx datosEntradaCGAL316 = ServicioNegocio.getPrograma(
//				contextoEjecucion, 
//				IConstantesTramitacion.CTE_SN_CONSULTA_NUC_CC,
//				IConstantesTramitacion.CTE_SN_CONSULTA_NUC_CO);
//		
//		datosEntradaCGAL316.addCampo(1, nucExpediente);
//		
//		// Llamada CGAL_316
//		IContexto[] salidaCGAL316 = ServicioNegocio.invocarServicio(
//				contextoEjecucion, datosEntradaCGAL316);
//		
//		// Si hay resultados y no hay error, devolver la clave de prescriptor
//		if ((null != salidaCGAL316) && (0 < salidaCGAL316.length))
//		{
//			IContexto ctx = salidaCGAL316[0];
//			
//			// Comprobar errores
//			BigDecimal codError = ctx.getBigDecimal(IConstantesTramitacion.
//					CTE_SN_CONSULTA_NUC_SAL_COD_ERR);
//			
//			if (0 == codError.compareTo(Constantes.CTE_BID_100))
//			{
//				// Codigo error = 100: el NUC no existe
//				ServicioNegocio.rollback(
//						CodigosError.CTE_ERROR_CONSULTA_NUC_NO_EXISTE,
//						null,
//						new String[] {nucExpediente.toString()},
//						null);
//			}
//			else
//			{
//				if (0 != codError.compareTo(Constantes.CTE_BID_0))
//				{
//					// Codigo error != 0: otros errores
//					ServicioNegocio.rollback(
//							CodigosError.CTE_ERROR_CONSULTA_NUC,
//							null,
//							new String[] {nucExpediente.toString()},
//							null);
//				}
//			}
//			
//			// Devolver clave prescriptor
//			clavePrescriptor = ctx.getBigDecimal(IConstantesTramitacion.
//					CTE_SN_CONSULTA_NUC_SAL_CLAVE_PRESCR);
//					
//		}
//		else
//		{
//			// No hay resultados para el NUC
//			ServicioNegocio.rollback(
//					CodigosError.CTE_ERROR_CONSULTA_NUC_NO_CTX,
//					null,
//					new String[] {nucExpediente.toString()},
//					null);
//		}
//		
//		// Devolver clave de prescriptor
//		return clavePrescriptor;
//	}
	
	
	/**
	 * Este metodo consulta el prescriptor por nuc
	 * @param nuc
	 * @return
	 */
	public static IContexto[] compruebaReferenciaNegativaILog(BigDecimal nuc){
		
		IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_REFERENCIA_NEGATIVA_ILOG,
				IConstantesTramitacion.CTE_CO_CONSULTA_REFERENCIA_NEGATIVA_ILOG);
		
		//Anahdimnos el campo de entrada del nuc
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_CONSULTA_REFERENCIA_NUC, nuc);
		
		
		//Invocar el srv
		IContexto[] salidaConsultaReferenciaNegativaILog = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
		
		return salidaConsultaReferenciaNegativaILog;
	}
	
	/**
	 * Procesa y modifica los valores de las condiciones de interés para una posible referencia negativa 
	 * sin invocar a ilog
	 * @return
	 */
	public static List<CondicionesInteresC> procesaDatosReferenciaNegativaNoIlog(BigDecimal nuc,List<CondicionesInteresC> listaCondicionesInteres, Integer codigoErrorDiferencial){
		
		/**
		 * Recuperamos el objeto de datos de solicitud
		 */
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitudC = gds.getUltimaVersionIncompleta(nuc);
		
		/**
		 * Valores de catalogo de los indicadores
		 */
		BigDecimal indicadorSueloInicial = null;
		BigDecimal indicadorSuelo = null;
		
		/**
		 * Recuperamos los valores de catalogo de condiciones de interés
		 */
		IContexto[] salidaCatalogo = recuperaDatosSubproductoCatalogo(datosSolicitudC, 3);
		for(CondicionesInteresC condicionInteres:listaCondicionesInteres) {
			//Recorremos la salida de catalogo para obtener los valores e indicadores que necesitamos
			for(IContexto elementoInteres:salidaCatalogo) {
				//Si es el contexto de techos suelos y diferenciales
				if(elementoInteres.getNombre().equals("ANPMN015")) {
					if(0 == elementoInteres.getBigDecimal("ANPMN015210").compareTo(new BigDecimal(condicionInteres.getIntTipoReferencia()))) {
						//Valor del indicador de suelo
						if(!UtilidadesTramitacion.isBlankOrNull(elementoInteres.getString("ANPMN015260"))) {
							indicadorSuelo = new BigDecimal(elementoInteres.getString("ANPMN015260"));
						}
						//Valor del indicador de suelo inicial
						if(!UtilidadesTramitacion.isBlankOrNull(elementoInteres.getString("ANPMN015350"))) {
							indicadorSueloInicial = new BigDecimal(elementoInteres.getString("ANPMN015350"));
						}
						if(!UtilidadesTramitacion.isBlankOrNull(indicadorSuelo) && !UtilidadesTramitacion.isBlankOrNull(indicadorSueloInicial)) {
							procesarCondicionesInteresConsumidorasNoConsumidoras(condicionInteres, indicadorSuelo, indicadorSueloInicial, nuc, codigoErrorDiferencial);
						}
					}
				}
			}
		}

		return listaCondicionesInteres;
	}
	
	/**
	 * Procesa y modifica los valores de las condiciones de interés para una posible referencia negativa 
	 * sin invocar a ilog
	 * @return
	 */
	public static List<CondicionesInteresC> procesaDatosReferenciaNegativaNoIlog(BigDecimal nuc,List<CondicionesInteresC> listaCondicionesInteres){
		
		/**
		 * Recuperamos el objeto de datos de solicitud
		 */
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitudC = gds.getUltimaVersionIncompleta(nuc);
		
		/**
		 * Valores de catalogo de los indicadores
		 */
		BigDecimal indicadorSueloInicial = null;
		BigDecimal indicadorSuelo = null;
		
		/**
		 * Recuperamos los valores de catalogo de condiciones de interés
		 */
		IContexto[] salidaCatalogo = recuperaDatosSubproductoCatalogo(datosSolicitudC, 3);
		for(CondicionesInteresC condicionInteres:listaCondicionesInteres) {
			//Recorremos la salida de catalogo para obtener los valores e indicadores que necesitamos
			for(IContexto elementoInteres:salidaCatalogo) {
				//Si es el contexto de techos suelos y diferenciales
				if(elementoInteres.getNombre().equals("ANPMN015")) {
					if(0 == elementoInteres.getBigDecimal("ANPMN015210").compareTo(new BigDecimal(condicionInteres.getIntTipoReferencia()))) {
						//Valor del indicador de suelo
						if(!UtilidadesTramitacion.isBlankOrNull(elementoInteres.getString("ANPMN015260"))) {
							indicadorSuelo = new BigDecimal(elementoInteres.getString("ANPMN015260"));
						}
						//Valor del indicador de suelo inicial
						if(!UtilidadesTramitacion.isBlankOrNull(elementoInteres.getString("ANPMN015350"))) {
							indicadorSueloInicial = new BigDecimal(elementoInteres.getString("ANPMN015350"));
						}
						if(!UtilidadesTramitacion.isBlankOrNull(indicadorSuelo) && !UtilidadesTramitacion.isBlankOrNull(indicadorSueloInicial)) {
							procesarCondicionesInteresConsumidorasNoConsumidoras(condicionInteres, indicadorSuelo, indicadorSueloInicial, nuc);
						}
					}
				}
			}
		}

		return listaCondicionesInteres;
	}
	
	/**
	 * Procesa y modifica los valores de las condiciones de interés para una posible referencia negativa 
	 * Metodo sobrecargado para optimización de código
	 * @return
	 */
//	public static List<CondicionesInteresC> procesaDatosReferenciaNegativaNoIlog(DatosSolicitudC datosSolicitudC,List<CondicionesInteresC> listaCondicionesInteres){
//		
//		/**
//		 * Recuperamos el objeto de datos de solicitud
//		 */
//		GestionDatosSolicitud gds = new GestionDatosSolicitud();
//		DatosSolicitudC datosSolicitudC = gds.getUltimaVersionIncompleta(nuc);
//		
//		/**
//		 * Valores de catalogo de los indicadores
//		 */
//		BigDecimal indicadorSueloInicial = null;
//		BigDecimal indicadorSuelo = null;
//		BigDecimal nuc = null;
//		
//		nuc = datosSolicitudC.getDatosSolicitudKey().getNucExpediente();		
//		/**
//		 * Recuperamos los valores de catalogo de condiciones de interés
//		 */
//		IContexto[] salidaCatalogo = recuperaDatosSubproductoCatalogo(datosSolicitudC, 3);
//		for(CondicionesInteresC condicionInteres:listaCondicionesInteres) {
//			//Recorremos la salida de catalogo para obtener los valores e indicadores que necesitamos
//			for(IContexto elementoInteres:salidaCatalogo) {
//				//Si es el contexto de techos suelos y diferenciales
//				if(elementoInteres.getNombre().equals("ANPMN015")) {
//					if(0 == elementoInteres.getBigDecimal("ANPMN015210").compareTo(new BigDecimal(condicionInteres.getIntTipoReferencia()))) {
//						//Valor del indicador de suelo
//						if(!UtilidadesTramitacion.isBlankOrNull(elementoInteres.getString("ANPMN015260"))) {
//							indicadorSuelo = new BigDecimal(elementoInteres.getString("ANPMN015260"));
//						}
//						//Valor del indicador de suelo inicial
//						if(!UtilidadesTramitacion.isBlankOrNull(elementoInteres.getString("ANPMN015350"))) {
//							indicadorSueloInicial = new BigDecimal(elementoInteres.getString("ANPMN015350"));
//						}
//						if(!UtilidadesTramitacion.isBlankOrNull(indicadorSuelo) && !UtilidadesTramitacion.isBlankOrNull(indicadorSueloInicial)) {
//							procesarCondicionesInteresConsumidorasNoConsumidoras(condicionInteres, indicadorSuelo, indicadorSueloInicial, nuc);
//						}
//					}
//				}
//			}
//		}
//
//		return listaCondicionesInteres;
//	}	
//	
	public static void procesarCondicionesInteresConsumidorasNoConsumidoras(CondicionesInteresC condicionInteres,
			BigDecimal indicadorSuelo,BigDecimal indicadorSueloInicial,
			BigDecimal nuc, Integer codigoErrorDiferencial) {
		/**
		 * Si es una persona consumidora 
		 */
		if(UtilidadesTramitacion.esConsumidorNoIlog(nuc).equals(Constantes.CTE_SI_COMPROBACION_S)) {
			if(indicadorSueloInicial.compareTo(BigDecimal.ONE) == 0) {
				procesaCondicionInteresClienteConsumidor(condicionInteres,indicadorSuelo,indicadorSueloInicial);

			}
			//Si el indicador de suelo es distinto de Zero
			if(!(indicadorSuelo.compareTo(BigDecimal.ZERO) == 0)){
				procesaCondicionInteresClienteConsumidor(condicionInteres,indicadorSuelo,indicadorSueloInicial);
			}
			/**
			 * Si es una persona NO Consumidora	(Autonomo o Persona Fisica)
			 */
		}else if(UtilidadesTramitacion.esConsumidorNoIlog(nuc).equals(Constantes.CTE_NO_COMPROBACION_N)) {
			comprobarErrorDiferencial(condicionInteres,nuc,codigoErrorDiferencial);
		}
	}
	
	/**
	 * Procesa las condiciones de interes.
	 * @param condicionInteres
	 * @param indicadorSuelo
	 * @param indicadorSueloInicial
	 * @param nuc
	 */
	public static void procesarCondicionesInteresConsumidorasNoConsumidoras(CondicionesInteresC condicionInteres,
			BigDecimal indicadorSuelo,BigDecimal indicadorSueloInicial,
			BigDecimal nuc) {
		/**
		 * Si es una persona consumidora 
		 */
		if(UtilidadesTramitacion.esConsumidorNoIlog(nuc).equals(Constantes.CTE_SI_COMPROBACION_S)) {
			if(indicadorSueloInicial.compareTo(BigDecimal.ONE) == 0) {
				procesaCondicionInteresClienteConsumidor(condicionInteres,indicadorSuelo,indicadorSueloInicial);

			}
			//Si el indicador de suelo es distinto de Zero
			if(!(indicadorSuelo.compareTo(BigDecimal.ZERO) == 0)){
				procesaCondicionInteresClienteConsumidor(condicionInteres,indicadorSuelo,indicadorSueloInicial);
			}
			/**
			 * Si es una persona NO Consumidora	(Autonomo o Persona Fisica)
			 */
		}else if(UtilidadesTramitacion.esConsumidorNoIlog(nuc).equals(Constantes.CTE_NO_COMPROBACION_N)) {
			comprobarErrorDiferencial(condicionInteres,nuc);
		}
	}
	
	/**
	 * Modifica los valores del primer tramo variable de acuerdo a las normas indicadas para un cliente consumidor
	 * @param condicionesInteres
	 * @param sueloInicial
	 * @param nivelSueloInicial
	 * @param suelo
	 * @param nivelSuelo
	 */
	public static CondicionesInteresC procesaCondicionInteresClienteConsumidor(CondicionesInteresC condicionInteres,
			BigDecimal indicadorSuelo,BigDecimal indicadorSueloInicial) {
		
			BigDecimal suelo = BigDecimal.ZERO;
			BigDecimal nivelSuelo = BigDecimal.ZERO;
			BigDecimal sueloInicial = BigDecimal.ZERO;
			BigDecimal nivelSueloInicial = BigDecimal.ZERO;

		
				if (Constantes.TIPO_INT_VARIABLE.equals(condicionInteres.getStrTipoDeInteres()) ||
						Constantes.TIPO_INT_VAR_BONIF.equals(condicionInteres.getStrTipoDeInteres()) ||
						Constantes.TIPO_INT_VAR_PENAL.equals(condicionInteres.getStrTipoDeInteres()) ||
						Constantes.TIPO_INT_VAR_DIF_BONIF.equals(condicionInteres.getStrTipoDeInteres()))
				{
					if(null!=condicionInteres) {
						if(indicadorSueloInicial.compareTo(BigDecimal.ONE) == 0) {
							sueloInicial = BigDecimal.ZERO;
							indicadorSueloInicial = BigDecimal.ZERO;
							condicionInteres.setIntSueloInteresInicial(sueloInicial);
							condicionInteres.setIntNivelSueloInteresInicial(nivelSueloInicial.intValue());
						}
						
						if(!(indicadorSuelo.compareTo(BigDecimal.ZERO) == 0)){
							suelo = BigDecimal.ZERO;
							nivelSuelo = BigDecimal.ZERO;
							condicionInteres.setIntSuelo(suelo);
							condicionInteres.setIntNivelSuelo(nivelSuelo.intValue());
						}
					}
				}
		

		return condicionInteres;
	}

	
	/**
	 * Comprueba que el diferencial no sea menor que el suelo o menor que el suelo incial
	 * @param condicionInteres
	 * @param nuc
	 * @param codigoErrorDiferencial
	 */
	public static void comprobarErrorDiferencial(CondicionesInteresC condicionInteres,BigDecimal nuc, Integer codigoErrorDiferencial) {
		//Si el diferencial es menor que el suelo inicial
		// OR
		//Si el diferencial es menor que el suelo

		if (Constantes.TIPO_INT_VARIABLE.equals(condicionInteres.getStrTipoDeInteres()) ||
				Constantes.TIPO_INT_VAR_BONIF.equals(condicionInteres.getStrTipoDeInteres()) ||
				Constantes.TIPO_INT_VAR_PENAL.equals(condicionInteres.getStrTipoDeInteres()) ||
				Constantes.TIPO_INT_VAR_DIF_BONIF.equals(condicionInteres.getStrTipoDeInteres()))
		{
			if(null!=condicionInteres) 
			{
				if((condicionInteres.getIntDif().compareTo(condicionInteres.getIntSueloInteresInicial()) > 0) || (
						condicionInteres.getIntDif().compareTo(condicionInteres.getIntSuelo()) > 0))
				{
					//Se setea el código de error a 1 cuando el suelo es menor que el diferencial
					CondicionesInteresAltaSrv.codigoErrorDiferencial = new Integer(1);	
				}
				else if(0 == condicionInteres.getIntSuelo().compareTo(BigDecimal.ZERO)) 
				{
					//Se setea el código de error a 2 cuando el suelo tiene valor 0 para ese cliente
					CondicionesInteresAltaSrv.codigoErrorDiferencial = new Integer(2);				
				}
				else 
				{
					//si no hay error se setea el código a 0
					CondicionesInteresAltaSrv.codigoErrorDiferencial = new Integer(0);
				}
			}
		}
	}
	
	
	/**
	 * Comprueba que el diferencial no sea menor que el suelo o menor que el suelo incial
	 * @param condicionInteres
	 * @param nuc
	 */
	public static void comprobarErrorDiferencial(CondicionesInteresC condicionInteres,BigDecimal nuc) {
		//Si el diferencial es menor que el suelo inicial
		// OR
		//Si el diferencial es menor que el suelo

		if (Constantes.TIPO_INT_VARIABLE.equals(condicionInteres.getStrTipoDeInteres()) ||
				Constantes.TIPO_INT_VAR_BONIF.equals(condicionInteres.getStrTipoDeInteres()) ||
				Constantes.TIPO_INT_VAR_PENAL.equals(condicionInteres.getStrTipoDeInteres()) ||
				Constantes.TIPO_INT_VAR_DIF_BONIF.equals(condicionInteres.getStrTipoDeInteres()))
		{
			if(null!=condicionInteres) 
			{
				if((condicionInteres.getIntDif().compareTo(condicionInteres.getIntSueloInteresInicial()) > 0) || (
						condicionInteres.getIntDif().compareTo(condicionInteres.getIntSuelo()) > 0))
				{
					//Si se da alguna de estas precondiciones le mostramos un error al usuario
					ServicioNegocio.rollback(
							CodigosError.CTE_ERROR_DIFERENCIAL_TIPO_REFERENCIA,
							null,
							new String[] {nuc.toString()},
							null);
					
				}
				else if(0 == condicionInteres.getIntSuelo().compareTo(BigDecimal.ZERO)) 
				{
					//Si se da alguna de estas precondiciones le mostramos un error al usuario
					ServicioNegocio.rollback(
							CodigosError.CTE_ERROR_DIFERENCIAL_TIPO_REFERENCIA_SUELO,
							null,
							new String[] {nuc.toString()},
							null);
					
				}
			}
		}
	}
	
	
	
	
	
	
	/**
	 * Procesa el contexto resultate de ilog, manipulando los datos de salida
	 * segun el cumplimiento de las reglas de negocio
	 */
	public static List<CondicionesInteresC> procesaDatosReferenciaNegativa(BigDecimal nuc,List<CondicionesInteresC> listaIntereses) {

		//IContexto[] salidaReferenciaNegativaIlog = compruebaReferenciaNegativaILog(nuc);
		/**
		 * Obtener el diferencial del primer tramo
		 */
		CondicionesInteresC condicionInteres = getPrimerVariable(listaIntereses);

		if(null != condicionInteres) {
			IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
					IConstantesTramitacion.CTE_CC_CONSULTA_REFERENCIA_NEGATIVA_ILOG,
					IConstantesTramitacion.CTE_CO_CONSULTA_REFERENCIA_NEGATIVA_ILOG);

			//Anahdimnos el campo de entrada del nuc
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_CONSULTA_REFERENCIA_NUC, nuc);
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_CONSULTA_REFERENCIA_DIFERENCIAL, condicionInteres.getIntDif());
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_CONSULTA_REFERENCIA_SUELO, condicionInteres.getIntSuelo());
			datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_CONSULTA_REFERENCIA_SUELO_INICIAL,condicionInteres.getIntSueloInteresInicial());


			//Invocar el srv
			IContexto[] salidaReferenciaNegativaIlog = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);

			BigDecimal suelo = BigDecimal.ZERO;
			BigDecimal nivelSuelo = BigDecimal.ZERO;
			BigDecimal sueloInicial = BigDecimal.ZERO;
			BigDecimal nivelSueloInicial = BigDecimal.ZERO;

			if(null != salidaReferenciaNegativaIlog) {
				if (Constantes.CTE_NO_COMPROBACION_N.equals(
						salidaReferenciaNegativaIlog[0].getString(IConstantesTramitacion.CTE_CTX_ANPMN080_CONSUMIDOR_SN)) &&
						Constantes.CTE_SI_COMPROBACION_S.equals(
								salidaReferenciaNegativaIlog[0].getString(IConstantesTramitacion.CTE_CTX_ANPMN080_ERROR_SN)))
				{
					ServicioNegocio.rollback(
							CodigosError.CTE_ERROR_DIFERENCIAL_TIPO_REFERENCIA,
							null,
							new String[] {nuc.toString()},
							null);
				}else

					/**
					 * Si el cliente es consumidor
					 */
					if(Constantes.CTE_NO_COMPROBACION_N.equals(
							salidaReferenciaNegativaIlog[0].getString(IConstantesTramitacion.CTE_CTX_ANPMN080_ERROR_SN)) &&
							Constantes.CTE_SI_COMPROBACION_S.equals(
									salidaReferenciaNegativaIlog[0].getString(IConstantesTramitacion.CTE_CTX_ANPMN080_CONSUMIDOR_SN))) {

						suelo = salidaReferenciaNegativaIlog[0].getBigDecimal(IConstantesTramitacion.CTE_CTX_ANPMN080_SUELO);
						nivelSuelo = salidaReferenciaNegativaIlog[0].getBigDecimal(IConstantesTramitacion.CTE_CTX_ANPMN080_NIVEL_SUELO);
						sueloInicial = salidaReferenciaNegativaIlog[0].getBigDecimal(IConstantesTramitacion.CTE_CTX_ANPMN080_SUELO_INICIAL);
						nivelSueloInicial = salidaReferenciaNegativaIlog[0].getBigDecimal(IConstantesTramitacion.CTE_CTX_ANPMN080_NIVEL_SUELO_INICIAL);


						CondicionesInteresC condicionInteresC = getPrimerVariable(listaIntereses);
						if(null!=condicionInteresC) {
							/**Si distinto de nulo y mayor o igual a Zero**/
							if(!UtilidadesTramitacion.isBlankOrNull(suelo) && 
									(suelo.compareTo(BigDecimal.ZERO) == 1 || suelo.compareTo(BigDecimal.ZERO)== 0)) {
								condicionInteresC.setIntSuelo(suelo);
							}
							if(!UtilidadesTramitacion.isBlankOrNull(sueloInicial) && 
									(sueloInicial.compareTo(BigDecimal.ZERO) == 1 || sueloInicial.compareTo(BigDecimal.ZERO)== 0)) {
								condicionInteresC.setIntSueloInteresInicial(sueloInicial);
							}
							if(!UtilidadesTramitacion.isBlankOrNull(nivelSuelo) && 
									(nivelSuelo.compareTo(BigDecimal.ZERO) == 1 || nivelSuelo.compareTo(BigDecimal.ZERO)== 0)) {
								condicionInteresC.setIntNivelSuelo(nivelSuelo.intValue());
							}
							if(!UtilidadesTramitacion.isBlankOrNull(nivelSueloInicial) && 
									(nivelSueloInicial.compareTo(BigDecimal.ZERO) == 1 || nivelSueloInicial.compareTo(BigDecimal.ZERO)== 0)) {
								condicionInteresC.setIntNivelSueloInteresInicial(nivelSueloInicial.intValue());
							}	




						}
					}
			}
		}


		return listaIntereses;
	}

	
	/**
	 * Obtiene el primer tramo de interés variable
	 * @return
	 */
	public static CondicionesInteresC getPrimerVariable(List<CondicionesInteresC> listaCondicionesInteres) {
		
		for(CondicionesInteresC condicionInteres:listaCondicionesInteres) {
			if(condicionInteres.getCondicionesInteresKey().getIntOrdenDelTramo().equals(new Integer(1))) {
				if (Constantes.TIPO_INT_VARIABLE.equals(condicionInteres.getStrTipoDeInteres()) ||
						Constantes.TIPO_INT_VAR_BONIF.equals(condicionInteres.getStrTipoDeInteres()) ||
						Constantes.TIPO_INT_VAR_PENAL.equals(condicionInteres.getStrTipoDeInteres()) ||
						Constantes.TIPO_INT_VAR_DIF_BONIF.equals(condicionInteres.getStrTipoDeInteres()))
				{
					return condicionInteres;
				}
			}
		}
		
		return null;
	}

	/**
	 * Devuelve si está permitida la operacion con el control de operatoria
	 * @param nuc
	 * @param codigoOperatoria
	 * @param invertirSalidaLogica, este parametro cuando es verdadero invierte la salida logica, es decir si sale un S lo convierte en N
	 * y vicebersa. Esto es necesario por ejemplo en el caso de la demora.
	 * @return
	 */
	public static boolean comprobarControlOperatoria(BigDecimal nuc,BigDecimal codigoOperatoria,boolean invertirSalidaLogica){
		
		Boolean operacionPermitida = false;
		
		IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_CONTROL_OPERATORIA,
				IConstantesTramitacion.CTE_CO_CONSULTA_CONTROL_OPERATORIA);
		
		//Anahdimnos el campo de entrada del nuc
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CMPO_ENTRADA_CUENTA_CONTABLE,new BigDecimal(502));
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CMPO_ENTRADA_NUC,nuc);
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CMPO_ENTRADA_COD_OPERACION,codigoOperatoria);
		
		//Invocar el srv
		IContexto[] salidaControlOperatoria = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
		if(null != salidaControlOperatoria) {
				if(	Constantes.CTE_SI_COMPROBACION_S.equals(salidaControlOperatoria[0].getString(IConstantesTramitacion.CTE_CTX_SALIDA_CONTROL_OPERATORIA_PERMITIDO_PTMON012010))) {
					operacionPermitida = true;
				}else {
					operacionPermitida = false;
				}
		}	
		
		/**
		 * Se invierte la logica de salida para el caso de la demora
		 */
		if(invertirSalidaLogica) {
			operacionPermitida = !operacionPermitida;
		}
		
		
		return operacionPermitida;
	}
	
	/**
	 * Este método permite pasarle un nuc y los numeros de operatoria y se encarga de construir un contexto
	 * válido para llamar a control de operatoria con varios codigos de operatoria
	 * 
	 * @param nuc
	 * @param lista con códigos de operatoria
	 * @return
	 * 
	 */
	public static void formarControlPreOperatoria( BigDecimal nuc, int codigoOperacion, ArrayList<BigDecimal> codigosOperatoria)
	{
		IContexto PTMON015 = ContextoFactory.getInstance().getContexto("PTMON015");
		IRegistro [] reg = new IRegistro [codigosOperatoria.size()];
		
			for(int i = 0; i < codigosOperatoria.size(); i++)
			{
				IRegistro  registro = ContextoFactory.getInstance().getRegistro(PTMON015, "PTMON015010");
						
				registro.put("PTMON015011", nuc);
				registro.put("PTMON015012",  codigosOperatoria.get(i));
				registro.put("PTMON015013", new BigDecimal(codigoOperacion));
				
				reg[i] = registro;
			}
			
		 PTMON015.put("PTMON015010", reg);	
		 comprobarControlOperatoria(nuc, new BigDecimal(codigoOperacion),  PTMON015);
	}
	
	/**
	 * Devuelve si está permitida la operacion con el control de operatoria para una contexto pasadO por parámetro 
	 * Este método es una sobrecarga del metodo ya existente comprobarControlOperatoria. Cambian los parámetros 
	 * de entrada y el parámetro que devuelve.
	 * 
	 * @param contexto con los diferentes nuc y códigos de operación
	 * @return contexto con los códigos de operatoria
	 *
	 */
	
	public static IContexto [] comprobarControlOperatoria(BigDecimal nuc, BigDecimal codigoOperacion,IContexto contextoEntrada){
	
		IContexto[] resultado = null;
		
		IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_CONTROL_OPERATORIA,   //500
				IConstantesTramitacion.CTE_CO_CONSULTA_CONTROL_OPERATORIA);  //129
		
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CMPO_ENTRADA_NUC,nuc);
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CMPO_ENTRADA_COD_OPERACION,codigoOperacion);
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CMPO_ENTRADA_CUENTA_CONTABLE, new BigDecimal(502));
		datosEntradaTx.addCampo(IConstantesTramitacion.CTE_REG_OPERATORIA, contextoEntrada);
		
		//Se invoca el servicio PTMO_129
		IContexto[] salidaControlOperatoria = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
		
		if(null != salidaControlOperatoria) // comprobamos el resultado,  y si no es nulo lo devolvemos
		{
			resultado = salidaControlOperatoria;
		}
		else // control de operatoria no devuelve el contexto con datos
		{
			ServicioNegocio.rollback(CodigosError.CTE_ERROR_LISTA_CONTROL_OPERATORIA, 
		   							  null,
		   							  null,
		   							  null);
		}
		
		return resultado;
	}
	
	/**
	 * Devuelve verdadero si el prestamo tramitado es especialidad divisa
	 * Especialidad = D
	 * @param especialidad
	 * @return
	 */
	public static boolean esDivisaPorEspecialidad(String especialidad) {
		
		boolean esDivisa = false;
		
		if(especialidad.equalsIgnoreCase(Constantes.CTE_ESPECIALIDAD_DIVISA)) {
			esDivisa = true;
		}
		
		return esDivisa;
	}
	
	/**
	 * Comprueba pasandole el nuc de la solicitud la especialidad de la solicitud
	 * @param nuc
	 * @return
	 */
	public static boolean esDivisa(BigDecimal nuc) {
		
		DatosSolicitudC datosSolicitudC = new DatosSolicitudC();
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		boolean esDivisa = false;
	
		datosSolicitudC = gds.getUltimaVersion(nuc);
		
		if(datosSolicitudC.getEspecialidad().equalsIgnoreCase(Constantes.CTE_ESPECIALIDAD_DIVISA)) {
			esDivisa = true;
		}
		
		return esDivisa;
	}
	
			
	/**
	 * Comprueba si es multicredito 48h con el segundo parametro informado comprobará tb el nivel de subproducto,
	 * si esta a nulo solo  comprueba el nivel de producto
	 * @param producto
	 * @return
	 */
	public static BigDecimal consultaParametro(BigDecimal idConcepto) {
		
		BigDecimal numeroPeriodosRestar = BigDecimal.ZERO;
		
		final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(
				ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_PARAMETRO,IConstantesTramitacion.CTE_CO_CONSULTA_PARAMETRO);
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_CAMPO_PARAMETRO, idConcepto.toString());
		datosEntradaConsultaParametro.addCampo(IConstantesTramitacion.NOMBRE_AGRUPACION_PARAMETRO, "GASTOSADIC");
		
		final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
		
		if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0
				&& !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR))) {
				//Si viene informado el campo del subproducto
				numeroPeriodosRestar = new BigDecimal(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR));
				return numeroPeriodosRestar;
		}
		
		return numeroPeriodosRestar;
	}

	/**
	 * Llamada al servicio de negocio ANPM_179, comprueba si un expediente es hipotecario o personal. 
	 * @param solicitud
	 * @param contexto
	 */
	public static String tipoDeExpediente(DatosSolicitudC solicitud) {

		IDatosEntradaTx datosEntradaSrvTipoExpediente = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_TIPO_EXPEDIENTE,IConstantesTramitacion.CTE_CO_CONSULTA_TIPO_EXPEDIENTE);
		datosEntradaSrvTipoExpediente.addCampo(IConstantesTramitacion.CTE_CAMPO_TIPO_EXPEDIENTE,solicitud.getTipoExpediente().toString());

		String hipo = new String();

		IContexto[]	salidaSrvTipoExpediente = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaSrvTipoExpediente);
		if(!UtilidadesTramitacion.isBlankOrNull(salidaSrvTipoExpediente)) {

			hipo = salidaSrvTipoExpediente[0].getString(Constantes.CTE_DATO_ENTRADA_TIPO_EXPEDIENTE);
		}	

		return hipo;
	}


	/**
	 * Devuelve verdadero cuando el expediente que ejecutamos es de un prestamo personal
	 * @return
	 */
	public static boolean esExpedientePersonal(DatosSolicitudC datosSolicitud) {
		boolean esPersonal = false;
		if(tipoDeExpediente(datosSolicitud).equals(Constantes.CTE_COMPROBACION_ES_PERSONAL)) {
			esPersonal = true;
		}
		return esPersonal;
	}

	/**
	 * Devuelve una S o una N
	 * Parametro de configuracion del CGDN: PMOS - Grupos de configuracion
	 * PMOSCFG_SOLICITUD_DEMORA_CONSUMO
	 * 
	 * @return String S/N
	 */
	public static String comprobarDemora() {

		return Configuracion.getInstance().getValor("PMOS", "SOLICITUD", "DEMORA_CONSUMO");

	}
	
	/**
	 * Obtiene el valor de demora, llamando al ANPM_169. Para recuperar ese valor,
	 * hace una consulta sobre la tabla CG32TB01, por los campos CG320010 = 'PAR' AND CG320020 = 'MORC';
	 * @return BigDecimal demora
	 */
	public static BigDecimal recuperaDemora() {
		
		BigDecimal demora = BigDecimal.ZERO;
		
		final IDatosEntradaTx datosEntradaConsultaParametro = ServicioNegocio.getPrograma(
				ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_PARAM,IConstantesTramitacion.CTE_CO_CONSULTA_PARAM);
			datosEntradaConsultaParametro.addCampo("OPERACION","MOR");
		
		
		final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametro);
		
		if(!UtilidadesTramitacion.isBlankOrNull(aContextoParametro) && aContextoParametro.length > 0
				&& !UtilidadesTramitacion.isBlankOrNull(aContextoParametro[0].getString(IConstantesTramitacion.CTE_CAMPO_VAL_PARAM))) {
				//Si viene informado el campo del subproducto
				demora = aContextoParametro[0].getBigDecimal(IConstantesTramitacion.CTXTO_PARAMETROS_CG320090);
				return demora;
		}
		
		return demora;
	}
	
	
//	/**
//	 * Comprueba si el titular del prestamo es consumidor o no consumidor,
//	 * lo hace sin llamar a iLog JRules.
//	 * @param nuc
//	 * @return
//	 */
//	public static String esConsumidorNoIlog(BigDecimal nucSolicitud) {
//		
//		String tipoPersona = Constantes.CADENA_VACIA;
//		GestionDatosSolicitud gds = new GestionDatosSolicitud();
//		DatosSolicitudC datosSolicitud = gds.getUltimaVersion(nucSolicitud);
//		String esConsumidor = "N";
//		
//		IContextoEjecucion contexto = ServicioNegocio.getContexto();
//		
//		/**
//		 * Llamada al servicio de negocio que recupera los datos del cliente a partir del nuc
//		 * FCLI_722
//		 */
//		
//		IDatosEntradaTx datosEntradaSrvParam = ServicioNegocio.getPrograma(contexto, 
//				CTE_CC_CONSULTA_FCLI,CTE_CO_CONSULTA_FCLI_NUC);
//		
//		datosEntradaSrvParam.addCampo(CTE_NUC_SOLICITUD, nucSolicitud);
//
//		IContexto[] salidaSrvParam = ServicioNegocio.invocarServicio(contexto, datosEntradaSrvParam);	
//		
//		if(salidaSrvParam != null && BigDecimal.ZERO.intValue() < salidaSrvParam.length) 
//		{	
//			for(IContexto ctx:salidaSrvParam) 
//			{
//				// Pendiente revisar este bucle (actualmente se queda con el valor del ultimo participante)
//				if(ctx.getString(CTE_TIPO_PERSONA_NR_FCLI722).trim().equals(CTE_TIPO_PERSONA_FISICA_1)) {
//								tipoPersona = "F";
//				}else if(ctx.getString(CTE_TIPO_PERSONA_NR_FCLI722).trim().equals(CTE_TIPO_PERSONA_JURIDICA_0)) {
//								tipoPersona = "J";
//				}
//			}	
//		}
//		
//		if(UtilidadesTramitacion.stringToBigDecimal(datosSolicitud.getDestinoPrincipal().getDestino(), Locale.getDefault()).intValue() > 5021 
//				|| UtilidadesTramitacion.stringToBigDecimal(datosSolicitud.getDestinoPrincipal().getDestino(), Locale.getDefault()).intValue() == 5021
//				&& tipoPersona.equals("F")){
//			esConsumidor = "S";
//		}
//		
//		return esConsumidor;
//	}
	
	/**
	 * Comprueba si el titular del prestamo es consumidor o no consumidor,
	 * lo hace sin llamar a iLog JRules.
	 * @param nuc
	 * @return
	 */
	public static String esConsumidorNoIlog(BigDecimal nucSolicitud) {
		
		String tipoPersona = Constantes.CADENA_VACIA;
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitud = gds.getUltimaVersion(nucSolicitud);
		boolean esComunidadPropietarios = UtilidadesComun.esComunidadPropietarios(nucSolicitud);
		String esConsumidor = "N";
		
		if (esComunidadPropietarios)
		{
			esConsumidor = "S";
		} 
		else 
		{
			BigDecimal sector = datosSolicitud.getSector();
			
			if ((null != sector) && 
				(0 == sector.compareTo(ConstantesComun.CTE_SECTOR_PERSONA_FISICA)))
			{
				// Sector de la solicitud = 10 --> Es persona fisica
				tipoPersona = "F";
			}
			else
			{
				// Sector de la solicitud != 10 --> Es persona juridica
				tipoPersona = "J";
			}
			
			if(UtilidadesTramitacion.stringToBigDecimal(datosSolicitud.getDestinoPrincipal().getDestino(), 
					Locale.getDefault()).intValue() > 5021 || 
				UtilidadesTramitacion.stringToBigDecimal(datosSolicitud.getDestinoPrincipal().getDestino(), 
					Locale.getDefault()).intValue() == 5021 && 
				tipoPersona.equals("F"))
			{
				esConsumidor = "S";
			}
		}
		
		return esConsumidor;
	}

	
	/**
	 * Comprueba si la demora establecida es correcta de lo contrario la modifica por la demora establecida en la CG32TB01
	 * @param nucExpediente
	 * @param listaCondicionesInteres
	 */
	public static void esCorrectaDemora(BigDecimal nucExpediente,List<CondicionesInteresC> listaCondicionesInteres) {
		if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente) && esSolicitudValida(nucExpediente)) {
			if(UtilidadesTramitacion.comprobarControlOperatoria(nucExpediente, new BigDecimal(20000),true)) {
				/**
				 * Recuperamos la ultima versión de la solicitud
				 */
				GestionDatosSolicitud gds = new GestionDatosSolicitud();
				DatosSolicitudC datosSolicitudC = gds.getUltimaVersion(nucExpediente);

				/** 1-Primero comprobamos el parametro de configuracion **/
				if((Constantes.CTE_SI_COMPROBACION_S).equals(UtilidadesTramitacion.comprobarDemora())) {
					/** 2- Comprobar si se trata de un prestamo personal */
					if(UtilidadesTramitacion.esExpedientePersonal(datosSolicitudC)) {
						/** 3 - si es CONSUMIDOR, es decir, persona fisica **/
						String esConsumidor = UtilidadesTramitacion.esConsumidorNoIlog(nucExpediente);
						if((Constantes.CTE_SI_COMPROBACION_S).equals(esConsumidor)) {
							BigDecimal demoraPermitida = recuperaDemora();
							for(CondicionesInteresC condicionInteresC:listaCondicionesInteres) {
								if(condicionInteresC.getIntPorDemoraSobreCapital().compareTo(demoraPermitida) > 0) {
									//Lanzamos un rollBack
									//Sino la impresion continuar normalmente
									//ServicioNegocio.rollback(CodigosError.ERROR_PORCENTAJE_DEMORA_INCORRECTO, null, new String[] {UtilidadesTramitacion.bigDecimalToString(demoraPermitida, 3, 4, true)}, null);
									condicionInteresC.setIntPorDemoraSobreCapital(demoraPermitida);
								}
								if(condicionInteresC.getIntPorDemoraSobreInteres().compareTo(demoraPermitida) > 0) {
									condicionInteresC.setIntPorDemoraSobreInteres(demoraPermitida);
								}
								/**
								 * Si es una persona consumidora el suelo solo puede ser zero.
								 */
								if(0 != condicionInteresC.getIntSuelo().compareTo(BigDecimal.ZERO)) {
									condicionInteresC.setIntSuelo(BigDecimal.ZERO);
								}
							}
						//}else if(esConsumidor.equals(Constantes.CTE_NO_COMPROBACION_N)) {
							//Recuperar los datos del subproducto para el paso 3
							//Si es una persona NO CONSUMIDORA, debemos comprobar que los datos son los que están establecidos en catalogo
							//Recuperamos los valores por defecto y comprobamos
							//for(CondicionesInteresC condicionInteresC:listaCondicionesInteres) {
								//reestablecerValoresCatalogo(nucExpediente, condicionInteresC);
							//}
							
							}
						}
					}
				}
			}
		}
	
	
	/**
	 * Comprueba si una solicitud es valida para operar con ella.
	 * @param bidNuc
	 * @return
	 */
	public static boolean esSolicitudValida(BigDecimal bidNuc) {

		boolean esValida = true;

		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitudC = gds.getUltimaVersion(bidNuc);

		if(null != datosSolicitudC) {
			if(UtilidadesTramitacion.isBlankOrNull(datosSolicitudC.getDatosSolicitudKey().getNucExpediente())
					|| UtilidadesTramitacion.isBlankOrNull(datosSolicitudC.getDatosSolicitudKey().getNumSolicitud())
					|| UtilidadesTramitacion.isBlankOrNull(datosSolicitudC.getDatosSolicitudKey().getOficinaSolicitud())
					|| UtilidadesTramitacion.isBlankOrNull(datosSolicitudC.getDatosSolicitudKey().getVersionSolicitud())) {
				esValida = false;
			}
		}else {
			esValida = false;
		}


		return esValida;
	}
	
	/**
	 * Modifica el valor del indicador de difirimiento.
	 * @param nucExpediente
	 * @param salidaDetalleCatalogo
	 */
	public static IContexto[] modificaIndicadorDiferimiento(IContexto[] salidaDetalleCatalogo) {

		if(!UtilidadesTramitacion.isBlankOrNull(salidaDetalleCatalogo)) {				
			for(IContexto condicionEconomica:salidaDetalleCatalogo) {
				if(null != condicionEconomica
				&& null != condicionEconomica.getNombre()
				&& condicionEconomica.getNombre().equalsIgnoreCase("ANPMN013")) {
					if(!condicionEconomica.getString("ANPMN013350").equals(Constantes.CTE_STR_0)) {
						condicionEconomica.put("ANPMN013350", Constantes.CTE_STR_1);
					}
				}
			}
		}
		return salidaDetalleCatalogo;
	}
	
	/**
	 * Modifica los valores de catalogo del interés de demora cuando se cumplen las condiciones.
	 * @param nucExpediente
	 * @param salidaDetalleCatalogo
	 */
	public static IContexto[] esCorrectaDemoraModificarValoresDetalleCatalogo(BigDecimal nucExpediente,IContexto[] salidaDetalleCatalogo) {

		if(!UtilidadesTramitacion.isBlankOrNull(nucExpediente) && esSolicitudValida(nucExpediente)) {
			if(UtilidadesTramitacion.comprobarControlOperatoria(nucExpediente, new BigDecimal(20000),true)) {
				/**
				 * Recuperamos la ultima versión de la solicitud
				 */
				GestionDatosSolicitud gds = new GestionDatosSolicitud();
				//20151120 Optimización para obtener la versión incompleta usando el indicador de última versión
				DatosSolicitudC datosSolicitudC = gds.getUltimaVersionIncompleta(nucExpediente);
				
				if (null != datosSolicitudC){
					/** 1-Primero comprobamos el parametro de configuracion **/
					if(UtilidadesTramitacion.comprobarDemora().equals(Constantes.CTE_SI_COMPROBACION_S)) {
						/** 2- Comprobar si se trata de un prestamo personal */
						if(UtilidadesTramitacion.esExpedientePersonal(datosSolicitudC)) {
							/** 3 - si es CONSUMIDOR, es decir, persona fisica **/
							String esConsumidor = UtilidadesTramitacion.esConsumidorNoIlog(nucExpediente);
							if(esConsumidor.equals(Constantes.CTE_SI_COMPROBACION_S)) {
								BigDecimal demoraPermitida = recuperaDemora();
								for(IContexto condicionInteres:salidaDetalleCatalogo) {
									if(condicionInteres.getNombre().equalsIgnoreCase("ANPMN014")) {
										if(condicionInteres.getBigDecimal("ANPMN014370").compareTo(demoraPermitida) > 0) {
											//Lanzamos un rollBack
											//Sino la impresion continuar normalmente
											//ServicioNegocio.rollback(CodigosError.ERROR_PORCENTAJE_DEMORA_INCORRECTO, null, new String[] {UtilidadesTramitacion.bigDecimalToString(demoraPermitida, 3, 4, true)}, null);
											condicionInteres.put("ANPMN014370",demoraPermitida);
										}
										if(condicionInteres.getBigDecimal("ANPMN014410").compareTo(demoraPermitida) > 0) {
											condicionInteres.put("ANPMN014410",demoraPermitida);
										}

									}
									/**Si es una persona consumidora por defecto el suelo tiene que ser 0 **/
									if(condicionInteres.getNombre().equalsIgnoreCase("ANPMN015")){
										condicionInteres.put("ANPMN015230",BigDecimal.ZERO);
									}

								}

							}

						}
					}
				}
				else // 24-10-2016 Rollback por solicitud incompleta no recuperada : 
				{
					ServicioNegocio.rollback(
							Constantes.CTE_VERSION_INCOMPLETA_NO_RECUPERADA,
							null,
							null, 
							null
							);
				}
				/**Si es una persona fisica consumidora modificamos el valor del suelo por defecto para que salga en la pantalla de consulta como 0**/
				/**Existe mas abajo una funcion que realiza esta accion comprobando los indicadores para una futura edicion**/
			}
		}


		return salidaDetalleCatalogo;
	}
	
	/**
	 * Modifica el valor del suelo para personas consumidoras en la salida del detalle de catalogo
	 * @param condicionInteres
	 * @param salidaDetalleCatalogo
	 */
	public static IContexto[] modificaSuelosPersonasConsumidorasDefecto(IContexto[] salidaDetalleCatalogo) {
		
		BigDecimal indicadorSuelo = null;
		BigDecimal indicadorSueloInicial = null;
		
		for(IContexto elementoCatalogo:salidaDetalleCatalogo) {
			
				//Valor del indicador de suelo
						if(!UtilidadesTramitacion.isBlankOrNull(elementoCatalogo.getString("ANPMN015260"))) {
							indicadorSuelo = new BigDecimal(elementoCatalogo.getString("ANPMN015260"));
						}
						//Valor del indicador de suelo inicial
						if(!UtilidadesTramitacion.isBlankOrNull(elementoCatalogo.getString("ANPMN015350"))) {
							indicadorSueloInicial = new BigDecimal(elementoCatalogo.getString("ANPMN015350"));
						}
						if(!UtilidadesTramitacion.isBlankOrNull(indicadorSueloInicial) && UtilidadesTramitacion.isBlankOrNull(indicadorSuelo)) {
							/**Si es una persona consumidora por defecto el suelo tiene que ser 0 **/
							if(elementoCatalogo.getNombre().equalsIgnoreCase("ANPMN015")){
								
								if(0 != indicadorSuelo.compareTo(BigDecimal.ZERO)) {
									//Suelo interés inicial
									elementoCatalogo.put("ANPMN015320", BigDecimal.ZERO);
								}
								if(0 == indicadorSuelo.compareTo(BigDecimal.ONE)) {
									//Suelo
									elementoCatalogo.put("ANPMN015230",BigDecimal.ZERO);
								}	
							}
						}
						
		}
		
		return salidaDetalleCatalogo;
	}
	
	/**
	 * Comprueba para una solicitud si el subproducto tramitado tiene tarifa y si la tiene
	 * se asegura de que la tarifa sea distinta de cero.
	 * @param datosSolicitud
	 */
	public static boolean validaTarifaSolicitud(DatosSolicitudC datosSolicitud) {
		
		boolean existeErrorTarifa = false;
		
		IContexto[] detalleCatalogo = recuperaDatosSubproductoCatalogo(datosSolicitud, 9); 
		
		if(detalleCatalogo.length > 0) {
			for(IContexto elementoCatalogo:detalleCatalogo) {
				if(elementoCatalogo.getNombre().equals("ANPMN002")) {
					if(elementoCatalogo.getString("ANPMN002670").equals(Constantes.CTE_STR_1)) {
						if(null == datosSolicitud.getIdTarifa() || 0 == datosSolicitud.getIdTarifa().compareTo(BigDecimal.ZERO)) {
							//Tiene tarifa a nivel de subproducto 
							existeErrorTarifa = true;			
						}	
					}
					
				}
			}
			
		}
		return existeErrorTarifa;
	}

	
	/**
	 * Recupera los datos de un subproducto seleccionado
	 * @param datosSolicitud
	 * @return Devuelve los datos del subproducto
	 */
	public static IContexto[] recuperaDatosSubproductoCatalogo(DatosSolicitudC datosSolicitud, int paso)
	{
		IDatosEntradaTx datosEntradaSrvCatalogo = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 
				IConstantesTramitacion.CTE_CC_CONSULTA_CATALOGO,IConstantesTramitacion.CTE_CO_CONSULTA_CATALOGO);
		datosEntradaSrvCatalogo.addCampo(IConstantesTramitacion.CTE_CAMPO_PRODUCTO, datosSolicitud.getProducto());
		datosEntradaSrvCatalogo.addCampo(IConstantesTramitacion.CTE_CAMPO_SUBPRODUCTO, datosSolicitud.getSubproducto());
		datosEntradaSrvCatalogo.addCampo(IConstantesTramitacion.CTE_CAMPO_NUC_EXPEDIENTE, datosSolicitud.getDatosSolicitudKey().getNucExpediente());
		datosEntradaSrvCatalogo.addCampo(IConstantesTramitacion.CTE_CAMPO_COLECTIVO, datosSolicitud.getLineaColectivo());
		datosEntradaSrvCatalogo.addCampo(IConstantesTramitacion.CTE_CAMPO_VERSIONGENERAL, datosSolicitud.getVersionGeneral());
		datosEntradaSrvCatalogo.addCampo(IConstantesTramitacion.CTE_CAMPO_IND_FILTRARNIVEL, Constantes.SI);
		datosEntradaSrvCatalogo.addCampo(IConstantesTramitacion.CTE_CAMPO_PASO, new BigDecimal(paso));
		
		
		BigDecimal idTarifa = null;
		BigDecimal plazo = null;

		idTarifa = datosSolicitud.getIdTarifa();
		plazo = datosSolicitud.getPlazoTotal();
		/*20150910 Añadimos los campos de tarifa*/
		/*20150910 Si el id tarifa es <> 0 enviamos los campos para obtener los precios de tarifa, los contextos de
		 * interés de catálogo vendrán sobreescritos con los precios.*/
		if (null != idTarifa && 0 != idTarifa.compareTo(BigDecimal.ZERO))
		{
			datosEntradaSrvCatalogo.addCampo("ID_TARIFA", idTarifa);
			datosEntradaSrvCatalogo.addCampo("PLAZO", plazo.toString());
			datosEntradaSrvCatalogo.addCampo("ORIGEN", Constantes.CTE_ORIGEN_CONSULTA_TARIFA_SOLICITUD);
			
		}
		
		IContexto[] salidaSrvCatalogo = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaSrvCatalogo);
		
		return salidaSrvCatalogo;	
	}
	
	/**
	 * Reestablece los valores de catalogo para una condicion de interes
	 * @return
	 */
	public static void reestablecerValoresCatalogo(BigDecimal nuc,CondicionesInteresC condicionInteres) {
		/**
		 * Tenemos que recuperar la ultima version de la solicitud para recuperar los datos de catalogo.
		 */
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitudC = new DatosSolicitudC();
		datosSolicitudC = gds.getUltimaVersion(nuc);

		IContexto[] detalleCatalogo = recuperaDatosSubproductoCatalogo(datosSolicitudC, 3);

		for(IContexto elementoCatalogo:detalleCatalogo) {
			if(elementoCatalogo.getNombre().equalsIgnoreCase("ANPMN014")) {
				if(0 != elementoCatalogo.getBigDecimal("ANPMN014370").compareTo(condicionInteres.getIntPorDemoraSobreCapital())) {
					condicionInteres.setIntPorDemoraSobreCapital(elementoCatalogo.getBigDecimal("ANPMN014370"));
				}
				if(0 != elementoCatalogo.getBigDecimal("ANPMN014410").compareTo(condicionInteres.getIntPorDemoraSobreInteres())) {
					condicionInteres.setIntPorDemoraSobreInteres(elementoCatalogo.getBigDecimal("ANPMN014410"));
				}
			}
			if(elementoCatalogo.getNombre().equalsIgnoreCase("ANPMN015")) {
				//Comprobamos que estamos operando para el mismo el mento por el campo tipo de referencia
				if(0 == elementoCatalogo.getBigDecimal("ANPMN015210").compareTo(new BigDecimal(condicionInteres.getIntTipoReferencia()))) {
					if(0 != elementoCatalogo.getBigDecimal("ANPMN015230").compareTo(condicionInteres.getIntPorDemoraSobreCapital())) {
						condicionInteres.setIntSuelo(elementoCatalogo.getBigDecimal("ANPMN015230"));
					}
				}

			}

		}
	}

	
	/**
	 * Invoca el FCLI_722 para obtener datos de los clientes de ese expediente.
	 * 
	 * @param nuc
	 * @return
	 */
	private static IContexto[] recuperarDatosClientesExpediente(BigDecimal nuc)
	{
		IDatosEntradaTx datosEntrada = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IContexto[] resultado = null;
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CC_CONSULTA_CLIENTES_NUC,
			Constantes.CTE_SN_CO_CONSULTA_CLIENTES_NUC);
		
		datosEntrada.addCampo("NUC", nuc);
		
		resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
		
		if (UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_DATOS_CLIENTE_NUC_NO_TIENE,
				null,
				new String[] {nuc.toString()},
				null);
		}
		return resultado;
	}
	
	/**
	 * recupera la fecha de nacimiento del servicio 555-722 y calcula el numero 
	 * de meses que hay entre la fecha y la actual
	 * @param nuc
	 * @param plazo
	 * @param indicador
	 * @return
	 */
	
	public static BigDecimal recuperarNumeroMeses(BigDecimal nuc, BigDecimal plazo, BigDecimal indicador)
	{
		IDatosEntradaTx datosEntrada = null;
		BigDecimal numeroMeses=new BigDecimal(12);
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IContexto[] resultado = null;
		String fechaNacimiento = null;
		BigDecimal totalSuperar = null;
		BigDecimal total = new BigDecimal(0);
		Calendar c = Calendar.getInstance();
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CC_CONSULTA_CLIENTES_NUC,
			Constantes.CTE_SN_CO_CONSULTA_CLIENTES_NUC);
		
		datosEntrada.addCampo("NUC", nuc);
		ArrayList<BigDecimal> lnums= new ArrayList<BigDecimal>();
		
		resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
		if(!UtilidadesTramitacion.isBlankOrNull(resultado) && resultado.length > 0
				&& !UtilidadesTramitacion.isBlankOrNull(resultado[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_FECHANAC))) {
				
			int anhoActual = c.get(Calendar.YEAR);
			int mesActual = c.get(Calendar.MONTH) + 1;
			
			for(int i=0; i<resultado.length ;i++) 
			{
				lnums.add(new BigDecimal(resultado[i].getString(IConstantesTramitacion.CTXTO_PARAMETRO_FECHANAC)));
				
			}
			//Ordenamos el ArrayList
			Collections.sort(lnums);
			
			//Si el indicador es 2 sacamos la fecha del cliente más viejo
			//Si el indicador es 1 sacamos la fecha del cliente mas joven
			if(indicador.equals(new BigDecimal(2)))
			{
				fechaNacimiento = lnums.get(0).toString();
			}else if (indicador.equals(BigDecimal.ONE))
			{
				fechaNacimiento = lnums.get(lnums.size()-1).toString();
			}else 
			{
				if(mesActual<10)
				{
					fechaNacimiento = new BigDecimal(anhoActual).toString().concat("0").concat(new BigDecimal(mesActual).toString());
				}else 
				{
					fechaNacimiento = new BigDecimal(anhoActual).toString().concat(new BigDecimal(mesActual).toString());
				}
			}
				
				
			int totalActual = (anhoActual*12)+mesActual;
			
			if(fechaNacimiento.length()<6) 
			{
				ServicioNegocio.rollback(
						CodigosError.CTE_ERROR_FECHA_NACIMIENTO,
						null,
						new String[] {},
						null);
			}
			
			BigDecimal año = new BigDecimal(fechaNacimiento.substring(0, 4));
			BigDecimal mesNacimiento = new BigDecimal(fechaNacimiento.substring(4, 6));
			total =((new BigDecimal(totalActual)).subtract(año.multiply(numeroMeses).add(mesNacimiento)));
				
			totalSuperar = total.add(plazo);
		}
		if (UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_DATOS_CLIENTE_NUC_NO_TIENE,
				null,
				new String[] {nuc.toString()},
				null);
		}
		return totalSuperar;
	}
	public static BigDecimal obtenerNumeroClientePrimerTitular(BigDecimal nuc)
	{
		BigDecimal numeroCliente = null;
		IContexto[] resultado = null;
		
		
		resultado = recuperarDatosClientesExpediente(nuc);
		
		for (IContexto contexto : resultado)
		{
			if ((Constantes.CTE_RELACION_TITULAR.equals(contexto.getString(Constantes.CTE_DATOS_CLIENTE_SAL_RELACION))) &&
				(Constantes.CTE_001.equals(contexto.getString(Constantes.CTE_DATOS_CLIENTE_SAL_SECUENCIA_EN_RELACION))))
			{
				numeroCliente = contexto.getBigDecimal(Constantes.CTE_DATOS_CLIENTE_SAL_NUM_CLIENTE);
				break;
			}
		}
		if (null == numeroCliente)
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_DATOS_CLIENTE_NO_HAY_PRIMER_TIT,
				null,
				new String[] {nuc.toString()},
				null);
				
		}
		
		return numeroCliente;
	}
	
	/**
	 * Cuenta los tramos de interes no sustitutivos.
	 * @param listaCondicionesInteres
	 * @return
	 */
	public int cuentaTramosNoSustitutivo(List<CondicionesInteresC> listaCondicionesInteres){

		int tramosNoSustitutivos = 0;

		for(CondicionesInteresC condicion:listaCondicionesInteres){
			if(condicion.getCondicionesInteresKey().getIntTipoCondicion().equals(Constantes.CTE_INT_CERO)){
				tramosNoSustitutivos++;
			}
		}

		return tramosNoSustitutivos;
	}
			
	/**
	 * Recupera el plazo de interés y actualiza el plazo en caso de que este no coincida
	 * tanto el del sustitutivo como el de la condicion principal
	 * @param solicitud
	 * @return
	 */
	public static DatosSolicitudC actualizarPlazoInteres(DatosSolicitudC solicitudExiste, DatosSolicitudC solicitud) {

		//Declaracion de variables para verificar los plazos
		Integer plazoInteresTramoUno = new Integer(0);
		Integer plazoInteresTramoDos = new Integer(0);
		Integer plazoTotalInteres = new Integer(0);
		Integer plazoInteresTramoDosModificado = new Integer(0);
		UtilidadesTramitacion ut = new UtilidadesTramitacion();

		List<CondicionesInteresC> condicionesInteresSolicitud = new ArrayList<CondicionesInteresC>();
		//Recuperamos las condiciones de interes de la solicitud
		if(null != solicitudExiste){
			condicionesInteresSolicitud = solicitudExiste.getCondicionesInteres();

			/**
			 * Validamos previamente que existan condiciones de interes antes de procesarlas
			 */
			if(!UtilidadesTramitacion.isBlankOrNull(condicionesInteresSolicitud)) {
				//Si el numero de tramos es mayor o igual a 3 no podemos cambiar los plazos.
				if(ut.cuentaTramosNoSustitutivo(condicionesInteresSolicitud) < 3){
					/**Comprobar si tiene uno o varios tramos de interés**/
					if(condicionesInteresSolicitud.size() > 1) {

						//Comprobamos los plazos
						for(CondicionesInteresC condicion:condicionesInteresSolicitud) {
							//Capturar la duracion del primer plazo, tramo fijo
							if(condicion.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_UNO)) {
								plazoInteresTramoUno = condicion.getIntPlazo();
							}
							//Capturar el plazo del segundo tramo
							//Además capturo solo el plazo de la condicion de interes no del sustitutivo
							if(condicion.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_DOS)
									&& condicion.getCondicionesInteresKey().getIntTipoCondicion().equals(Constantes.CTE_INT_CERO)) {
								plazoInteresTramoDos = condicion.getIntPlazo();
							}
						}

						/**
						 * Comprobar que la suma de los plazos de interés es igual al plazo total de la solicitud
						 */
						plazoTotalInteres = plazoInteresTramoUno + plazoInteresTramoDos;
						//Comparar la suma de los plazos de los tramos de interes con el plazo total de la solicitud
						//Si son distintos se actualizan
						if(!solicitudExiste.getPlazoTotal().equals(plazoTotalInteres)) {
							//Si es distinto indica que tenemos que actualizar el plazo del tramo 2
							plazoInteresTramoDosModificado = solicitudExiste.getPlazoTotal().intValue() - plazoInteresTramoUno;
							for(CondicionesInteresC condicion:condicionesInteresSolicitud) {
								//Actualizar el plazo del segundo tramo con el plazo total de solicitud menos el plazo del primer tramo
								//Se actualiza el sustitutivo y el segundo tramo de interés asi como las condiciones opcionales siempre
								//que sean de orden 2.
								if(condicion.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_DOS)) {
									condicion.setIntPlazo(plazoInteresTramoDosModificado);
								}
							}
						}

					}else {
						//Si solo tiene un tramo el plazo de interés es el plazo de la solicitud
						for(CondicionesInteresC condicion:condicionesInteresSolicitud) {
							condicion.setIntPlazo(solicitudExiste.getPlazoTotal().intValue());
						}

					}

				}

				/**Colocar las nuevas condiciones de interés en solicitud**/
				solicitud.setCondicionesInteres(condicionesInteresSolicitud);
			}
		}

		return solicitud;
	}

	/**
	 * Recupera el plazo de interés y actualiza el plazo en caso de que este no coincida
	 * tanto el del sustitutivo como el de la condicion principal
	 * 
	 * Metodo sobrecargado comprueba y actualiza el plazo de una solicitud incompleta que se pasa como parametro
	 * @param solicitud
	 * @return
	 */
	public static DatosSolicitudC actualizarPlazoInteres(DatosSolicitudC solicitud) {

		//Declaracion de variables para verificar los plazos
		Integer plazoInteresTramoUno = new Integer(0);
		Integer plazoInteresTramoDos = new Integer(0);
		Integer plazoTotalInteres = new Integer(0);
		Integer plazoInteresTramoDosModificado = new Integer(0);

		List<CondicionesInteresC> condicionesInteresSolicitud = new ArrayList<CondicionesInteresC>();
		//Recuperamos las condiciones de interes de la solicitud
		condicionesInteresSolicitud = solicitud.getCondicionesInteres();

		/**
		 * Validamos previamente que existan condiciones de interes antes de procesarlas
		 */
		if(!UtilidadesTramitacion.isBlankOrNull(condicionesInteresSolicitud)) 
		{
			int numeroTramos = 0;
			
			for(CondicionesInteresC condicion : condicionesInteresSolicitud)
			{
				if(numeroTramos < condicion.getCondicionesInteresKey().getIntOrdenDelTramo())
				{
					numeroTramos = condicion.getCondicionesInteresKey().getIntOrdenDelTramo();
				}
			}
			
			//Si el numero de tramos es mayor o igual a 3 no podemos cambiar los plazos.
			if(numeroTramos < 3){
				/**Comprobar si tiene uno o varios tramos de interés**/
				if(numeroTramos > 1) {
	
					//Comprobamos los plazos
					for(CondicionesInteresC condicion:condicionesInteresSolicitud) {
						//Capturar la duracion del primer plazo, tramo fijo
						if(condicion.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_UNO)) {
							plazoInteresTramoUno = condicion.getIntPlazo();
						}
						//Capturar el plazo del segundo tramo
						//Además capturo solo el plazo de la condicion de interes no del sustitutivo
						if(condicion.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_DOS)
								&& condicion.getCondicionesInteresKey().getIntTipoCondicion().equals(Constantes.CTE_INT_CERO)) {
							plazoInteresTramoDos = condicion.getIntPlazo();
						}
					}
	
					/**
					 * Comprobar que la suma de los plazos de interés es igual al plazo total de la solicitud
					 */
					plazoTotalInteres = plazoInteresTramoUno + plazoInteresTramoDos;
					//Comparar la suma de los plazos de los tramos de interes con el plazo total de la solicitud
					//Si son distintos se actualizan
					if(!solicitud.getPlazoTotal().equals(plazoTotalInteres)) {
						//Si es distinto indica que tenemos que actualizar el plazo del tramo 2
						plazoInteresTramoDosModificado = solicitud.getPlazoTotal().intValue() - plazoInteresTramoUno;
						for(CondicionesInteresC condicion:condicionesInteresSolicitud) {
							//Actualizar el plazo del segundo tramo con el plazo total de solicitud menos el plazo del primer tramo
							//Se actualiza el sustitutivo y el segundo tramo de interés asi como las condiciones opcionales siempre
							//que sean de orden 2.
							if(condicion.getCondicionesInteresKey().getIntOrdenDelTramo().equals(Constantes.CTE_INT_DOS)) {
								condicion.setIntPlazo(plazoInteresTramoDosModificado);
							}
						}
					}
	
				}else {
					//Si solo tiene un tramo el plazo de interés es el plazo de la solicitud
					for(CondicionesInteresC condicion:condicionesInteresSolicitud) {
						condicion.setIntPlazo(solicitud.getPlazoTotal().intValue());
					}
	
				}				
			}

			/**Colocar las nuevas condiciones de interés en solicitud**/
			solicitud.setCondicionesInteres(condicionesInteresSolicitud);
		}
		
		return solicitud;
	}
	
	/**
	 * 
	 * Método que llama al servicio ANPM_075 para obtener el parámetro de la AN82TB01.
	 * 
	 * @param agrupacion
	 * @param nombreParametro
	 * 
	 * @return valorParametro
	 * 
	 */
	public static String obtenerParametroUnicoANPM(String agrupacion, String nombreParametro)
	{
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultadosParam = null;
		String valorParametro = null;
		
		/*Llamamos al ANPM_075 para obtener el listado de productos destino, si existe.*/
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_BUSQ_PARAM_CC,
			Constantes.CTE_SN_BUSQ_PARAM_CO);
		
		datosEntrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_NOMBRE, nombreParametro);
		datosEntrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_AGRUP, agrupacion);
		
		resultadosParam = ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntrada);
		
		if (! UtilidadesTramitacion.isBlankOrNull(resultadosParam))
		{
			valorParametro = comprobarDatoNull(resultadosParam[0].getString(Constantes.CTE_SN_BUSQ_PARAM_SAL_VALOR));
		}
		return valorParametro;
	}
	
	/**
	 * Obtiene los parámetros para una misma agrupación llamando al método ANPM_075.
	 * 
	 * @param nombre de la agrupación
	 * @return Map <K, V> -> K = nombre parámetro V= valor parámetro
	 * 
	 * */
	
	public static Map<String,String> obtenerListaParametrosAgrupacion(String agrupacion)
	{
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultadosParam = null;
		Map<String, String> listaParametros = new HashMap<String, String>();
		
		
		/*Llamamos al ANPM_075 para obtener el listado de productos destino, si existe.*/
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_BUSQ_PARAM_CC,
			Constantes.CTE_SN_BUSQ_PARAM_CO);
		
		datosEntrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_AGRUP, agrupacion);
		
		resultadosParam = ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntrada);
		
		for ( IContexto filtrado : resultadosParam)
		{
			if ("AUTOR".equals(filtrado.getString("ANPMN031040"))) // si el parametro es autor
			{
				listaParametros.put(filtrado.getString("ANPMN031040"), filtrado.getString("ANPMN031010"));
			}
			else if( "DESTINATAR".equals(filtrado.getString("ANPMN031040")))
			{
				listaParametros.put(filtrado.getString("ANPMN031040"), filtrado.getString("ANPMN031010"));
			}
		}
		return listaParametros;
	}

	/**
	 * 
	 * Método que llama al servicio ANPM_075 para obtener de la AN82TB01 los valores
	 * correspondientes a la agrupacion y parametro recibidos como entrada.
	 * 
	 * @param agrupacion
	 * @param nombreParametro
	 * 
	 * @return lista de valores de parametros
	 * 
	 */
	public static List<String> obtenerParametrosANPM(String agrupacion, String nombreParametro)
	{
		// Inicializaciones
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada = null;
		IContexto[] resultadosParam = null;
		List<String> valoresParametros = new ArrayList<String>();
		
		// Llamada al ANPM_075 para obtener el listado de parametros
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_BUSQ_PARAM_CC,
			Constantes.CTE_SN_BUSQ_PARAM_CO);
		
		datosEntrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_NOMBRE, nombreParametro);
		datosEntrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_AGRUP, agrupacion);
		
		resultadosParam = ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntrada);
		
		// Anhadir valores de parametros a la lista
		if (!UtilidadesTramitacion.isBlankOrNull(resultadosParam))
		{
			for(IContexto resultado : resultadosParam)
			{
				valoresParametros.add(comprobarDatoNull(resultado.getString(
						Constantes.CTE_SN_BUSQ_PARAM_SAL_VALOR)));
			}
		}
		
		// Devolver lista de valores
		return valoresParametros;
	}
	
	
	// Se llama al SN ANPM_442 desde garantías para obtener las tarifas posibles a aplicar a una solicitud
	// ordenadas por prioridad ( origen solicitud () ).
	
	public static List<TarifaTO> obtenerTarifasAplicablesGarantias(BigDecimal nuc,String cumpleLTVPremier,String cumpleLTVNormativo)
	{
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IDatosEntradaTx datosEntrada 	= 	null;
		IContexto[] datosSalida 		=	null;

		BigDecimal origen = new BigDecimal(1);
		
		/*Llamamos al ANPM_442 para obtener las tarifas*/
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.ID_CUENTA_ANPM,
			Constantes.CTE_SN_CONS_TARIFA_CO);
		
		datosEntrada.addCampo(Constantes.ORIGEN , origen);
		datosEntrada.addCampo(Constantes.NUC, nuc);
		datosEntrada.addCampo(Constantes.CUMPLE_LTV_PREM,cumpleLTVPremier);
		datosEntrada.addCampo(Constantes.CUMPLE_LTV_NORM,cumpleLTVNormativo);

		datosSalida = ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntrada);
		
		// Retorna un array de TO's con las tarifas.	
		IRegistro[] ctxTarifas = datosSalida[0].getRegistro(Constantes.REG_ANPMCTX442);
		
		List<TarifaTO> tarifasValidas = new ArrayList<TarifaTO>(0);
		for (IRegistro iRegistro : ctxTarifas)
			{
				TarifaTO t = new TarifaTO();
				t.setIdTarifa(iRegistro.getBigDecimal(Enumerados.REG_ANPMN442010.ID_TARIFA.getFieldCGDN()));
				t.setDescrTarifa(iRegistro.getString(Enumerados.REG_ANPMN442010.DESCRIPCION.getFieldCGDN()).toString().trim());
				t.setPrioridad(iRegistro.getBigDecimal(Enumerados.REG_ANPMN442010.PRIORIDAD.getFieldCGDN()));
				tarifasValidas.add(t);
				t=null;
			}
		return tarifasValidas;
	}
	
	/**
	 * Método que comprueba si una cliente es premium o no ("S"/"N")
	 * 
	 * @param numeroCliente
	 * @return
	 */
	public static String obtenerIndClienteCartBPrivadaOBPremium(BigDecimal numeroCliente)
	{
		String indicador = Constantes.CTE_STR_N;
		
		IDatosEntradaTx datosEntradaConsultaModeloCartera = null; //YINT_035
		IContexto[] resultadoConsultaModeloCartera = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();

		IDatosEntradaTx datosEntradaDetalleCartera = null;
		IContexto[] resultadoDetalleCartera = null;
		String tipoCartera = null;
		
		datosEntradaConsultaModeloCartera = ServicioNegocio.getPrograma(
													contextoEjecucion,
													Constantes.CTE_SN_CC_CONSULTA_MODELO_CARTERA, //888
													Constantes.CTE_SN_CO_CONSULTA_MODELO_CARTERA); //035
		
		datosEntradaConsultaModeloCartera.addCampo("NUMERO_CLIENTE", numeroCliente); 
		
		resultadoConsultaModeloCartera = ServicioNegocio.invocarServicio(
																contextoEjecucion,
																datosEntradaConsultaModeloCartera);
		
		// Se obtiene el código de la cartera modelo, el YINTN004050
		if (null != resultadoConsultaModeloCartera
		&& !StringUtils.isBlank(resultadoConsultaModeloCartera[0].getString("YINTN004050")))
		{
			// Se llama al YINT_013
			datosEntradaDetalleCartera = ServicioNegocio.getPrograma(
															contextoEjecucion,
															Constantes.CTE_SN_CC_DETALLE_CARTERA, //YINT
															Constantes.CTE_SN_CO_DETALLE_CARTERA); //013
			
			datosEntradaDetalleCartera.addCampo(
											"CODIGO_CARTERA_MODELO", 
											resultadoConsultaModeloCartera[0].getString("YINTN004050").trim());
			
			resultadoDetalleCartera = ServicioNegocio.invocarServicio(
															contextoEjecucion,
															datosEntradaDetalleCartera);
			
			// Si el tipoCartera comienza por "SP" o "SR" entonces el cliente está carterizado 
			// o bien en Banca Privada o en Banca Premium, es decir indicador = "S", else "N"	
			if (null != resultadoDetalleCartera
			&& !StringUtils.isBlank(resultadoDetalleCartera[0].getString("YINTN002050")))
			{
				tipoCartera = resultadoDetalleCartera[0].getString("YINTN002050").trim();
			
				if(tipoCartera.startsWith("SP")
				|| tipoCartera.startsWith("SR"))
				{
					indicador = Constantes.CTE_STR_S;
				}
			}
		}
		
		return indicador;
	}
	
	/**
	 * 
	 * Método que obtiene datos de la versión general del subproducto.
	 * 
	 * @param datosSolicitud
	 * @return arrayDatosCatalogo array de contextos con los datos de catálogo del subproducto.
	 */
	public static IContexto[] consultarDatosSubproductoCatalogo(DatosSolicitudC datosSolicitud)
	{
		IContexto[] arrayDatosCatalogo = null;
		
		BigDecimal codProducto = null;
		BigDecimal codSubproducto = null;
		BigDecimal colectivo = null;
		BigDecimal versionGeneral = null;
		BigDecimal paso = null;
		BigDecimal idTarifa = null;
		String plazoStr = null;
		BigDecimal origen = null;
		BigDecimal nuc = null;
		
		codProducto = datosSolicitud.getProducto();
		codSubproducto = datosSolicitud.getSubproducto();
		colectivo = BigDecimal.ZERO;
		versionGeneral = datosSolicitud.getVersionGeneral();
		paso = Constantes.CTE_PASO_3;
		//FALTA RECUPERAR EL ID TARIFA, ESPERAR A QUE ESTÉ MAPEADO.
		//idTarifa = datosSolicitud.getIdTarifa();
		plazoStr = datosSolicitud.getPlazoTotal().toString();
		origen = Constantes.CTE_ORIGEN_CONSULTA_TARIFA_SOLICITUD; //1: Simulacion, 2: Solicitud
		nuc = datosSolicitud.getDatosSolicitudKey().getNucExpediente();
		
		arrayDatosCatalogo = consultarDatosSubproductoCatalogo(
			codProducto,
			codSubproducto,
			colectivo,
			versionGeneral,
			paso,
			idTarifa,
			plazoStr,
			origen, 
			nuc);
		
		
		return arrayDatosCatalogo;
	}
	

	/**
	 * Método que obtiene datos de subproducto llamando al servicio ANPM_048.
	 * 
	 * @param codProducto
	 * @param codSubproducto
	 * @param colectivo
	 * @param versionGeneral
	 * @param paso
	 * @param idTarifa
	 * @param plazoStr
	 * @param origen
	 * @return arrayDatosCatalogo array de contextos con los datos de catálogo del subproducto.
	 */
	public static IContexto[] consultarDatosSubproductoCatalogo(
		BigDecimal codProducto,
		BigDecimal codSubproducto,
		BigDecimal colectivo,
		BigDecimal versionGeneral,
		BigDecimal paso,
		BigDecimal idTarifa,
		String plazoStr,
		BigDecimal origen, 
		BigDecimal nuc)
	{
		IDatosEntradaTx datosEntradaDetalleSubprod = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		IContexto[] arrayDatosCatalogo = null;
		
		datosEntradaDetalleSubprod = ServicioNegocio.getPrograma(
			ServicioNegocio.getContexto(),
			Constantes.CTE_SN_DETALLE_SUBPROD_CC,
			Constantes.CTE_SN_DETALLE_SUBPROD_CO);
		
		// Datos obligatorios
		datosEntradaDetalleSubprod.addCampo("Codigo_producto", codProducto);
		datosEntradaDetalleSubprod.addCampo("Codigo_subproducto", codSubproducto);
		datosEntradaDetalleSubprod.addCampo("Colectivo", colectivo);
		datosEntradaDetalleSubprod.addCampo("Version_general", versionGeneral);
		
		// Datos optativos
		if (null != paso)
		{
			datosEntradaDetalleSubprod.addCampo("Paso", paso);
		}
		
		if (null != idTarifa)
		{
			datosEntradaDetalleSubprod.addCampo("ID_TARIFA", idTarifa);
		}
		
		if (null != plazoStr)
		{
			datosEntradaDetalleSubprod.addCampo("PLAZO", plazoStr);
		}
		
		if (null != origen)
		{
			datosEntradaDetalleSubprod.addCampo("ORIGEN", origen);
		}
		
		if (null != nuc)
		{
			datosEntradaDetalleSubprod.addCampo("NUC", nuc);
		}
		
		arrayDatosCatalogo = ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntradaDetalleSubprod);
		
		return arrayDatosCatalogo;
	}
	
	// Este método realiza una serie de consultas a 
	// través del servicio ANPM_450 que consulta la
	// tabla ANTATB01. En caso de no encontrar ningún resultado
	// (SQLCODE = null ) retorna un nulo.
	
	public static List<TarifaTO> obtenerTarifas(BigDecimal producto,BigDecimal subproducto,BigDecimal version, 
			BigDecimal id, boolean tarifasLTV, BigDecimal canal)
	{
		
		IDatosEntradaTx datosEntrada = null;
		IContexto[] datosSalida = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.ID_CUENTA_ANPM, //507
			Constantes.CO_CONSULTA_TARIFAS); //451
		
		datosEntrada.addCampo(Constantes.PRODUCTO, producto);
		datosEntrada.addCampo(Constantes.SUBPRODUCTO, subproducto);
		datosEntrada.addCampo(Constantes.VERSION_GENERAL, version);
		if( !(null == id))
		{
			datosEntrada.addCampo(Constantes.ID_TARIFA, id);
		}
		if(tarifasLTV)
		{
			datosEntrada.addCampo(Constantes.TARIFAS_LTV, new BigDecimal(1));
		}
		
		if (null != canal)
		{
			datosEntrada.addCampo(Constantes.CANAL, canal);
		}
		
		
		datosSalida = ServicioNegocio.invocarServicio(
			contextoEjecucion,
			datosEntrada);
		
		if(Helper.isNullOrEmpty(datosSalida)) return null;

		// Retorna un array de TO's con todas/la tarifas.	
		IRegistro[] ctxTarifas = datosSalida[0].getRegistro(Constantes.REG_ANPMCTX442);
		
		List<TarifaTO> tarifasValidas = new ArrayList<TarifaTO>(0);
		for (IRegistro iRegistro : ctxTarifas)
			{
				TarifaTO t = new TarifaTO();
				t.setIdTarifa(iRegistro.getBigDecimal(Enumerados.REG_ANPMN442010.ID_TARIFA.getFieldCGDN()));
				t.setDescrTarifa(iRegistro.getString(Enumerados.REG_ANPMN442010.DESCRIPCION.getFieldCGDN()).toString().trim());
				t.setPrioridad(iRegistro.getBigDecimal(Enumerados.REG_ANPMN442010.PRIORIDAD.getFieldCGDN()));
				tarifasValidas.add(t);
				t=null;
			}
		
		return tarifasValidas;
	}
	
	
	/**
	 * Consulta los datos de una solicitud
	 * @param bidOficinaSolicitud
	 * @param bidNumeroSolicitud
	 * @param bidVersionSolicitud
	 * @param bidNucExpediente
	 * @return Datos de la consulta de la solicitud
	 */
	
	// Se llama al servicio ANPM_150 y devuelve el contexto ANPMN050
	// para obtener los parametos básicos de una solicitud de un préstamo. 
	// que devuelve la version incompleta si existe y, si no, devuelve la última
	//
	
	public static IContexto[] consultarSolicitud(boolean completa,
			BigDecimal bidNucExpediente, boolean devolverDetalleHijos)
	{
		IDatosEntradaTx datosEntradaDatosSolicitud = 
			ServicioNegocio.getPrograma(ServicioNegocio.getContexto(),
					Constantes.ID_CUENTA_ANPM,
					Constantes.ID_CODOP_CONSULTA_SOL);
		
		datosEntradaDatosSolicitud.addCampo(
				Constantes.CTE_POSICION_TIRA_NUC_EXPEDIENTE, bidNucExpediente);
		if (devolverDetalleHijos)
		{
			datosEntradaDatosSolicitud.addCampo(
					Constantes.CTE_POSICION_TIRA_DETALLE_HIJOS, Constantes.SI);
		}
		else
		{
			datosEntradaDatosSolicitud.addCampo(
					Constantes.CTE_POSICION_TIRA_DETALLE_HIJOS, Constantes.NO);
		}
		
		final IContexto[] aCtxtoDatosSolicitud = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaDatosSolicitud);
		
		
		if (isBlankOrNull(aCtxtoDatosSolicitud))
		{
			
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_SOLIC_NO_EXISTE_PARA_NUC,
				null,
				new String[] {bidNucExpediente.toString()},
				new String[] {bidNucExpediente.toString()});
			
		}
		
		else 
		{
			BigDecimal estado = aCtxtoDatosSolicitud[0].getBigDecimal(Constantes.CTE_NUMERO_SOLICITUD);
			//
			if(estado.equals(new BigDecimal(0)))
			{
				if(completa)
				{
					ServicioNegocio.rollback(
					CodigosError.CTE_ERROR_SOLIC_INCOMPLETA,
					new String[] {Constantes.CTE_INCOMPLETA},
					new String[] {Constantes.CTE_COMPLETA},
					new String[] {bidNucExpediente.toString()});
				}
			}
			else
			{
				if(!completa)
				{
					ServicioNegocio.rollback(
					CodigosError.CTE_ERROR_SOLIC_INCOMPLETA,
					new String[] {Constantes.CTE_COMPLETA},
					new String[] {Constantes.CTE_INCOMPLETA},
					new String[] {bidNucExpediente.toString()});
					
				}
			}
		}
		return aCtxtoDatosSolicitud;
		
	}	
	
	
	/**
	 * Metodo que consulta los datos de una solicitud llamando al servicio ANPM_150.
	 * Se llama con aquellos parametros de entrada que tengan valor. 	
	 * @param oficina oficina de la solicitud
	 * @param numero numero de solicitud
	 * @param version version de la solicitud
	 * @param nuc nuc expediente
	 * @param detalleHijos detalle hijos S/N
	 * @return datos de la solicitud correspondiente a los parametros de entrada. Si existe
	 *         version incompleta se devuelve la incompleta, si no la ultima version.
	 */
	public static IContexto[] consultarDatosSolicitud(BigDecimal oficina, BigDecimal numero, 
			BigDecimal version, BigDecimal nuc, String detalleHijos)
	{
		
		// Rellenar campos de entrada al servicio
		IDatosEntradaTx datosEntrada = 
			ServicioNegocio.getPrograma(ServicioNegocio.getContexto(),
					Constantes.ID_CUENTA_ANPM,
					Constantes.ID_CODOP_CONSULTA_SOL);
		
		if (null != oficina)
		{
			datosEntrada.addCampo("OFICINA_SOLICITUD", oficina);
		}
		
		if (null != numero)
		{
			datosEntrada.addCampo("NUMERO_SOLICITUD", numero);
		}
		
		if (null != version)
		{
			datosEntrada.addCampo("VERSION_SOLICITUD", version);
		}
		
		if (null != nuc)
		{
			datosEntrada.addCampo("NUM_EXPEDIENTE", nuc);
		}
		
		if (StringUtils.isNotBlank(detalleHijos))
		{
			datosEntrada.addCampo("DETALLE_HIJOS", detalleHijos);
		}

		// Llamada al servicio ANPM_150
		final IContexto[] aCtxtoDatosSolicitud = ServicioNegocio.invocarServicio(
				ServicioNegocio.getContexto(), datosEntrada);
		
		
		if (isBlankOrNull(aCtxtoDatosSolicitud))
		{
			
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_SOLIC_NO_EXISTE_PARA_NUC,
				null,
				new String[] {nuc.toString()},
				new String[] {nuc.toString()});
			
		}
		
		return aCtxtoDatosSolicitud;	
	}
	
	
	// Función que se llama desde el servicio ANPM_450 para comprobar si
	// existe o no el nuc en ANPM. Devuelve (S/N/E).
	
	public static String existeNUCenANTA( BigDecimal bidNucExpediente)
	{
		IDatosEntradaTx datosEntradaDatosSolicitud = 
			ServicioNegocio.getPrograma(ServicioNegocio.getContexto(),
					Constantes.ID_CUENTA_ANPM,
					Constantes.ID_CODOP_CONSULTA_SOL);
		
		datosEntradaDatosSolicitud.addCampo(
				Constantes.CTE_POSICION_TIRA_NUC_EXPEDIENTE, bidNucExpediente);

		datosEntradaDatosSolicitud.addCampo(
					Constantes.CTE_POSICION_TIRA_DETALLE_HIJOS, Constantes.NO);

		
		final IContexto[] aCtxtoDatosSolicitud = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaDatosSolicitud);
		
		
		if (isBlankOrNull(aCtxtoDatosSolicitud))
		{
			return Constantes.CTE_STR_N;
		}		
		else 
		{
			BigDecimal estado = aCtxtoDatosSolicitud[0].getBigDecimal(Constantes.CTE_NUMERO_SOLICITUD);
			//
			if(estado.compareTo(new BigDecimal(0)) == 0)
			{
				return Constantes.CTE_STR_E;	
			}
			estado = null;
		}		
		return Constantes.CTE_STR_S;
	}


	public static boolean existeEnANTA(BigDecimal producto,
			BigDecimal subProducto, BigDecimal versionGeneral)
	{
		IDatosEntradaTx datosEntrada = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.ID_CUENTA_ANPM, //507
			Constantes.CO_CONSULTA_TARIFAS); //451
		
		datosEntrada.addCampo(Constantes.PRODUCTO, producto);
		datosEntrada.addCampo(Constantes.SUBPRODUCTO, subProducto);
		datosEntrada.addCampo(Constantes.VERSION_GENERAL, versionGeneral);
		
		return false;
	}
	
	/**
	 * Método que llama al PTMO_130 para obtener datos sobre el tipo de referencia indicado.
	 * 
	 * @param tipoRefTruncado
	 * @param plazoRef
	 * @param indBusqFecha
	 * @return
	 */
	public static IContexto obtenerDatosTipoReferencia(String tipoRefTruncado, String plazoRef, String indBusqFecha)
	{
		IContexto[] resultado = null;
		IContexto salida = null;
		IDatosEntradaTx datosEntradaObtenerTipoRef = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();

		
		datosEntradaObtenerTipoRef = ServicioNegocio.getPrograma(
			contextoEjecucion,
			new Integer(Constantes.CTE_SN_OBTENER_TIPO_REF_CC),
			new Integer(Constantes.CTE_SN_OBTENER_TIPO_REF_CO));
		
		datosEntradaObtenerTipoRef.addCampo(Constantes.CTE_SN_SN_OBTENER_TIPO_REF_ENTRADA_TIPO, tipoRefTruncado);
		datosEntradaObtenerTipoRef.addCampo(Constantes.CTE_SN_SN_OBTENER_TIPO_REF_ENTRADA_PLAZO, plazoRef);
		/*20140825: Si estamos en entorno de EVO buscamos el valor tipo ref. por fecha publicación y
		 * si estamos en entorno ABANCA buscamos por fecha referencia.*/
		datosEntradaObtenerTipoRef.addCampo(Constantes.CTE_SN_OBTENER_TIPO_REF_IND_BUS_FECHA, indBusqFecha);
		
		resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntradaObtenerTipoRef);
		
		if (! UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			salida = resultado[0];
		}
		
		return salida;
	}
	
	
	/**
	 * Método que obtiene la fecha de publicación del tipo de referencia indicado.
	 * La recibimos del PTMO_130 en formato AAAA-MM-DD pero la devolvemos en formato DD-MM-AAAA
	 * 
	 */
	public static String obtenerFechaPublicacionTipoReferencia(String tipoRefTruncado, String plazoRef, String indBusqFecha)
	{
		String fechaPublicacion = null;
		IContexto resultado = null;
		String fechaPublicacionFormateada = null; //Formato DD-MM-AAAA
		
		resultado = obtenerDatosTipoReferencia(tipoRefTruncado, plazoRef, indBusqFecha);
		
		if (null != resultado)
		{
			fechaPublicacion = resultado.getString("PTMON010030");
			if (null != fechaPublicacion)
			{
				fechaPublicacionFormateada = DateHelper.getInstance().formatearFecha(
					DateHelper.FORMATO_DB2_DATE, DateHelper.FORMATO_DD_MM_YYYY_GUION, fechaPublicacion);
			}
		}
		
		return fechaPublicacionFormateada;
	}

	public static String obtenerEstadoTarea(BigDecimal nucExpediente, BigDecimal codigoProceso)
	{
		String estadoTarea = null;
		
		IContexto[] resultado = null;
		IDatosEntradaTx datosEntrada = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CONSULTA_ESTADO_TAREA_EEXP_CC,
			Constantes.CTE_SN_CONSULTA_ESTADO_TAREA_EEXP_CO);
		
		
		datosEntrada.addCampo(Constantes.CTE_NUC, nucExpediente);
		datosEntrada.addCampo(Constantes.CTE_CODIGO_PROCESO, codigoProceso);
		
		resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
		
		if (! UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			if (Constantes.CTE_STR_0.equals(resultado[0].getString(Constantes.CTE_SALIDA_CONS_ESTADO_TAREA_COD_ERROR)))
			{
				estadoTarea = resultado[0].getString(Constantes.CTE_SALIDA_CONS_ESTADO_TAREA_ESTADO);
			}
		}
		
		return estadoTarea;
	}

	/**
	 * Este método es una copia de obtenerEstadoTarea con la diferencia de que si en el campo del contexto devuelve el valor 2, y el campo 30 del contexto viene informado, 
	 * se devuelve el estado de la tarea. El método obtenerEstadoTarea si detectaba un "error" (2), devuelve un null, aunque este valor también significa que la tarea de 
	 * validación no está comenzada.
	 * */
	public static String obtenerEstadoTareaNuevo(BigDecimal nucExpediente, BigDecimal codigoProceso)
	{
		String estadoTarea = null;
		
		IContexto[] resultado = null;
		IDatosEntradaTx datosEntrada = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CONSULTA_ESTADO_TAREA_EEXP_CC,
			Constantes.CTE_SN_CONSULTA_ESTADO_TAREA_EEXP_CO);
		
		
		datosEntrada.addCampo(Constantes.CTE_NUC, nucExpediente);
		datosEntrada.addCampo(Constantes.CTE_CODIGO_PROCESO, codigoProceso);
		
		resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
		
		if (! UtilidadesTramitacion.isBlankOrNull(resultado))
		{
			if (Constantes.CTE_STR_0.equals(resultado[0].getString(Constantes.CTE_SALIDA_CONS_ESTADO_TAREA_COD_ERROR)))
			{
			  estadoTarea = resultado[0].getString(Constantes.CTE_SALIDA_CONS_ESTADO_TAREA_ESTADO);
			}
			else if ( !UtilidadesTramitacion.isBlankOrNull(resultado[0].getString(Constantes.CTE_SALIDA_CONS_ESTADO_TAREA_ESTADO)))
			{
				estadoTarea = resultado[0].getString(Constantes.CTE_SALIDA_CONS_ESTADO_TAREA_ESTADO);
			}
		}
		
		return estadoTarea;
	}
	
	
	
	
	/**
	 * Método que llama al servicio EEXP_419 y comprueba qué tipo de minuta tiene el expediente
	 * Si el expediente tiene minuta electrónica devuelve una "S"
	 * Si el expediente tiene minuta manual devuelve una "N"
	 * 
	 * */
	
	public static String minutaManualOElectronica(BigDecimal nucExpediente)
	{		
		IContexto[] resultadoInvocacion = null;
		String resultado = "N";
		
		IDatosEntradaTx datosEntrada = null;
		IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
		
		datosEntrada = ServicioNegocio.getPrograma(
			contextoEjecucion,
			Constantes.CTE_SN_CONSULTA_ESTADO_TAREA_EEXP_CC,
			Constantes.CTE_SN_CONSULTA_TIPO_MINUTA_CO);
		
		
		datosEntrada.addCampo(Constantes.CTE_NUC_EXPEDIENTE, nucExpediente);
		resultadoInvocacion = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
		
		for (IContexto tipoMinuta : resultadoInvocacion)
		{
			if ("S".equals(tipoMinuta.getString("EEXPN454010")))
			{
				resultado = "S";
			}
		}
		return resultado;
	}
	
	
	/*
	 * Llamada al método ANPM_458 para la obtención de la descripcion de la tarifa	
	 */
	public static String obtenerDescripcionTarifa(BigDecimal producto, BigDecimal subProducto, 
			BigDecimal idTarifa) 
	{
		String resultado = "";
		IContexto [] llamadaServicio = null;
		Integer CTE_CC_CONSULTA_DESCRIPCION = Integer.parseInt("507");
		Integer CTE_CO_CONSULTA_DESCRIPCION = Integer.parseInt("458");
	
		if ( !UtilidadesTramitacion.isBlankOrNull(idTarifa))
		{						 
			IDatosEntradaTx datosDescripcion = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), CTE_CC_CONSULTA_DESCRIPCION, CTE_CO_CONSULTA_DESCRIPCION);
			
			datosDescripcion.addCampo ("COD_PRODUCTO", producto);
			datosDescripcion.addCampo ("COD_SUBPRODUCTO", subProducto);
			datosDescripcion.addCampo ("ID_TARIFA", idTarifa);

			/*Devuelve en la variable resultado la descripción para el ID de tarifa pedido*/
  			llamadaServicio = (ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosDescripcion));
  			resultado = llamadaServicio[0].getString("ANPMN458020");
		}
		
		return resultado;
	}
	
	
	/**
	 * Comprueba el parametro de configuracion de si tiene o no tiene que ejecutar el log
	 * @return un true en caso de que se tenga que ejecutar el log y un false en caso contrario
	 */
	public static boolean ejecutarLog()
	{
		String estadoLog = null;

		/**
		 * Nos va a devolver un si si el log esta activo S y un No cuando no lo está N
		 */
		
		/*Obtenemos el código de la entidad en la que se está ejecutando el servicio*/
		estadoLog = Configuracion.getInstance().getValor(
			IConstantesSolicitud.CTE_APLICACION_LOG_ACTIVO,
			IConstantesSolicitud.CTE_GRUPO_CONFIG_LOG_ACTIVO,
			IConstantesSolicitud.CTE_PARAM_CONFIG_LOG_ACTIVO).trim();


		if(estadoLog.equalsIgnoreCase(ConstantesComun.CTE_STR_S)) {
			return true;
		}
		
		if(LOGGER.isDebugEnabled()) {
					LOGGER.debug("PARAMETRO_EVO parametro de configuracion, aplicacion ANPM, grupo ENTIDAD, parametro COD : ".concat(estadoLog));
		}
		
		
		return false;
	}
	
	/**
	 * Metodo que comprueba si un String solo contiene numeros.
	 * 
	 * @param str	String para comprobar
	 * @return
	 */
	public static boolean strIsNumber(String str)
	{
		try
		{
			Integer.parseInt(str);
		} catch (Exception e) {
			return false;
		}
		return true;
	}
	
	
	/**
	 * 	Metodo que convierte una lista de integers a una lista de BigDecimals
	 * 
	 * @param listaInteger
	 * @return
	 */
	public static List<BigDecimal> convertirListaIntegerToBigDecimal(List<Integer> listaInteger)
	{
		List<BigDecimal> listaBigDecimal = new ArrayList<BigDecimal>();
		
		if(null != listaInteger && 0 < listaInteger.size())
		{
			for (Integer numero : listaInteger)
			{
				listaBigDecimal.add(new BigDecimal(numero));
			}
		}
		
		return listaBigDecimal;
	}
	
	
	
	/**
	 * Metodo que calcula el importe de una comision, de la siguiente manera:<br>
	 * importe comision = importe prestamo * (porcentaje comision/100)<br> 
	 * Llama al programa ANPMR113<br>
	 * @param importeSolicitado
	 * @param porcentajeComision
	 * @return importe de la comision
	 */
	public static BigDecimal getImporteComision(BigDecimal importeSolicitado, 
			BigDecimal porcentajeComision)
	{
		BigDecimal importeComision = BigDecimal.ZERO;

		IContexto contextoProgramaCorretaje = ContextoFactory.getInstance().getContexto(Constantes.CTE_CODIGO_CONTEXTO_ANPMN113);
		
		// Campos entrada
		contextoProgramaCorretaje.put(Constantes.CTE_CODIGO_PROP_ANPMN113_1, importeSolicitado);
		contextoProgramaCorretaje.put(Constantes.CTE_CODIGO_PROP_ANPMN113_2, porcentajeComision);
		contextoProgramaCorretaje.put(Constantes.CTE_CODIGO_PROP_ANPMN113_3, Constantes.COD_MONEDA_DEFECTO);
		
		// Campos salida
		contextoProgramaCorretaje.put(Constantes.CTE_CODIGO_PROP_ANPMN113_4, BigDecimal.ZERO);
		contextoProgramaCorretaje.put(Constantes.CTE_CODIGO_PROP_ANPMN113_5, Helper.inicializarCadena("", 2, ' '));
		contextoProgramaCorretaje.put(Constantes.CTE_CODIGO_PROP_ANPMN113_6, Helper.inicializarCadena("", 50, ' '));
		contextoProgramaCorretaje.put(Constantes.CTE_CODIGO_PROP_ANPMN113_7, BigDecimal.ZERO);
		
		CtgFacade ctg = new CtgFacade();
		final IContexto[] contextosSalida = ctg.invocarProgramaCics(contextoProgramaCorretaje, Constantes.CTE_CODIGO_PROGRAMA_ANPMR113);			
		
		if (contextosSalida == null 
				|| contextosSalida[0] == null
				|| contextosSalida[0].getBigDecimal(Constantes.CTE_CODIGO_PROP_ANPMN113_7).intValue() != 0)
		{
			ServicioNegocio.rollback(CodigosError.CTE_ERROR_CALCULO_COMISION, null, new String[] {}, null);
		}
		
		importeComision = contextosSalida[0].getBigDecimal(Constantes.CTE_CODIGO_PROP_ANPMN113_4);
		
		// Devolver importe calculado
		return importeComision;
	}	
	
	
	/**
	 * Calcula el valor del importe productos a financiar y el importe total de una solicitud, 
	 * a partir de los datos de la solicitud y del indicador de financiar comision de apertura.
	 * 
	 * @param indFinanciarComisionApertura indicador de financiar comision de apertura.
	 * @param solicitud datos de la solicitud
	 * @return true si se han actualizado los valores de los importes de la solicitud, false en 
	 *         caso contrario.
	 */
	public static boolean calcularImportes(String indFinanciarComisionApertura, String indFinanciarComisionEstudios, DatosSolicitudC solicitud,
			String indFinanciarSeguro, BigDecimal bidImporteSeguro) {
		
		// Inicializaciones
		boolean actualizarImportes = false;
		
		// Obtener datos de la solicitud
		BigDecimal importeSolicitado = solicitud.getImporteSolicitado();
		BigDecimal importeProductosFinanciar = solicitud.getImporteProductosFinanciar();;
		BigDecimal importeTotal = null;
		BigDecimal importeComisionApertura = BigDecimal.ZERO;
		BigDecimal importeComisionEstudio = BigDecimal.ZERO;
							
		// Calcular importe productos a financiar como en ANPM_420
		// Comprobar si es necesario actualizar los importes
		if (indFinanciarComisionApertura.equals(Constantes.CTE_STR_S) || indFinanciarComisionEstudios.equals(Constantes.CTE_STR_S)){
			// Indicador financiar = "S": 
			// importe productos a financiar = importe comision
			// Para concesionarios no habra otros productos a financiar.
			List<ComisionC> listaComisiones = solicitud.getComisiones();
				
			if (null != listaComisiones){
				for (ComisionC com : listaComisiones){	
					if (com.getComisionesKey().getStrTipoComision().equals(Constantes.TIPO_COMISION_APERTURA)
							&& indFinanciarComisionApertura.equals(Constantes.CTE_STR_S)){					
						// Calcular importe comision apertura
						importeComisionApertura = UtilidadesTramitacion.getImporteComision( importeSolicitado, com.getBidPorcentajeComision());
		
						// Si importe comision < importe minimo => importe = importe minino
						if (null != com.getBidImporteMinimo()){
							if (importeComisionApertura.compareTo(com.getBidImporteMinimo()) < 0){
								importeComisionApertura = com.getBidImporteMinimo();
							}
						}
		
						// Actualizar importes (importeProductosFinanciar e importeTotal)
						actualizarImportes = true;
						//Insertamos el gasto financiado en la tabla AN57TB01
						if (importeComisionApertura.compareTo(BigDecimal.ZERO)>0){
							GestionGastosFinanciados.insertarGastoFinanciado(solicitud, Constantes.CTE_FINANCIAR_ID_COMISION_APERTURA, Constantes.CTE_FINANCIAR_DESC_COMISION_APERTURA, 
									importeComisionApertura, solicitud.getMonedaProductosFinanciar());
						}
					}
					else if (com.getComisionesKey().getStrTipoComision().equals(Constantes.TIPO_COMISION_ESTUDIO)
							&& indFinanciarComisionEstudios.equals(Constantes.CTE_STR_S)){
						// Calcular importe comision estudio
						importeComisionEstudio = UtilidadesTramitacion.getImporteComision( importeSolicitado, com.getBidPorcentajeComision());
		
						// Si importe comision < importe minimo => importe = importe minino
						if (null != com.getBidImporteMinimo()){
							if (importeComisionEstudio.compareTo(com.getBidImporteMinimo()) < 0){
								importeComisionEstudio = com.getBidImporteMinimo();
							}
						}
		
						// Actualizar importes (importeProductosFinanciar e importeTotal)
						actualizarImportes = true;	
						//Insertamos el gasto financiado en la tabla AN57TB01
						if (importeComisionEstudio.compareTo(BigDecimal.ZERO)>0){
							GestionGastosFinanciados.insertarGastoFinanciado(solicitud, Constantes.CTE_FINANCIAR_ID_GASTOS_ESTUDIO, Constantes.CTE_FINANCIAR_DESC_GASTOS_ESTUDIO, 
								importeComisionEstudio, solicitud.getMonedaProductosFinanciar());
						}
					}						
				}
					
				if (actualizarImportes){
					importeProductosFinanciar = importeComisionApertura.add(importeComisionEstudio);						
				}
			}
		}
		else{
			// Indicador financiar = "N": importe productos financiar 0
			importeProductosFinanciar = BigDecimal.ZERO;
				
			// Actualizar importe a 0
			actualizarImportes = true;
		}
			
		// Si financia el seguro se le suma al importe total y productos a financiar
		// e se inserta en la tabla AN57TB01
		if (Constantes.CTE_STR_S.equals(indFinanciarSeguro)){		    	   	
		    importeProductosFinanciar = importeProductosFinanciar.add(bidImporteSeguro);			    	
		    actualizarImportes = true;
		    if (bidImporteSeguro.compareTo(BigDecimal.ZERO)>0){
			    GestionGastosFinanciados.insertarGastoFinanciado(solicitud, 
			    		Constantes.CTE_FINANCIAR_ID_SEGURO, 
			    		Constantes.CTE_FINANCIAR_DESC_SEGURO, 
			    		bidImporteSeguro, solicitud.getMonedaProductosFinanciar());	
		    }	    	
		 }
						
		// Si es necesario, actualizar importes en la solicitud.
		if (actualizarImportes){
			// Calcular nuevo importeTotal
			if ((null != importeSolicitado) && (null != importeProductosFinanciar)){
				importeTotal = importeSolicitado.add(importeProductosFinanciar);
			}
				
			// Recuperar solicitud
			if (null != solicitud){
				// Actualizar valores en la solicitud
				solicitud.setImporteProductosFinanciar(importeProductosFinanciar);
				solicitud.setImporteTotal(importeTotal);
			}
		}
		
		// Devolver indicador de si hay que actualizar los importes o no
		return actualizarImportes;
	}	
	
	
	/**
	 * Comprueba si los precios de una solicitud estan caducados, teniendo en cuenta
	 * la fecha de la solicitud y el numero de dias de caducidad de los precios. <br>
	 * <br>
	 * La comprobacion que se hace es la siguiente:<br>
	 * <ul>
	 * <li>Si hoy > (fechaSolicitud + numero dias caducidad precio):
	 *     los precios estan caducados (se devuelve true)</li>
	 * <li>Resto de casos:
	 *     los precios no estan caducados (se devuelve false)</li>
	 * </ul>
	 * @param solicitud solicitud para la que se determinara si los precios estan caducados.
	 * @return true si los precios estan caducados, false en caso contrario.
	 */
	public static boolean comprobarPreciosCaducados(DatosSolicitudC solicitud)
	{
		// Inicializaciones
		boolean preciosCaducados = false;
		
		// Obtener fecha de solicitud y caducidad precio
		//Date fechaSolicitud = solicitud.getFechaSolicitud();
		
		// Si tiene la marca de autorización a 1 se calcula la caducidad a partir de la fecha de la autorización
		if(null != solicitud
		&& null != solicitud.getIndicadorAutorizacion()
		&& 1 == solicitud.getIndicadorAutorizacion().intValue())
		{
			// Consulta AN31 para obtener la fecha de la autorización
			DatosAutorizacionC autorizacion = new DatosAutorizacionEng("conf/CXGDB2XA").buscarAutorizacionPorVersionYEstado(
															solicitud.getDatosSolicitudKey().getOficinaSolicitud(), 
															solicitud.getDatosSolicitudKey().getNumSolicitud(),
															solicitud.getDatosSolicitudKey().getVersionSolicitud(),
															"A");
			
			// Consulta AN02 para obtener el plazo de caducidad
		/*	SubProductoC subproducto = new SubProductoEng().obtenerSubProductoUtimaVersion(
																			solicitud.getProducto().intValue(), 
																			solicitud.getSubproducto().intValue(), 
																			true, 
																			true);*/
			
			//BigDecimal plazo = BigDecimal.ZERO;

			if(/*null != subproducto
			&& null != subproducto.getCaducidadPrecios()
			&& */null != autorizacion
			&& null != autorizacion.getTimestampAutorizTotalDenegacion())
			{
				Date fecha = new Date(autorizacion.getTimestampAutorizTotalDenegacion().getTime());
			

		
				int caducidadPrecio = solicitud.getCaducidadPrecios().intValue();
				
				// Calcular la fecha de caducidad ( = fecha autorización + dias caducidad)
				Date fechaCaducidad = UtilidadesComun.sumarFechaDias(fecha, caducidadPrecio);
		
			    // Comprobar si los precios estan caducados (si hoy > fechaCaducidad, estan caducados)
			    Date hoy = new Date(System.currentTimeMillis());
		
			    if (0 < hoy.compareTo(fechaCaducidad))
			    {
			    	preciosCaducados = true;
			    }
			}
		}
			
	    // Devolver preciosCaducados
	    return preciosCaducados;
	}
	
	/**
	 * Obtiene la caducidad del precio para el producto, subproducto y version recibidos 
	 * como entrada, llamando al servicio ANPM_048 con paso preformalizacion (9). La llamada 
	 * con el paso 9 devuelve contexto de producto (ANPMN001) y subproducto (ANPMN002).
	 * 
	 * @param producto producto para el que se obtendra la caducidad del precio.
	 * @param subproducto subproducto para el que se obtendra la caducidad del precio.
	 * @param versionGeneral version general para la que se obtendra la caducidad del precio.
	 * @return caducidad del precio para el producto, subproducto y version general recibidos
	 *         como entrada.
	 */
	public static BigDecimal obtenerCaducidadPrecio(BigDecimal producto, BigDecimal subproducto, 
			BigDecimal versionGeneral, BigDecimal colectivo)
	{
		
		// Inicializaciones
		BigDecimal caducidadPrecio = null;
		BigDecimal paso = ConstantesComun.CTE_BID_9;
		
		// Llamada a ANPM_048
		IContexto[] salidaANPM048 = UtilidadesTramitacion.consultarDatosSubproductoCatalogo(producto, 
				subproducto, colectivo, versionGeneral, paso, null, null, null, null);
		
		if ((null != salidaANPM048) && (0 < salidaANPM048.length))
		{
			for (IContexto ctx : salidaANPM048)
			{
				if (ctx.getNombre().equals(CTE_CTX_SUBPRODUCTO))
				{
					caducidadPrecio = ctx.getBigDecimal(CTE_CTX_SUBPRODUCTO_CADUCIDAD_PRECIO);
					
					break;
				}
			}
		}
		
		// Devolver caducidad del precio
		return caducidadPrecio;
	}
	
	
	/**
	 * Actualiza campos que vengan en la salida del servicio de negocio de detalle de subproducto
	 * en un objeto de solicitud que recibe como parametro, esta configurado para solamente devol
	 * ver los contextos ANPMN001 y ANPMN002
	 * @param producto
	 * @param subproducto
	 * @param versionGeneral
	 * @param colectivo
	 * @param datosSolicitud
	 * @return
	 */
	public static DatosSolicitudC actualizarCamposCatalogo(BigDecimal producto, BigDecimal subproducto, 
			BigDecimal versionGeneral, BigDecimal colectivo,DatosSolicitudC datosSolicitud){		
		
		//Paso PASO_PREFORMALIZCION
		BigDecimal paso = ConstantesComun.CTE_BID_9;
		
		// Llamada a ANPM_048
		IContexto[] salidaANPM048 = UtilidadesTramitacion.consultarDatosSubproductoCatalogo(producto, 
				subproducto, colectivo, versionGeneral, paso, null, null, null, null);
		
		if ((null != salidaANPM048) && (0 < salidaANPM048.length))
		{
			for (IContexto ctx : salidaANPM048)
			{
				if (ctx.getNombre().equals(CTE_CTX_PRODUCTO))
				{
					datosSolicitud.setDiaDeSalto(ctx.getBigDecimal(CTE_CTX_PRODUCTO_DIA_SALTO));
					datosSolicitud.setIndicadorCalculoFinMes(ctx.getBigDecimal(CTE_CTX_PRODUCTO_CALCULO_FIN_MES));
					datosSolicitud.setFrmaPgoCrrtje(ctx.getBigDecimal(CTE_CTX_PRODUCTO_FRMA_PGO_CRRTJE));
					//break;
				}
				
				// 2017-11-03 - Leer de catalogo el indicador de forma de calculo de demoras y el indicador 
				// de cobro recibo otra entidad. Estos indicadores son datos de subproducto (ctx ANPMN002).
				if (ctx.getNombre().equals(CTE_CTX_SUBPRODUCTO))
				{
					datosSolicitud.setIndFormaCalculoDemoras(ctx.getBigDecimal(CTE_CTX_SUBPRODUCTO_IND_FORMA_CALCULO_DEMORAS));
					datosSolicitud.setIndCobroReciboOtraEntidad(ctx.getBigDecimal(CTE_CTX_SUBPRODUCTO_IND_COBRO_RECIBO_OTRA_ENTIDAD));
					break;
				}
			}
		}
						
		return datosSolicitud;
	}
	
	
	/**
	 * Metodo que llama al SN ANPM_424 (PL/I ANPMR208) para obtener la maxima bonificacion
	 * para un producto, subproducto, tarifa, nuc, periodicidad de interes y version general.
	 * 
	 * @param codProd
	 * @param codSubProd
	 * @param idTarifa
	 * @param nuc
	 * @param periodicidadInteres
	 * @param versionGeneral
	 * @return
	 */
	public static BigDecimal obtenerBonificacionMaxima(BigDecimal codProd, BigDecimal codSubProd, 
			BigDecimal idTarifa, BigDecimal nuc, BigDecimal periodicidadInteres, BigDecimal versionGeneral)
	{
		// Inicializaciones
		BigDecimal bonificacionMaxima = null;
		IContexto contextoEntradaPLI = ContextoFactory.getInstance().getContexto(CTE_CTX_BONIF);
		
		// Reservar memoria para la matriz de pagos
		reservarMemoriaRegistro(contextoEntradaPLI,
			CTE_CTX_BONIF_MATRIZ_BONIFICACIONES_PRODUCTO,
			CTE_CTX_BONIF_LONG_MATRIZ_BONIFICACIONES_PRODUCTO);
		
		// Datos de entrada
		contextoEntradaPLI.put(CTE_CTX_BONIF_PRODUCTO, codProd);
		contextoEntradaPLI.put(CTE_CTX_BONIF_SUBPRODUCTO, codSubProd);
		contextoEntradaPLI.put(CTE_CTX_BONIF_ID_TARIFA, idTarifa);
		contextoEntradaPLI.put(CTE_CTX_BONIF_NUC_EXPEDIENTE, nuc); 
		contextoEntradaPLI.put(CTE_CTX_BONIF_PERIODICIDAD_INTERES, periodicidadInteres);
		contextoEntradaPLI.put(CTE_CTX_BONIF_VERSION_GENERAL, versionGeneral);
		
		// Llamada a ANPMR208
		CtgFacade ctg = new CtgFacade();
		IContexto[] contextoSalidaPLI = ctg.invocarProgramaCics(contextoEntradaPLI, CTE_CTX_PROGRAMA_ANPMR208);
		
		// Obtener bonificacion maxima
		if (contextoSalidaPLI[0].getBigDecimal(CTE_CTX_BONIF_CODIGO_RETORNO).compareTo(BigDecimal.ZERO) == 0)
		{
			// No hay error
			bonificacionMaxima = contextoSalidaPLI[0].getBigDecimal(CTE_CTX_BONIF_BONIFICACION_MAXIMA);
		}
		else
		{
			// Hay error
			String strNuc = "";
			if (null != nuc)
			{
				strNuc = nuc.toString();
			}
		
			BigDecimal codigoError = contextoSalidaPLI[0].getBigDecimal(CTE_CTX_BONIF_CODIGO_ERROR);
			String strCodigoError = "";
			if (null != codigoError)
			{
				strCodigoError = codigoError.toString();
			}
			
			String strDescripcionError = contextoSalidaPLI[0].getString(CTE_CTX_BONIF_DESCRIPCION_ERROR);
		
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_LLAMADA_ANPMR208,
				new String[] {},
				new String[] {
						strNuc, 
						strCodigoError,
						strDescripcionError},
				null);
					
		}
			

		// Devolver bonificacion maxima
		return bonificacionMaxima;
	}

	
	/**
	 * Reserva memoria en el contexto para el registro que se pasa como parámetro
	 * @param contexto Contexto donde reservar memoria
	 * @param strCtxtoIdRegistro Id del registro a crear
	 * @param iRegistrosSize Número de registros a crear
	 */
	private static void reservarMemoriaRegistro(IContexto contexto,
			String strCtxtoIdRegistro, int iRegistrosSize)
	{
		List<IRegistro> lstRegistros = new ArrayList<IRegistro>(iRegistrosSize);
		for (int i = 0; i < iRegistrosSize; i++)
		{
			lstRegistros.add(ContextoFactory.getInstance().getRegistro(contexto, strCtxtoIdRegistro));
		}
		contexto.put(strCtxtoIdRegistro, lstRegistros.toArray(new IRegistro[0]));
	}
	
	
	/**
	 * Devuelve la referencia a partir del campo TipoReferencia del contexto de interes
	 * @param strIntPropTipoReferencia
	 * @param contextoInteres
	 * @return referencia
	 */
	public static BigDecimal obtenerReferencia(
			final String strIntPropTipoReferencia, IContexto contextoInteres)
	{
		BigDecimal referencia = BigDecimal.ZERO;
		String tipoReferencia = contextoInteres.getBigDecimal(strIntPropTipoReferencia).toString();
		
		if (!UtilidadesTramitacion.isEmptyOrNullString(tipoReferencia))
		{
			if (tipoReferencia.equals(Constantes.REF_9800)){
				referencia = BigDecimal.ONE;
			}
			else if (tipoReferencia.equals(Constantes.REF_1300)) {
				referencia = BigDecimal.valueOf(4);
			}
			else if (tipoReferencia.equals(Constantes.REF_2400)) {
				referencia = BigDecimal.valueOf(2);
			}
			else if (tipoReferencia.equals(Constantes.REF_0909)) {
				referencia = BigDecimal.valueOf(3);
			}
			else if (tipoReferencia.equals(Constantes.REF_2800)) {
				referencia = BigDecimal.valueOf(5);
			}
			else if (tipoReferencia.equals(Constantes.REF_2512)) {
				referencia = BigDecimal.valueOf(6);
			}
		}
		
		return referencia;
	}
	
	
	/**
	 * Devuelve la referencia a partir del campo TipoReferencia del contexto de interes para INE
	 * @param strIntPropTipoReferencia
	 * @param contextoInteres
	 * @return referencia
	 */
	public static BigDecimal obtenerReferenciaINE(
			final String strIntPropTipoReferencia, IContexto contextoInteres)
	{
		BigDecimal referencia = BigDecimal.ZERO;
		String tipoReferencia = contextoInteres.getBigDecimal(strIntPropTipoReferencia).toString();
		
		if (!UtilidadesTramitacion.isEmptyOrNullString(tipoReferencia))
		{
			if (tipoReferencia.equals(Constantes.REF_9803)){
				referencia = BigDecimal.ONE;
			}
			else if (tipoReferencia.equals(Constantes.REF_9806)) {
				referencia = BigDecimal.valueOf(2);
			}
			else if(tipoReferencia.equals(Constantes.REF_9800))
			{
				referencia = BigDecimal.valueOf(7);
			}
			else if (tipoReferencia.equals(Constantes.REF_9812)) {
				referencia = BigDecimal.valueOf(3);
			}
			else if (tipoReferencia.equals(Constantes.REF_3900)) {
				referencia = BigDecimal.valueOf(4);
			}
			else if (tipoReferencia.equals(Constantes.REF_1300)) {
				referencia = BigDecimal.valueOf(5);
			}
			else if (tipoReferencia.equals(Constantes.REF_2500)) {
				referencia = BigDecimal.valueOf(6);
			}
		}
		
		return referencia;
	}
	
	
	/**
	 * Usa el servicio 100-307 para obtener la descripción de la oficina
	 * @param bidOficina Id del centro
	 * @return Nombre del centro correspondiente a la oficina
	 */
	public static String getNombreOficina(final BigDecimal bidOficina)
	{
		final int POSICION_TIRA_CENTRO 				= 0;
		final String strCtxtoCentro = "CG057CON";
		final String strCtxtoCmpoDescripcion = "CG057C031";
		final int iCGAL = 100;
		final int iCodConsultaCentroSrv = 307;
		
		final IDatosEntradaTx datosEntradaConsultaCentro = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(),
				iCGAL, iCodConsultaCentroSrv);
		datosEntradaConsultaCentro.addCampo(POSICION_TIRA_CENTRO, bidOficina.toString());
		IContexto[] contextosCentro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaCentro);
		String strNombreOficina = Constantes.CTE_STRING_EMPTY;
		for (IContexto contextoCentro : contextosCentro)
		{
			if (strCtxtoCentro.equals(contextoCentro.getNombre()))
			{
				strNombreOficina = contextoCentro.getString(strCtxtoCmpoDescripcion);
			}
			
		}
		return strNombreOficina;
	}
	
	/**
	 * Método que comprueba si la solicitud es de un préstamo refaccionario comprobando el atributo correspondiente
	 * y si este está a 0, comprueba que este con el convenio que está en el parametro de configuracion.
	 * Este método NO consulta a la AN25TB01
	 * 
	 * @param refaccionario
	 * @param producto
	 * @param lineaColectivo
	 * @param colectivo
	 * 
	 * @return 
	 */
	public static boolean esRefaccionario(
								BigDecimal refaccionario, 
								BigDecimal producto, 
								BigDecimal lineaColectivo, 
								BigDecimal colectivo) 
	{
		boolean coincide = false;
		
		if(null != refaccionario)
		{
			if(0 == BigDecimal.ZERO.compareTo(refaccionario))
			{
				if(null != producto
				&& null != lineaColectivo
				&& null != colectivo)
				{
					coincide = UtilidadesComun.coincideEducredito(
																producto.toString(), 
																lineaColectivo.toString(),
																colectivo.toString());
				}
			}
			else if(0 == BigDecimal.ONE.compareTo(refaccionario))
			{
				coincide = true;
			}
		}
		
		return coincide;
	}
	
	/**
	 * Método que comprueba si un préstamo es refaccionario a partir de su nuc.
	 * Este método consulta a la AN25TB01
	 * 
	 * @param nucSolicitud
	 * @return un booleano a true o false segun sea o no refaccionario.
	 */
	public static boolean esRefaccionario(BigDecimal nuc)
	{
		boolean refaccionario = false;
		
		GestionDatosSolicitud gds =  new GestionDatosSolicitud();
		DatosSolicitudC solicitud = gds.getUltimaVersion(nuc);
		
		if(null != solicitud)
		{
			refaccionario = UtilidadesTramitacion.esRefaccionario(
															solicitud.getRefaccionario(), 
															solicitud.getProducto(), 
															solicitud.getLineaColectivo(), 
															solicitud.getIdColectivo());
		}
		
		return refaccionario;
	}
	
	
	
	/**
	 * Método que llama al programa PESCR201 (SN PESC_201) de prescriptores para generar el mandato SEPA
	 * @param nucSolicitud
	 */
	
	public static void generarMandatoSEPA(BigDecimal nucExpediente)
	{
		IContexto contextoEntrada = ContextoFactory.getInstance().getContexto("PESCN201");
			
		// Campos de entrada
		contextoEntrada.put("PESCN201900", BigDecimal.ZERO);   //código error
		contextoEntrada.put("PESCN201910", "");                //texto error
		contextoEntrada.put("PESCN201010", nucExpediente);     //NUC expediente
		contextoEntrada.put("PESCN201020", "S");               //imprimir S/N
			
		CtgFacade ctg = new CtgFacade();
		final IContexto[] contextosSalida = ctg.invocarProgramaCics(contextoEntrada, "PESCR201");
		
	    /*if ((null == contextosSalida) || (!BigDecimal.ZERO.equals(contextosSalida[0].getBigDecimal("PESCN201900"))))
		{
			ServicioNegocio.rollback(CodigosError.,
									 null,
									 new String[] {nucExpediente.toString()},
									 null);
		}*/
		
	}	

	
	
	/**
	 * Método que llama al ANPM_296 para sacar el importe del préstamo para dejar en depósito
	 * 
	 * @param nucSolicitud
	 * @return IContexto[]
	 */
	public static IContexto[] sacaDepositoCaja(BigDecimal nuc,String numeroAsiento){
		
		// Rellenar campos de entrada al servicio
		IDatosEntradaTx datosEntrada = 
			ServicioNegocio.getPrograma(ServicioNegocio.getContexto(),
					Constantes.ID_CUENTA_ANPM,
					Constantes.CTE_CO_SACA_DEPOSITO_CAJA);
		
		if (null != nuc){
			datosEntrada.addCampo("NUC", nuc);
		}
		datosEntrada.addCampo("numeroAsiento", numeroAsiento);

		// Llamada al servicio ANPM_296
		final IContexto[] salida = ServicioNegocio.invocarServicio(
				ServicioNegocio.getContexto(), datosEntrada);
						
		return salida;
	}
		
	
	/**
	 * Metodo que lee el tipo de prescriptor devuelto por expedientes y lo traduce al 
	 * tipo de prescriptor de ANPM.
	 * 
	 * @param datosExpediente datos devueltos por el servicio EEXP_272.
	 * @return 
	 */
	public static BigDecimal obtenerTipoPrescriptor(IContexto[] datosExpediente)
	{
		// Inicializaciones 
		String tipoPrescriptorEEXP = null;
		BigDecimal tipoPrescriptorANPM = null;
		
		// Obtener tipo prescriptor
		if ((null != datosExpediente) && (0 < datosExpediente.length))
		{
			// Leer tipo prescriptor de expediente
			tipoPrescriptorEEXP = datosExpediente[0].getString(CTE_CMPO_CTX_TIPO_PRESCRIPTOR);
			
			// Traducir a tipo prescriptor ANPM
			tipoPrescriptorANPM = UtilidadesTramitacion.traducirTipoPrescriptor(tipoPrescriptorEEXP);			
		}
		
		// Devolver tipo prescriptor
		return tipoPrescriptorANPM;
	}
	
}