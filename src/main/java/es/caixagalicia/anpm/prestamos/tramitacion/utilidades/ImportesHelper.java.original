/**/
package es.caixagalicia.anpm.prestamos.tramitacion.utilidades;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.DecimalFormatSymbols;
import java.util.Locale;

import org.apache.commons.lang.StringUtils;

import es.caixagalicia.ifrt.core.ContextoSistema;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.log.LogHelper;
import es.caixagalicia.ifrt.util.Helper;

/**
 * Clase que contiene los métodos necesarios para aplicar redondeo de los
 * importes según su divisa acepte o no decimales.
 * 
 * @author G2510
 *
 */
public final class ImportesHelper
{	
	/**
	 * Tipos de redondeos que pueden ser aplicados sobre importes 
	 * @author f002014
	 */
	public static enum TipoRedondeo
	{
		UP,
		DOWN
	}
	
	/**
	 * Posible número de decimales que pueden ser contemplados por un importe
	 * @author f002014
	 */
	public static enum NumeroDecimales
	{
		CERO,
		UNO,
		DOS		
	}
	
	/**
	 * Tipo de redondeo por defecto que se utilizará en la clase 
	 */
	private static final int TIPO_REDONDEO_DEFECTO = BigDecimal.ROUND_DOWN;
	
	/**
	 * Número de decimales por defecto
	 */
	private static final int NUMERO_DECIMALES_DEFECTO = 2;
	
	/**
	 * Separador de decimales en un numero de tipo bigdecimal
	 */
	private static final String SEPARADOR_DECIMALES = "\\.";
	
	/**
	 * Nombre de la clase que se utilizará para lanzar excepciones y escribir
	 * mensajes en el Log de la plataforma
	 */
	private static final String NOMBRE_CLASE = ImportesHelper.class.getSimpleName();
	
	/**
	 * Objeto que utilizaremos para escribir mensajes en el log de la plataforma
	 */
	private static final LogHelper OBLOGHELPER = UtilidadesTramitacion.getLoggerANPM(NOMBRE_CLASE);
	
	/**
	 * Numero 0 que utilizaremos para comprobaciones en llamadas a funciones
	 */
	private static final Integer INT_0 = Integer.valueOf(0);
	
	private static final int INT_3 = 3;
	
	/**
	 * Constructor por defecto de la clase
	 */
	private ImportesHelper()
	{
		
	}
	
	/**
	 * Método que redondea los decimales del importe cuyo
	 * valor parametriza el método
	 * 
	 * @param dcImporteIn El importe cuyo valor deseamos redondear 
	 * @param obNumeroDecimales El número de decimales soportados
	 * @param obTipoRedondeo El tipo de redondeo aplicado
	 * puede contemplar este parámetro es BigDecimal.ROUND_DOWN o BigDecimal.ROUND_UP
	 * @return El importe con el redondeo aplicado
	 */
	public static BigDecimal redondeaImporte(
			BigDecimal dcImporteIn, 
			NumeroDecimales obNumeroDecimales,
			TipoRedondeo obTipoRedondeo)
	{
		BigDecimal dcImporteOut = BigDecimal.ZERO;
		BigDecimal dcImporteAux = BigDecimal.ZERO;		
		int inTipoRedondeo = 0;
		int inNumeroDecimales = 0;
		
										
		/*
		 * Transformamos los tipos enumerados en parámetros que comprenda los métodos de 
		 * redondeo de la clase BigDecimal
		 */				
		inTipoRedondeo = obtenerTipoRedondeo(obTipoRedondeo);		
		inNumeroDecimales = obtenerNumeroDecimales(obNumeroDecimales);
		
		if (null != dcImporteIn)
		{
			dcImporteAux = dcImporteIn;
		}
		
		//Aplicamos el redondeo
		dcImporteOut = dcImporteAux.setScale(inNumeroDecimales, inTipoRedondeo);
				
		return dcImporteOut;
	}

	/**
	 * Método que redondea un importe al número de decimales por defecto 
	 * soportado por la aplicación
	 * @param dcImporteIn El importe que deseamos redondear
	 * @return El importe con el redondeo aplicado
	 */
	public static BigDecimal redondeaImporte(BigDecimal dcImporteIn)
	{
		BigDecimal dcImporteOut = BigDecimal.ZERO;
		NumeroDecimales obNumeroDecimales = null;
		TipoRedondeo obTipoRedondeo = null;
		
		
		//Invocamos a la sobrecarga del método
		dcImporteOut = redondeaImporte(dcImporteIn, 
					obNumeroDecimales, 
					obTipoRedondeo);
				
		return dcImporteOut;
	}
	
	/**
	 * Método que aplica un redondeo sobre un importe teniendo en cuenta si 
	 * la moneda soporta o no decimales
	 * 
	 * @param dcImporteIn El importe sobre el que deseamos aplicar un redondeo
	 * @param blMonedaConDecimales Indicador de si la moneda acepta o no decimales
	 * @return El importe con el redondeo aplicado
	 */
	public static BigDecimal redondeaImporte(BigDecimal dcImporteIn, 
			boolean blMonedaConDecimales)
	{
		NumeroDecimales obNumeroDecimales = null;
		BigDecimal dcImporteOut = BigDecimal.ZERO;
		
		
		if (!blMonedaConDecimales)
		{
			obNumeroDecimales = NumeroDecimales.CERO;
		}
		
		//Aplicamos el redondeo
		dcImporteOut = redondeaImporte(
				dcImporteIn, 
				obNumeroDecimales, 
				null);
		
		return dcImporteOut;
	}
	
	/**
	 * Método que aplica el redondeo sobre un importe en función de la
	 * divisa del mismo
	 * 
	 * @param dcImporteIn El importe que deseamos redondear
	 * @param strDivisaImporte La divisa asociada al importe
	 * @param strEntidadIn La entidad para la que se va a aplicar
	 * el redondeo
	 * @param obTipoRedondeoIn El tipo de redondeo aplicado
	 * @param obNumeroDecimalesIn El numero de decimales contemplados en
	 * el importe de salida del método
	 * @return El importe redondeado si aplica
	 */
	public static BigDecimal redondeaImporte(
			BigDecimal dcImporteIn, 
			String strDivisaImporte, 
			String strEntidadIn,
			TipoRedondeo obTipoRedondeoIn, 
			NumeroDecimales obNumeroDecimalesIn) 
	{
		final String strNombreParImp = "dcImporteIn";
		final String strNombreParDiv = "strDivisaImporte";			
		boolean blDivisaConDecimales = false;		
		BigDecimal dcImporteOut = BigDecimal.ZERO;
		AbstractItal obItalHelper = null;
		NumeroDecimales obNumeroDecimales = null;	
		String strEntidad = null;
		
		
		//Comprobamos que el valor de los parámetros obligatorios no sean nulos
		UtilidadesTramitacion.comprobarParametroNulo(dcImporteIn, strNombreParImp, NOMBRE_CLASE);
		UtilidadesTramitacion.comprobarParametroNulo(strDivisaImporte, strNombreParDiv, NOMBRE_CLASE);
		
		/*
		 * Si no se especifica la entidad para la que se va a realizar el redondeo, 
		 * suponemos que se corresponde con la entidad en la que se ejecuta la aplicacion
		 */
		strEntidad = strEntidadIn;
		
		if (Helper.isNullOrEmpty(strEntidad).booleanValue())
		{
			strEntidad = ContextoSistema.getInstance().getEntidad();
		}
		
		//Instanciamos un objeto que nos ayudará a obtener la información de la divisa
		obItalHelper = AbstractItal.fromEntidad(strEntidad);
		
		//Obtenemos si la divisa tiene o no decimales
		blDivisaConDecimales = obItalHelper.divisaConDecimales(strDivisaImporte);		
		
		//Comprobamos si la divisa soporta decimales
		if (blDivisaConDecimales)
		{
			if (null != obNumeroDecimalesIn)
			{
				obNumeroDecimales = obNumeroDecimalesIn;
			}
			else
			{
				//Por defecto dos decimales
				obNumeroDecimales = NumeroDecimales.DOS;
			}
		}
		else
		{
			obNumeroDecimales = NumeroDecimales.CERO;
		}
		
		//Aplicamos el redondeo
		dcImporteOut = redondeaImporte(
				dcImporteIn, 
				obNumeroDecimales, 
				obTipoRedondeoIn);
		
		return dcImporteOut;
	}
	
	/**
	 * Método que aplica el redondeo sobre un importe para una entidad
	 * determinada teniendo en cuenta el tipo de redondeo y numero de decimales
	 * por defecto establecidos para la aplicacion
	 * 
	 * @param dcImporteIn El importe que deseamos redondear
	 * @param strDivisaImporte La divisa asociada al importe
	 * @param strEntidad La entidad en la que se va a aplicar el redondeo 
	 * @return El importe con el redondeo aplicado
	 */
	public static BigDecimal redondeaImporte(
			BigDecimal dcImporteIn, 
			String strDivisaImporte, 
			String strEntidad) 
	{
		BigDecimal dcImporteOut = BigDecimal.ZERO;
	
		
		//Invocamos a la sobrecarla local del metodo
		dcImporteOut = redondeaImporte(dcImporteIn, 
				strDivisaImporte, 
				strEntidad,
				null, 
				null); 
		
		return dcImporteOut;
	}
	
	/**
	 * Método que aplica un redondeo sobre el importe cuyo valor parametriza el método
	 * 
	 * @param dcImporteIn El importe cuyo valor deseamos redondear
	 * @param strDivisaImporte La divisa asociada al importe
	 * @param strEntidad La entidad para la que se realiza el redondeo
	 * @param obNumeroDecimales El numero de decimales totales que deseamos obtener en el resultado de salida
	 * @return El importe redondeado
	 */
	public static BigDecimal redondeaImporte(
			BigDecimal dcImporteIn, 
			String strDivisaImporte, 
			String strEntidad, 
			NumeroDecimales obNumeroDecimales) 
	{
		BigDecimal dcImporteOut = BigDecimal.ZERO;
	
		
		//Invocamos a la sobrecarla local del metodo
		dcImporteOut = redondeaImporte(dcImporteIn, 
				strDivisaImporte, 
				strEntidad,
				null, 
				obNumeroDecimales); 
		
		return dcImporteOut;
	}
	
	/**
	 * Método que aplica el redondeo sobre un importe teniendo en 
	 * cuenta el tipo de redondeo y numero de decimales
	 * por defecto establecidos para la aplicacion.
	 * 
	 * @param dcImporteIn El importe que deseamos redondear
	 * @param strDivisaImporte La divisa asociada al importe
	 * @return El importe con el redondeo aplicado
	 */
	public static BigDecimal redondeaImporte(
			BigDecimal dcImporteIn, 
			String strDivisaImporte) 
	{
		BigDecimal dcImporteOut = BigDecimal.ZERO;			
		
		//Invocamos a la sobrecarla local del metodo
		dcImporteOut = redondeaImporte(dcImporteIn, 
				strDivisaImporte, 
				null,
				null, 
				null); 
		
		return dcImporteOut;
	}
	
	/**
	 * Método que obtiene el número de decimales a partir del tipo enumerado que lo
	 * representa
	 * 
	 * @param obNumeroDecimales El tipo enumerado para el que deseamos obtener el 
	 * número de decimales
	 * @return El número entero que representa el número de decimales asociado
	 * al tipo enumerado 
	 */
	private static int obtenerNumeroDecimales(NumeroDecimales obNumeroDecimales)
	{
		int inNumeroDecimales = 0;		

		
		if (null != obNumeroDecimales)
		{
			//Numero de decimales
			switch (obNumeroDecimales)
			{
				case CERO:
				{
					inNumeroDecimales = 0;
					break;
				}

				case UNO:
				{
					inNumeroDecimales = 1;
					break;
				}

				case DOS:
				{
					inNumeroDecimales = 2;
					break;
				}
				default:
				{
					inNumeroDecimales = NUMERO_DECIMALES_DEFECTO;
					break;
				}
			}
		}
		else
		{
			inNumeroDecimales = NUMERO_DECIMALES_DEFECTO;
		}

		return inNumeroDecimales;
	}

	/**
	 * Método que obtiene el tipo de redondeo a partir del tipo enumerado
	 * que lo representa
	 * 
	 * @param obTipoRedondeo El tipo enumerado que representa el tipo de 
	 * redondeo
	 * @return El número entero que representa el tipo de redondeo
	 */
	private static int obtenerTipoRedondeo(TipoRedondeo obTipoRedondeo)
	{
		int inTipoRedondeo = 0;
				
		
		if (null != obTipoRedondeo)
		{			
			switch (obTipoRedondeo)
			{
				case DOWN:
				{
					inTipoRedondeo = BigDecimal.ROUND_DOWN;
					break;
				}
				case UP:
				{
					inTipoRedondeo = BigDecimal.ROUND_UP;
					break;
				}				
				default:
				{
					inTipoRedondeo = TIPO_REDONDEO_DEFECTO;				
					break;
				}
			}
		}
		else
		{
			inTipoRedondeo = TIPO_REDONDEO_DEFECTO;
		}
						
		return inTipoRedondeo;
	}	
	
	/**
	 * Método que comprueba si un determinado importe es correcto teniendo en cuenta 
	 * si la divisa contempla o no decimales
	 * 
	 * @param dcImporte El importe que deseamos comprobar
	 * @param strDivisa La divisa del importe
	 * @param strEntidadIn La entidad para la que se va a ejecutar el método
	 * @param strNombreParDescImporte El nombre del parámetro en la lista de 
	 * mensajes multiidioma que contiene la descripcion del importe que no puede
	 * contener parte decimal
	 */
	public static void comprobarPosibilidadDecimalesImp(
			BigDecimal dcImporte, 
			String strDivisa,
			String strEntidadIn,
			String strNombreParDescImporte)
	{
		final String strNombreParDiv = "strDivisa";		
		String strEntidad = null;
		AbstractItal obItalHelper = null;
		boolean blDivisaConDecimales = false;				
		
		// Pedido por tony, los importes cero, no se comprueba divisa.
		if ((null != dcImporte) && (0 != BigDecimal.ZERO.compareTo(dcImporte)))
		{
			//Comprobamos que se envíe la divisa asociada al importe 
			UtilidadesTramitacion.comprobarParametroNulo(strDivisa, strNombreParDiv, NOMBRE_CLASE);
			
			/*
			 * Si no se especifica la entidad, suponemos que se corresponde con la entidad desde
			 * la que se ejecuta la aplicacion
			 */
			strEntidad = strEntidadIn;
			
			if (Helper.isNullOrEmpty(strEntidad).booleanValue())
			{
				strEntidad = ContextoSistema.getInstance().getEntidad();
			}
		
			//Instanciamos un objeto que nos permitira obtener informacion de la divisa
			obItalHelper = AbstractItal.fromEntidad(strEntidad);
			
			//Obtenemos si la divisa permite o no decimales
			blDivisaConDecimales = obItalHelper.divisaConDecimales(strDivisa);
			
			//Comprobamos si el importe contiene o no decimales
			comprobarPosibilidadDecimalesImp(dcImporte, 
					strNombreParDescImporte, 
					blDivisaConDecimales);
		}						
	}

	/**
	 * Metodo que comprueba si un determinado importe contiene o no decimales
	 * en función de si la divisa asociada los soporta
	 * 
	 * @param dcImporte El importe cuyo valor deseamos comprobar
	 * @param strNombreParDescImporte El nombre del campo que estamos 
	 * comprobando en la lista de mensajes multiidioma  
	 * @param blDivisaConDecimales Indicador de si la divisa soporta o no decimales 
	 */
	public static void comprobarPosibilidadDecimalesImp(BigDecimal dcImporte,
			String strNombreParDescImporte, boolean blDivisaConDecimales)
	{
		final String strMensaje = "La divisa asociada al importe no permite decimales";		
		boolean blImporteConDecimales = false;				
		
		// Pedido por tony, los importes cero, no se comprueba divisa.
		if ((null != dcImporte) && (0 != BigDecimal.ZERO.compareTo(dcImporte)))
		{
			//Comprobamos si el importe contiene decimales
			blImporteConDecimales = contieneDecimalesImporte(dcImporte);

			/*
			 * Si la divisa no soporta decimales y el importe tiene parte decimal, lanzamos
			 * una excepción y hacemos rollback del servicio de negocio
			 */
			if ((!blDivisaConDecimales) && blImporteConDecimales)
			{
				//Escribimos un mensaje en el log de la plataforma
				if (OBLOGHELPER.isDebugEnabled())
				{
					OBLOGHELPER.debug(strMensaje);
				}				

				//Lanzamos una excepcion y hacemos rollback del servicio de negocio
				ServicioNegocio.rollback(CodigosError.CLAVE_IMPORTE_SIN_DECIMALES, null, new String[] {dcImporte.toString()}, null);
			}
		}
	}
	
	/**
	 * Método que comprueba si el importe tiene o no decimales en funcion de si la divisa
	 * asociada contiene o no decimales 
	 * 
	 * @param dcImporte El importe cuyo valor deseamos comprobar si tiene o no
	 * decimales
	 * @param blDivisaConDecimales Indicador de si la divisa soporta o no decimales
	 */
	public static void comprobarPosibilidadDecimalesImp(
			BigDecimal dcImporte, 
			boolean blDivisaConDecimales)
	{		
		comprobarPosibilidadDecimalesImp(dcImporte,	null, 
				blDivisaConDecimales);	
	}
	
	/**
	 * Método que realiza una division segura entre dos importes, 
	 * usa el redondeo RoundingMode.DOWN y por defecto 2 decimales.
	 * 
	 * @param dcDividendo Dividendo
	 * @param dcDivisor Divisor
	 * @return Resultado de la division
	 */
	public static BigDecimal realizaDivisionSegura(BigDecimal dcDividendo, BigDecimal dcDivisor)
	{
		final String strNombreParDividendo = "dcDividendo";
		final String strNombreParDivisor = "dcDivisor";
		BigDecimal dcResultado = BigDecimal.ZERO;
		
		
		//Comprobamos que el valor de los parametros no sea nulo
		UtilidadesTramitacion.comprobarParametroNulo(dcDividendo, strNombreParDividendo, NOMBRE_CLASE);
		UtilidadesTramitacion.comprobarParametroNulo(dcDivisor, strNombreParDivisor, NOMBRE_CLASE);
		
		dcResultado = dcDividendo.divide(dcDivisor, 
				NUMERO_DECIMALES_DEFECTO, 
				RoundingMode.DOWN);
						
		return dcResultado;
	}
	
	/**
	 * Método que realiza una division segura entre dos importes
	 * 
	 * @param dcDividendo Dividendo
	 * @param dcDivisor Divisor
	 * @param intDecimales	Numero de decimales.
	 * @param RoundingMode Metodo de redondeo por defecto.
	 * @return Resultado de la division
	 */
	public static BigDecimal realizaDivisionSegura(BigDecimal dcDividendo, BigDecimal dcDivisor,
			int intDecimales, RoundingMode roundingMode)
	{
		final String strNombreParDividendo = "dcDividendo";
		final String strNombreParDivisor = "dcDivisor";
		final String strNombreDecimales = "intDecimales";
		BigDecimal dcResultado = BigDecimal.ZERO;
		
		//Comprobamos que el valor de los parametros no sea nulo
		UtilidadesTramitacion.comprobarParametroNulo(dcDividendo, strNombreParDividendo, NOMBRE_CLASE);
		UtilidadesTramitacion.comprobarParametroNulo(dcDivisor, strNombreParDivisor, NOMBRE_CLASE);
		
		if (intDecimales < 0)
		{
			UtilidadesTramitacion.comprobarParametroNulo(null, strNombreDecimales, NOMBRE_CLASE);
		}
		
		dcResultado = dcDividendo.divide(dcDivisor, intDecimales, roundingMode);
						
		return dcResultado;
	}
	
	/**
	 * Método que comprueba si un determinado importe es correcto teniendo en
	 * cuenta si la divisa tiene o no decimales 
	 * 
	 * @param dcImporte El importe que deseamos comprobar si es o no correcto
	 * @param strDivisa La divisa asociada al importe
	 * @param strEntidadIn La entidad para la que se va a ejecutar el metodo
	 */
	public static void comprobarPosibilidadDecimalesImp(
			BigDecimal dcImporte, 
			String strDivisa,
			String strEntidadIn)
	{
		comprobarPosibilidadDecimalesImp(dcImporte, strDivisa, strEntidadIn, null);		
	}
	
	/**
	 * Método que comprueba si un determinado importe es correcto teniendo en
	 * cuenta si la divisa tiene o no decimales. Se tiene en cuenta como entidad de 
	 * ejecucion la entidad para la que se ejecuta la aplicacion 
	 * 
	 * @param dcImporte El importe que deseamos comprobar si es o no correcto
	 * @param strDivisa La divisa asociada al importe
	 */
	public static void comprobarPosibilidadDecimalesImp(
			BigDecimal dcImporte, 
			String strDivisa)
	{
		comprobarPosibilidadDecimalesImp(dcImporte, strDivisa, null, null);		
	}
	
	/**
	 * Método que comprueba si un determinado importe contiene o no parte decimal
	 * 
	 * @param dcImporte El importe que deseamos comprobar
	 * @return true si el importe contiene decimales y false en caso contrario
	 */
	public static boolean contieneDecimalesImporte(BigDecimal dcImporte)
	{		
		boolean blContieneDecimales = false;
		String []matPartesImporte = null;
		String strImporte = null;		
		Integer inParteDecimal = null;
		
		
		//Comprobamos si el importe contiene decimales
		if ((null != dcImporte) && (0 != dcImporte.scale()))
		{			
			//Si contiene parte decimal, comprobamos si alguno de los decimales es distinto de 0
			strImporte = dcImporte.toString();
			matPartesImporte = strImporte.split(SEPARADOR_DECIMALES);			
			
			//Hay parte decimal. Comprobamos si es superior a 0
			if ((null != matPartesImporte) && (2 == matPartesImporte.length) && 
				(Helper.isNumeric(matPartesImporte[1])).booleanValue())
			{
				inParteDecimal = new Integer(matPartesImporte[1]);
				blContieneDecimales = (0 < inParteDecimal.compareTo(INT_0));
			}			
		}
		
		return blContieneDecimales;
	}

	/**
	 * Metodo que formatea un importe.
	 * 
	 * @param inImporte
	 * 
	 * @return String importe formateado sin ceros a la izquierda y con dos decimales.
	 * 
	 */
	public static String formatearImporte(BigDecimal inImporte)
	{	
		String strDatoFinal = StringUtils.EMPTY;
		String []matPartesImporte = null;
		String strImporte = null;		
		Integer inParteEntera = null;
		String strParteEntera = StringUtils.EMPTY;
		int tamanoParteEntera = 0;
		String strParteDecimal = null;
		int contador = 0;
		boolean signoNegativo = false;
		BigDecimal importe = null;
		
		importe = UtilidadesTramitacion.comprobarDatoNull(inImporte);
		
		if (0 < BigDecimal.ZERO.compareTo(importe))
		{
			signoNegativo = true;
			importe = importe.multiply(new BigDecimal("-1"));
		}
		
		//Comprobamos si el importe contiene decimales
		if (0 != importe.scale())
		{			
			//Si contiene parte decimal, comprobamos si alguno de los decimales es distinto de 0
			strImporte = importe.toString();
			matPartesImporte = strImporte.split(SEPARADOR_DECIMALES);			
			
			//Hay parte decimal
			if ((null != matPartesImporte) && (0 < matPartesImporte.length))
			{
				if (Helper.isNumeric(matPartesImporte[0]).booleanValue())
				{
					inParteEntera = new Integer(matPartesImporte[0]);
				}
				
				if (2 == matPartesImporte.length)
				{
					if (Helper.isNumeric(matPartesImporte[1]).booleanValue())
					{
						strParteDecimal = UtilidadesTramitacion.comprobarDatoNull(matPartesImporte[1]);
					}
				}
			}			
		}
		else
		{
			strImporte = importe.toString();
			
			if (Helper.isNumeric(strImporte).booleanValue())
			{
				inParteEntera = new Integer(strImporte);
			}
			
		}
	
		if (null == inParteEntera)
		{
			inParteEntera = new Integer("0");
		}
		
		if (Helper.isNullOrEmpty(strParteDecimal).booleanValue())
		{
			strParteDecimal = "0";
		}
		
		strParteEntera = inParteEntera.toString().trim();
		
		tamanoParteEntera = strParteEntera.length(); 
		while (0 < tamanoParteEntera)
		{
			strDatoFinal = strParteEntera.substring(tamanoParteEntera - 1) + strDatoFinal;
			strParteEntera = strParteEntera.substring(0, tamanoParteEntera - 1);
			tamanoParteEntera = strParteEntera.length();
			contador = contador + 1;
			
			if ((INT_3 == contador) && (0 < tamanoParteEntera))
			{
				contador = 0;
				strDatoFinal = "." + strDatoFinal;
			}
		}
		
		strParteDecimal = StringUtils.rightPad(strParteDecimal, 2, '0');
		strDatoFinal = strDatoFinal + "," + strParteDecimal.substring(0, 2);
		
		if (signoNegativo)
		{
			strDatoFinal = "-" + strDatoFinal;
		}
				
		return strDatoFinal;
	}
	
	
	/**
	 * @param formato
	 * @return
	 */
	public static String formatearDecimal(BigDecimal decimal)
	{
		
		DecimalFormatSymbols simbolos = new DecimalFormatSymbols(new Locale("es", "ES"));
		simbolos.setDecimalSeparator(',');
		simbolos.setGroupingSeparator('.');
		java.text.DecimalFormat decimalFormat = 
			new java.text.DecimalFormat("###,###,###,###,##0.00", simbolos);
		return decimalFormat.format(decimal);

	}
	
}
