package es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion;

import java.math.BigDecimal;
import org.apache.commons.lang.StringUtils;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.SubProductoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.SubProductoEng;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.CodigosError;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.destinos.DestinosC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.ResultadoDatosSolicitudVO;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.mensajes.Mensaje;

/**
 * Clase que contiene métodos para el cálculo de la cuota y comprobaciones Triad para
 * la solicitud de préstamos personales
 *
 * @author V362374
 */
public class ControlTriad {

    /**
     * Método que realiza la llamada al ANPM_403 para el cálculo de la cuota scoring
     *
     * @param solicitud
     * @return
     */
    public BigDecimal calculoCuotaScoring(DatosSolicitudC solicitud, BigDecimal producto, BigDecimal subproducto, BigDecimal interesInicial) {
        final String CUOTA = "ANPMN305010";
        IContextoEjecucion contexto = ServicioNegocio.getContexto();
        IDatosEntradaTx entrada = ServicioNegocio.getPrograma(contexto, IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_CC, IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_CO);
        // La selección de parámetros de entrada se ha realizado a partir de la existente en
        // AbstractObtencionDatosSolicitudPrestamo:1771
        entrada.addCampo(IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_IMPORTE, solicitud.getImporteSolicitado());
        entrada.addCampo(IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_PLAZO, solicitud.getPlazoTotal());
        if (null != solicitud.getCondicionesInteres() && solicitud.getCondicionesInteres().size() > 0) {
            entrada.addCampo(IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_NUC_EXPEDIENTE, solicitud.getDatosSolicitudKey().getNucExpediente());
            BigDecimal interesSolicitud = solicitud.getCondicionesInteres().get(0).getIntInteres();
            if (null != interesSolicitud && 0 != interesSolicitud.compareTo(BigDecimal.ZERO)) {
                entrada.addCampo(IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_INTERES_INICIAL, interesSolicitud);
            }
        } else {
            entrada.addCampo(IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_COD_PROD, producto);
            entrada.addCampo(IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_COD_SUBPROD, subproducto);
            if (null != interesInicial && 0 != interesInicial.compareTo(BigDecimal.ZERO)) {
                entrada.addCampo(IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_INTERES_INICIAL, interesInicial);
            }
        }
        return ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada)[0].getBigDecimal(CUOTA);
    }

    /**
     * Sobrecarga del metodo que calcula la cota cuando no pasamos el interés inicial
     * @param solicitud
     * @param producto
     * @param subproducto
     * @return la cuota scoring
     */
    public BigDecimal calculoCuotaScoring(DatosSolicitudC solicitud, BigDecimal producto, BigDecimal subproducto) {
        return calculoCuotaScoring(solicitud, producto, subproducto, null);
    }

    /**
     * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
     * desde el alta de solicitud ANPM_151
     *
     * @param resultado
     */
    public IContexto[] calculoPreScoringProactivo(String operacion, BigDecimal nuc, BigDecimal cuota, BigDecimal importe, String canal, String tarea, String subTipoTarea, BigDecimal producto, BigDecimal subproducto, String clave) {
        final int PRESCORING_CC = 506;
        final int PRESCORING_CO = 23;
        // Campos de entrada del servicio de negocio 506-023
        final String PRESCORING_OPERACION = "OPERACION";
        final String PRESCORING_NUC = "NUC";
        final String PRESCORING_CUOTA = "CUOTA";
        final String PRESCORING_IMPORTE = "IMPORTE";
        final String PRESCORING_CANAL = "CANAL";
        final String PRESCORING_TAREA = "TAREA";
        final String PRESCORING_SUBTIPO_TAREA = "SUBTIPO_TAREA";
        final String PRESCORING_PRODUCTO = "PRODUCTO";
        final String PRESCORING_SUBPRODUCTO = "SUBPRODUCTO";
        final String PRESCORING_CLAVE_PRODUCTO = "CLAVE_PRODUCTO";
        // Llamada al servicio 506-023
        IContextoEjecucion contexto = ServicioNegocio.getContexto();
        IDatosEntradaTx entrada = ServicioNegocio.getPrograma(contexto, PRESCORING_CC, PRESCORING_CO);
        entrada.addCampo(PRESCORING_OPERACION, operacion);
        entrada.addCampo(PRESCORING_NUC, nuc);
        if (null != cuota) {
            entrada.addCampo(PRESCORING_CUOTA, cuota);
        }
        entrada.addCampo(PRESCORING_IMPORTE, importe);
        entrada.addCampo(PRESCORING_CANAL, canal);
        entrada.addCampo(PRESCORING_TAREA, tarea);
        entrada.addCampo(PRESCORING_SUBTIPO_TAREA, subTipoTarea);
        entrada.addCampo(PRESCORING_PRODUCTO, producto);
        entrada.addCampo(PRESCORING_SUBPRODUCTO, subproducto);
        entrada.addCampo(PRESCORING_CLAVE_PRODUCTO, clave);
        return ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
    }

    /**
     * Método que comprueba si por el destino principal de la solicitud ésta
     * siempre debe ir por el circuito largo independientemente de cualquier
     * otro factor o si tiene opción de ir por el corto.
     *
     * @param solicitud
     * @return
     */
    public char circuitoSegunDestino(DestinosC destino) {
        final String AGRUPACION = "NO_TRIAD";
        char circuito = 'S';
        if (null != destino) {
            // Se busca en la tabla 82, si se encuentra irá por el circuito largo.
            IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
            IDatosEntradaTx entrada = ServicioNegocio.getPrograma(contextoEjecucion, Constantes.CTE_SN_BUSQ_PARAM_CC, Constantes.CTE_SN_BUSQ_PARAM_CO);
            entrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_AGRUP, AGRUPACION);
            entrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_NOMBRE, destino.getDestino());
            IContexto[] salida = ServicioNegocio.invocarServicio(contextoEjecucion, entrada);
            if (null != salida && BigDecimal.ZERO.intValue() < salida.length) {
                for (IContexto contexto : salida) {
                    if (contexto.getString("ANPMN031050").trim().equals(destino.getDestino())) {
                        circuito = 'N';
                        break;
                    }
                }
            }
        }
        return circuito;
    }

    /**
     * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
     * desde el alta de solicitud ANPM_151
     *
     * @param resultado
     */
    public IContexto[] calculoPreScoringProactivo(ResultadoDatosSolicitudVO resultado, int indOperacion) {
        // Parámetros constantes de la llamada
        final String OPERACION = "SCO";
        final String CANAL = "O2K";
        final String SOLICITUD = "SOL";
        final BigDecimal PRESTAMO = new BigDecimal("100");
        // Diferenciación entre alta y modificación
        String subTipoTarea;
        if (0 == indOperacion) {
            subTipoTarea = "ALT";
        } else {
            subTipoTarea = "MOD";
        }
        BigDecimal servicio = obtieneServicio(resultado.getDatos().getProducto(), resultado.getDatos().getSubproducto());
        // Llamada al servicio 506-023
        return calculoPreScoringProactivo(OPERACION, resultado.getDatos().getDatosSolicitudKey().getNucExpediente(), calculoCuotaScoring(resultado.getDatos(), null, null), resultado.getDatos().getImporteSolicitado(), CANAL, SOLICITUD, subTipoTarea, PRESTAMO, BigDecimal.ZERO, "ANPM;" + StringUtils.leftPad(resultado.getDatos().getProducto().toString(), 7, '0') + ";" + StringUtils.leftPad(resultado.getDatos().getSubproducto().toString(), 7, '0') + ";" + (null != servicio ? servicio : ""));
    }

    /**
     * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
     * desde el alta de autorización ANPM_210
     *
     * @param resultado
     */
    public IContexto[] calculoPreScoringProactivo(DatosSolicitudC solicitud, int indOperacion) {
        // Parámetros constantes de la llamada
        final String OPERACION = "SCO";
        final String CANAL = "O2K";
        final String SOLICITUD = "SOL";
        final BigDecimal PRESTAMO = new BigDecimal("100");
        // Diferenciación entre alta y modificación
        String subTipoTarea;
        if (0 == indOperacion) {
            subTipoTarea = "ALT";
        } else {
            subTipoTarea = "MOD";
        }
        // Llamada al servicio 506-023
        return calculoPreScoringProactivo(OPERACION, solicitud.getDatosSolicitudKey().getNucExpediente(), calculoCuotaScoring(solicitud, null, null), solicitud.getImporteSolicitado(), CANAL, SOLICITUD, subTipoTarea, PRESTAMO, BigDecimal.ZERO, "ANPM;" + StringUtils.leftPad(solicitud.getProducto().toString(), 7, '0') + ";" + StringUtils.leftPad(solicitud.getSubproducto().toString(), 7, '0'));
    }

    /**
     * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
     * desde el servicio de alta de formalización, ANPM_255, y devuelve un booleano según
     * se satisfagan o no las condiciones Triad
     *
     * @param solicitud
     * @return
     */
    public boolean condicionesTriad(DatosSolicitudC solicitud) {
        // Parámetros constantes de la llamada
        final String OPERACION = "CFO";
        final String CANAL = "O2K";
        final String SOLICITUD = "SOL";
        final BigDecimal PRESTAMO = new BigDecimal("100");
        final String SUBTIPO_TAREA = "ALT";
        final String CONTINUAR_EXPEDIENTE = "XPREN019170";
        return 'S' == calculoPreScoringProactivo(OPERACION, solicitud.getDatosSolicitudKey().getNucExpediente(), calculoCuotaScoring(solicitud, null, null), solicitud.getImporteSolicitado(), CANAL, SOLICITUD, SUBTIPO_TAREA, PRESTAMO, BigDecimal.ZERO, "ANPM;" + StringUtils.leftPad(solicitud.getProducto().toString(), 7, '0') + ";" + StringUtils.leftPad(solicitud.getSubproducto().toString(), 7, '0'))[0].getString(CONTINUAR_EXPEDIENTE).charAt(0);
    }

    /**
     * Método que devuelve un mensaje u otro dependiendo del circuito que recorrerá la
     * solicitud basado en las condiciones Triad asociadas. Usado en el ANPM_454
     *
     * @param nuc
     * @param indOperacion
     * @return
     */
    public String advertenciaCircuito(BigDecimal nuc, int indOperacion) {
        String advertencia = StringUtils.EMPTY;
        // Parámetros constantes de la llamada
        final String OPERACION = "SCO";
        final String CANAL = "O2K";
        final String SOLICITUD = "SOL";
        final BigDecimal PRESTAMO = new BigDecimal("100");
        final String CUOTA = "XPREN019140";
        final String CIRCUITO = "XPREN019160";
        final String ERROR = "XPREN019120";
        // Se recupera la última solicitud incompleta con el nuc para el ANPM_454
        // .getUltimaVersionCompleta(nuc);
        DatosSolicitudC solicitud = new GestionDatosSolicitud().getUltimaVersionIncompleta(nuc);
        if (null != solicitud) {
            // Se comprueba si el destino principal es apto para el circuito corto
            char destinoValido = circuitoSegunDestino(solicitud.getDestinoPrincipal());
            // Diferenciación entre alta y modificación
            String subTipoTarea;
            if (0 == indOperacion) {
                subTipoTarea = "ALT";
            } else {
                subTipoTarea = "MOD";
            }
            // Se calcula la cuotaScoring
            BigDecimal cuotaScoring = calculoCuotaScoring(solicitud, null, null);
            // Se consulta XPRE_023
            IContexto[] resultado = calculoPreScoringProactivo(OPERACION, solicitud.getDatosSolicitudKey().getNucExpediente(), cuotaScoring, solicitud.getImporteSolicitado(), CANAL, SOLICITUD, subTipoTarea, PRESTAMO, BigDecimal.ZERO, "ANPM;" + StringUtils.leftPad(solicitud.getProducto().toString(), 7, '0') + ";" + StringUtils.leftPad(solicitud.getSubproducto().toString(), 7, '0') + ";" + destinoValido);
            if (null != resultado && BigDecimal.ZERO.intValue() < resultado.length) {
                // Si el caracter es 'N' no procede y se ignora.
                switch(resultado[0].getString(CIRCUITO).charAt(0)) {
                    case 'L':
                        // Comprobacion sobre el producto el circuito y la tarifa
                        if (null != solicitud && 0 == solicitud.getProducto().compareTo(new BigDecimal(5005)) && 0 == solicitud.getSubproducto().compareTo(new BigDecimal(496))) {
                            if (solicitud.getIdTarifa().equals(Constantes.CTE_TARIFA_PREAUTORIZADO_OFICINA) || solicitud.getIdTarifa().equals(Constantes.CTE_TARIFA_ESPANA_PREAUTORIZADO_OFICINA) || solicitud.getIdTarifa().equals(Constantes.CTE_TARIFA_PREAUTORIZADO_CALL_CENTER)) {
                                // rollback
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_TARIFA_CON_VALOR_INCORRECTO_CIRCUITO, null, new String[] {}, null);
                            }
                        }
                        // Advertencias sobre el circutio
                        if (806 == resultado[0].getBigDecimal(ERROR).intValue()) {
                            // $OP-LBL-NL-2$
                            advertencia = new Mensaje(ServicioNegocio.getContexto(), OPERACI_N_EXPEDIENTE_EST_NDAR_SUPERA_IMPORTE_388643047).toString() + new Mensaje(ServicioNegocio.getContexto(), M_XIMO_15_000_EUROS_ESTABLECIDO_CLIENTE_285644656).toString() + new Mensaje(ServicioNegocio.getContexto(), INGRESOS_REGULARES_TRAMITACI_N_OFICINA_1582414742).toString();
                        } else {
                            // $OP-LBL-NL-2$ $OP-LBL-NL-2$
                            advertencia = new Mensaje(ServicioNegocio.getContexto(), OPERACI_N_EXPEDIENTE_EST_NDAR_CUMPLE_REQUISITOS_O_1023952686).toString() + new Mensaje(ServicioNegocio.getContexto(), SOLICITADA_1929467663).toString() + cuotaScoring + new Mensaje(ServicioNegocio.getContexto(), EUROS_CALCULADA_299368667).toString() + new Mensaje(ServicioNegocio.getContexto(), TIPO_INTER_S_TRAMO_M_S_CARO_SUPERIOR_1204591582).toString() + new Mensaje(ServicioNegocio.getContexto(), PRE_AUTORIZADA_2034312060).toString() + resultado[0].getBigDecimal(CUOTA) + new Mensaje(ServicioNegocio.getContexto(), EUROS_1291864637).toString();
                        }
                        break;
                    case 'C':
                        advertencia = new Mensaje(ServicioNegocio.getContexto(), OPERACI_N_APTA_TRAMITAR_EXPEDIENTE_REDUCIDO_DESEA_1953075797).toString() + new Mensaje(ServicioNegocio.getContexto(), TRAV_S_EXPEDIENTE_EST_NDAR_REALIZARLO_A_TRAV_S_BO_1964722097).toString() + new Mensaje(ServicioNegocio.getContexto(), MODIFICAR_1901048086).toString();
                        break;
                    default:
                        break;
                }
            }
        }
        return advertencia;
    }

    /**
     * Método auxiliar que obtiene el servicio de la AN02
     *
     * @param producto
     * @param subproducto
     * @return
     */
    private BigDecimal obtieneServicio(BigDecimal producto, BigDecimal subproducto) {
        BigDecimal servicio = null;
        if (null != producto && null != subproducto) {
            // Consulta AN02 para obtener el servicio
            SubProductoEng dao = new SubProductoEng();
            SubProductoC subProducto = dao.obtenerSubProductoUtimaVersion(producto.intValue(), subproducto.intValue(), false, true);
            if (null != subProducto) {
                servicio = subProducto.getServicio();
            }
        }
        return servicio;
    }

    private static final String MODIFICAR_1901048086 = "MODIFICAR_1901048086";

    private static final String PRE_AUTORIZADA_2034312060 = "PRE_AUTORIZADA_2034312060";

    private static final String SOLICITADA_1929467663 = "SOLICITADA_1929467663";

    private static final String EUROS_1291864637 = "EUROS_1291864637";

    private static final String TRAV_S_EXPEDIENTE_EST_NDAR_REALIZARLO_A_TRAV_S_BO_1964722097 = "TRAV_S_EXPEDIENTE_EST_NDAR_REALIZARLO_A_TRAV_S_BO_1964722097";

    private static final String OPERACI_N_EXPEDIENTE_EST_NDAR_CUMPLE_REQUISITOS_O_1023952686 = "OPERACI_N_EXPEDIENTE_EST_NDAR_CUMPLE_REQUISITOS_O_1023952686";

    private static final String EUROS_CALCULADA_299368667 = "EUROS_CALCULADA_299368667";

    private static final String M_XIMO_15_000_EUROS_ESTABLECIDO_CLIENTE_285644656 = "M_XIMO_15_000_EUROS_ESTABLECIDO_CLIENTE_285644656";

    private static final String OPERACI_N_APTA_TRAMITAR_EXPEDIENTE_REDUCIDO_DESEA_1953075797 = "OPERACI_N_APTA_TRAMITAR_EXPEDIENTE_REDUCIDO_DESEA_1953075797";

    private static final String TIPO_INTER_S_TRAMO_M_S_CARO_SUPERIOR_1204591582 = "TIPO_INTER_S_TRAMO_M_S_CARO_SUPERIOR_1204591582";

    private static final String OPERACI_N_EXPEDIENTE_EST_NDAR_SUPERA_IMPORTE_388643047 = "OPERACI_N_EXPEDIENTE_EST_NDAR_SUPERA_IMPORTE_388643047";

    private static final String INGRESOS_REGULARES_TRAMITACI_N_OFICINA_1582414742 = "INGRESOS_REGULARES_TRAMITACI_N_OFICINA_1582414742";
}
