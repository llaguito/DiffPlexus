/**
 */
package es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada;

import java.math.BigDecimal;
import java.sql.Time;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import org.apache.commons.lang.StringUtils;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.busqueda.BusquedaProductoObj;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.busqueda.VersionSubpObj;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.clausulas.ParametrosC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.datEconomicos.ClausulaRestringuidaC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.datEconomicos.DatEcoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.interes.InteresC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.periodosTransitorio.PeriodoTransitorioC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.ProductoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.SubProductoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.version.VersionesC;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionClausulasRestringuidas;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionDatEco;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionInteres;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionPeriodoTransitorio;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionProducto;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionSubProducto;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionVersiones;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.fachada.BusquedaProductoSrv;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.fachada.contextos.ContextosProducto;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Utilidades;
import es.caixagalicia.anpm.prestamos.colectivos.persistencia.colectivo.ColectivosLineasColecC;
import es.caixagalicia.anpm.prestamos.colectivos.persistencia.colectivo.ColectivosLineasColecEng;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.busqueda.BusquedaProdColectivoObj;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.busqueda.VersionObj;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.busqueda.VersionSubpColectivoObj;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.colectivos.ColectivosC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionColectivos;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionParametros;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionSubproductoColectivo;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextosBusquedaProdColectivo;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.CodigosError;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesTramitacion;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.log.LogHelper;
import es.caixagalicia.ifrt.persistencia.eccv02.CEcc;
import es.caixagalicia.ifrt.util.Helper;
import es.caixagalicia.ifrt.mensajes.Mensaje;

/**
 * Servicio que realiza una búsqueda de productos, subproductos, períodos
 * transitorios y colectivos.
 *
 * CC: 507
 * CO: ANPM_168
 * Tx: ANP8
 *
 * @author E800197
 */
public class BusProdColectivoSrv extends ServicioNegocio {

    // Identificación de campos de entrada.
    private static final String CTE_ID_PRODUCTO = "ID_PRODUCTO";

    private static final String CTE_DESCRIPCION_PRODUCTO = "DESCRIPCION_PRODUCTO";

    private static final String CTE_TIPO_FINANCIACION = "TIPO_FINANCIACION";

    private static final String CTE_GRUPO_DESTINO = "GRUPO_DESTINO";

    private static final String CTE_DESTINO = "DESTINO";

    private static final String CTE_SUBDESTINO = "SUBDESTINO";

    private static final String CTE_GRUPO_SECTOR = "GRUPO_SECTOR";

    private static final String CTE_SECTOR = "SECTOR";

    private static final String CTE_COLECTIVO = "COLECTIVO";

    private static final String CTE_CANAL = "CANAL";

    private static final String CTE_MONEDA = "MONEDA";

    private static final String CTE_FECHA_DESDE = "FECHA_DESDE";

    private static final String CTE_FECHA_HASTA = "FECHA_HASTA";

    // private static final String CTE_TIPO_OPERACION = "TIPO_OPERACION";
    private static final String CTE_PASADAS = "PASADAS";

    private static final String CTE_CENTRO_OPERANTE = "CENTRO_OPERANTE";

    private static final String CTE_COD_SUBPRODUCTO = "COD_SUBPRODUCTO";

    private static final String CTE_COD_CARTERA = "CARTERA";

    private static final String CTE_COD_TITULARIDAD = "TITULARIDAD";

    /*20150201 Se añade campo código producto solicitud.*/
    private static final String CTE_COD_PROD_SOLIC = "COD_PROD_SOLIC";

    private static final String CTE_COD_NUC = "NUC_EXPEDIENTE";

    // Parametros de la consulta de permisos
    private static final int POSICION_TIRA_ID_APLICACION = 0;

    private static final int POSICION_TIRA_TIPO_ENTIDAD = 1;

    private static final int POSICION_TIRA_ID_ENTIDAD = 2;

    private static final int POSICION_TIRA_CENTRO = 3;

    // Constantes para la llamada al servicio de consulta
    private static final String VALOR_TIRA_ID_APLICACION = "ANPM";

    private static final String VALOR_TIRA_TIPO_ENTIDAD = "PRODSUBP";

    private static final String CTE_CTXTO_TIENE_PERMISO = "CG1140900";

    // Filtrado por comunidad de bienes
    private static final String CTE_EXCLUSIVIDAD_COM_BIENES = "3";

    /**
     * Log de la clase.
     */
    private static final LogHelper LOGGER = LogHelper.getLog(BusquedaProductoSrv.class);

    /**
     * Ejecuta la logica de negocio del servicio
     *
     * @see es.caixagalicia.ifrt.core.ServicioNegocio
     *      #ejecutar(es.caixagalicia.ifrt.core.IContextoEjecucion,
     *      es.caixagalicia.ifrt.core.IDatosEntradaTx)
     * @param contexto
     *        contexto de ejecucion
     * @param datosEntrada
     *        datos de entrada
     * @return <code>IContexto[]</code>
     */
    @Override
    public IContexto[] ejecutar(IContextoEjecucion contexto, IDatosEntradaTx entrada) {
        final long lInicio = System.currentTimeMillis();
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("INICIO SNANPM168: Busqueda de productos con colectivos");
        }
        contexto.setDiarioElectronico(new DiarioElectronico(Constantes.CTE_OPERACION_CO, Integer.valueOf(0), BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, Constantes.CTE_STRING_EMPTY, Constantes.CTE_STRING_EMPTY, BigDecimal.ZERO, BigDecimal.ZERO, Integer.valueOf(0)));
        BigDecimal bidIdProducto = entrada.getDecimal(CTE_ID_PRODUCTO);
        Integer idprod = null;
        if (bidIdProducto != null) {
            idprod = new Integer(bidIdProducto.intValue());
        }
        String descripcion = entrada.getString(CTE_DESCRIPCION_PRODUCTO);
        if (UtilidadesTramitacion.isBlankOrNull(descripcion))
            descripcion = "";
        String tipoFinan = entrada.getString(CTE_TIPO_FINANCIACION);
        String grupoDestino = entrada.getString(CTE_GRUPO_DESTINO);
        String destino = entrada.getString(CTE_DESTINO);
        String centro = entrada.getString(CTE_CENTRO_OPERANTE);
        String subdestino = entrada.getString(CTE_SUBDESTINO);
        if (subdestino != null) {
            subdestino = subdestino.trim();
        }
        String grupoSector = entrada.getString(CTE_GRUPO_SECTOR);
        String sSector = entrada.getString(CTE_SECTOR);
        Integer sector = null;
        if (!(UtilidadesTramitacion.isBlankOrNull(sSector))) {
            sector = new Integer(sSector.trim());
        }
        String bidColectivo = entrada.getString(CTE_COLECTIVO);
        Integer colectivo = null;
        if (!(UtilidadesTramitacion.isBlankOrNull(bidColectivo))) {
            colectivo = Integer.valueOf(bidColectivo.trim());
        }
        String scanal = entrada.getString(CTE_CANAL);
        Integer canal = null;
        if (!(UtilidadesTramitacion.isBlankOrNull(scanal))) {
            canal = new Integer(scanal.trim());
        }
        String moneda = entrada.getString(CTE_MONEDA);
        if (moneda != null) {
            moneda = moneda.trim();
        }
        String fechaDesde = entrada.getString(CTE_FECHA_DESDE);
        String fechaHasta = entrada.getString(CTE_FECHA_HASTA);
        // String operacion = entrada.getString(CTE_TIPO_OPERACION);
        BigDecimal pasadas = entrada.getDecimal(CTE_PASADAS);
        Integer iPasadas = null;
        BigDecimal codSubproducto = entrada.getDecimal(CTE_COD_SUBPRODUCTO);
        Integer idSubprd = null;
        if (!UtilidadesTramitacion.isBlankOrNull(codSubproducto)) {
            idSubprd = new Integer(codSubproducto.intValue());
        }
        // filtramos todas las búsquedas de productos por la entidad a la que pertenece el terminal desde el que se busca
        String oficinaTerminal = contexto.getOficina();
        String entidad = UtilidadesComun.obtenerEntidadCentro(oficinaTerminal);
        // para determinados usuarios no se va a filtrar por entidad (para que puedan revisar incidencias de una entidad a pesar de pertenecer a otra)
        // Llamada a ambitos
        Boolean cumpleAmbito = Utilidades.esCumpleAmbitos(ConstantesComun.CTE_AMBIT_PROD_ENT_ID_APL, ConstantesComun.CTE_AMBIT_PROD_ENT_TIPO_ENTIDAD, ConstantesComun.CTE_AMBIT_PROD_ENT_ENTIDAD_TODASENT, // centro: no aplica, el ámbito se mira por usuario
        null, contexto.getUsuario());
        if (cumpleAmbito) {
            entidad = "";
        }
        if (pasadas != null) {
            iPasadas = new Integer(pasadas.intValue());
        } else {
            iPasadas = new Integer(0);
        }
        String cartera = entrada.getString(CTE_COD_CARTERA);
        if (null != cartera) {
            cartera = cartera.trim();
        }
        // if (UtilidadesTramitacion.isBlankOrNull(operacion))
        // {
        // contextoSalida = getBusquedaProductoCopiar(idprod, descripcion);
        // }
        // else
        // {
        // Nuevo criterio de búsqueda
        // opcional
        String titularidad = "";
        String versionActualStr = ServicioNegocio.getContexto().getVersionActual();
        BigDecimal versionActualBid = new BigDecimal(versionActualStr);
        if (0 >= new BigDecimal(2).compareTo(versionActualBid)) {
            titularidad = entrada.getString(CTE_COD_TITULARIDAD);
            if (null != titularidad) {
                titularidad = titularidad.trim();
            }
        }
        BigDecimal codProdSolic = entrada.getDecimal(CTE_COD_PROD_SOLIC);
        /*Cuidado: si la dll no nos envía aún el campo va a venir a nulo, se controla despues. */
        BigDecimal nuc = null;
        if (!Utilidades.isBlankOrNull(entrada.getDecimal(CTE_COD_NUC))) {
            nuc = entrada.getDecimal(CTE_COD_NUC);
        }
        // Definimos el contexto de salida
        IContexto[] contextoSalida;
        contextoSalida = getBusquedaProducto(centro, idprod, descripcion, tipoFinan, grupoDestino, destino, subdestino, grupoSector, sector, colectivo, canal, moneda, fechaDesde, fechaHasta, iPasadas, idSubprd, cartera, titularidad, codProdSolic, nuc, entidad);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("FIN SNANPM168: busqueda producto con colectivo. " + "***********             Tiempo total: " + (System.currentTimeMillis() - lInicio) + "ms                   ***********");
        }
        return contextoSalida;
    }

    /**
     * Elimina los resultados cuyos atributos: - Indicador operatividad. -
     * Indicador activo producto. - Indicador activo subproducto. presentan un
     * valor Si.
     *
     * @param srcList
     * @return
     */
    private List<VersionSubpColectivoObj> eliminarSubproductosNoActivos(final List<VersionSubpColectivoObj> srcList) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        for (VersionSubpColectivoObj srcVersionSubpCol : srcList) {
            if ((Constantes.SI.equals(srcVersionSubpCol.getIndOperatividad())) && (Constantes.CTE_UNO_INT.equals(srcVersionSubpCol.getIndicadorActivoProducto())) && (Constantes.CTE_UNO_INT.equals(srcVersionSubpCol.getIndicadorActivoSubproducto()))) {
                destList.add(srcVersionSubpCol);
            }
        }
        return destList;
    }

    /**
     * Elimina los resultados duplicados. Un resultado está duplicado si los
     * siguientes identificadores: - Identificador de producto. - Versión de
     * producto. - Identificador de subproducto. - Versión de subproducto. -
     * Identificador de colectivo. - Versión general. coinciden con otro.
     *
     * @param srcList
     * @return
     */
    private List<VersionSubpColectivoObj> eliminarSubproductosRepetidos(final List<VersionSubpColectivoObj> srcList) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        for (VersionSubpColectivoObj srcVersionSubpCol : srcList) {
            boolean success = false;
            for (VersionSubpColectivoObj destVersionSubpCol : destList) {
                if (srcVersionSubpCol.compare(destVersionSubpCol) == Constantes.CTE_CERO) {
                    success = true;
                    break;
                }
            }
            if (!(success)) {
                destList.add(srcVersionSubpCol);
            }
        }
        return destList;
    }

    /**
     * Filtra la lista de subproductos de entrada utilizando el colectivo
     * recibido como parámetro.
     *
     * @param srcList
     *        Objetos recuperados de la tabla AN14TB01 - Relación Versiones.
     * @param colectivo
     *        Identificador de colectivo a filtrar.
     * @return
     */
    private List<VersionSubpColectivoObj> filtrarColectivos(final List<VersionSubpColectivoObj> srcList, final List<ColectivosLineasColecC> lineasColectivo) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        BigDecimal bidLineaC = BigDecimal.ZERO;
        for (VersionSubpColectivoObj versionSubp : srcList) {
            // Colectivo recuperado de la tabla AN14TB01.
            BigDecimal idColectivo = new BigDecimal(versionSubp.getColectivo().toString());
            // colectivos a mostrar.
            if (ConstantesComun.CTE_BID_0.equals(idColectivo)) {
                destList.add(versionSubp);
            // List<VersionSubpColectivoObj> versionSubpColList =
            // this.obtenerColectivosVigentes(srcList, versionSubp, colectivo);
            // 
            // if(null!=colectivo && !Constantes.CTE_MENOS_UNO.equals(colectivo))
            // {
            // if(null!=versionSubpColList && versionSubpColList.size() > Constantes.CTE_CERO)
            // {
            // 
            // destList.add(versionSubp);
            // destList.addAll(versionSubpColList);
            // 
            // }
            // }
            // else if(Constantes.CTE_MENOS_UNO.equals(colectivo))
            // {
            // destList.add(versionSubp);
            // destList.addAll(versionSubpColList);
            // }
            // else
            // {
            // destList.add(versionSubp);
            // destList.addAll(versionSubpColList);
            // }
            } else {
                // Bucle para filtrar por las lineas de colectivo.
                for (ColectivosLineasColecC lineaColectivo : lineasColectivo) {
                    bidLineaC = lineaColectivo.getColectivosLineasColecKey().getLineaColectivo();
                    if (null != bidLineaC && 0 <= bidLineaC.compareTo(ConstantesComun.CTE_BID_0) && bidLineaC.equals(idColectivo)) {
                        // GestionColectivos gc = new GestionColectivos();
                        // ColectivosC colectivoC = gc
                        // .obtenerColectivoVigente(idColectivo);
                        // 
                        // if(null!=colectivoC && gc.esVinculacionColectivoActiva(versionSubp, idColectivo)) {
                        // 
                        // versionSubp.setDescColectivo(colectivoC.getStrDescripcion());
                        // destList.add(versionSubp);
                        // }
                        // Settea la descripcion de la linea de colectivo y lo añade a la lista de subproductos.
                        versionSubp.setDescColectivo(lineaColectivo.getColectivosLineasColecKey().getDescLinea());
                        destList.add(versionSubp);
                        break;
                    } else if (0 > bidLineaC.compareTo(ConstantesComun.CTE_BID_0)) {
                        GestionColectivos gc = new GestionColectivos();
                        ColectivosC colectivoC = gc.obtenerColectivoVigente(idColectivo);
                        if (null != colectivoC && gc.esVinculacionColectivoActiva(versionSubp, idColectivo)) {
                            versionSubp.setDescColectivo(colectivoC.getStrDescripcion().trim());
                            destList.add(versionSubp);
                        }
                    }
                }
            // FIN DEL BUCLE DE LINEAS DE COLECTIVO
            }
        }
        return destList;
    }

    /**
     * Búsqueda de producto utilizando filtros.
     *
     * @param idprod
     * @param descripcion
     * @param tipoFinan
     * @param grupoDestino
     * @param destino
     * @param subdestino
     * @param grupoSector
     * @param sector
     * @param colectivo
     * @param canal
     * @param moneda
     * @param fechaDesde
     * @param fechaHasta
     * @param iPasadas
     * @param codSubproducto
     * @return
     */
    @SuppressWarnings("unchecked")
    public IContexto[] getBusquedaProducto(String centro, Integer idprod, String descripcion, String tipoFinan, String grupoDestino, String destino, String subdestino, String grupoSector, Integer sector, Integer colectivo, Integer canal, String moneda, String fechaDesde, String fechaHasta, Integer iPasadas, Integer codSubproducto, String cartera, String titularidad, BigDecimal codProdSolic, BigDecimal nuc, String entidad) {
        List<BusquedaProdColectivoObj> salida = new ArrayList<BusquedaProdColectivoObj>(0);
        GestionProducto gprod = new GestionProducto();
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        DatosSolicitudC datosSolicitud = null;
        String codProductoSubproductoHermes = null;
        datosSolicitud = gds.getUltimaVersionCompleta(nuc);
        List<ColectivosLineasColecC> lineasColectivos = null;
        /*20150527 Si el código producto solicitud no viene informado lo informamos con el campo AN250080, hacemos esto
		 * por una incidencia de la dll de búsqueda de productos, AN021D01, que no está enviando el código producto de la 
		 * solicitud en la segunda búsqueda.
		 * */
        if (null == codProdSolic) {
            if (null == datosSolicitud) {
                codProductoSubproductoHermes = obtenerCodProductoSubproductoHermes(nuc);
                /*20170227 Si el SN CPRO_173 nos devuelve código de producto y subrpoducto = null es lo que devolvemos*/
                if (Utilidades.isBlankOrNull(codProductoSubproductoHermes)) {
                    codProdSolic = null;
                } else {
                    codProdSolic = new BigDecimal(codProductoSubproductoHermes.substring(Constantes.CTE_INT_CERO, Constantes.CTE_INT_SIETE));
                }
            } else {
                /*Si es un alta de tramitacion datosSolicitud no viene informado.*/
                codProdSolic = datosSolicitud.getProducto();
            }
        }
        // Busca las lineas de colectivo que pertenecen a ese codigo de colectivo.
        lineasColectivos = buscarLineasColectivo(colectivo);
        // Sin ID ni descripción de producto.
        if ((UtilidadesTramitacion.isBlankOrNull(idprod)) && (UtilidadesTramitacion.isBlankOrNull(descripcion))) {
            // Sin datos en el filtro.
            if ((UtilidadesTramitacion.isBlankOrNull(tipoFinan)) && (UtilidadesTramitacion.isBlankOrNull(grupoDestino)) && (UtilidadesTramitacion.isBlankOrNull(destino)) && (UtilidadesTramitacion.isBlankOrNull(subdestino)) && (UtilidadesTramitacion.isBlankOrNull(cartera)) && (UtilidadesTramitacion.isBlankOrNull(grupoSector)) && (sector == null) && (canal == null) && (UtilidadesTramitacion.isBlankOrNull(moneda))) {
                // Todos los productos y subproductos que tengan version.
                List<Object> subProdList = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                List<VersionSubpColectivoObj> versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.TODO);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                List<VersionSubpColectivoObj> versionSubpColList = this.filtrarColectivos(versionSubpList, lineasColectivos);
                subProdList = gprod.buscarProductosSQLSinDatEco(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.SINDATECO);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                subProdList = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.SININT);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                subProdList = gprod.buscarProductoSQLSinDatEcoNiInteres(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.NADA);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                versionSubpColList = this.filtrarProductosFechaTope(versionSubpColList, colectivo);
                if (null != nuc) {
                    versionSubpColList = this.filtrarComunidadPropietarios(versionSubpColList, nuc);
                }
                if (null != nuc && versionSubpColList.size() > 0) {
                    versionSubpColList = this.filtrarCarteraCliente(nuc, versionSubpColList);
                }
                Collections.sort(versionSubpColList, new VersionSubpColectivoObj());
                this.construyeSalida(versionSubpColList, salida);
            } else {
                // Con 'Tipo de financiación' y Subdestino.
                if ((UtilidadesTramitacion.isBlankOrNull(grupoDestino)) && (UtilidadesTramitacion.isBlankOrNull(destino)) && (UtilidadesTramitacion.isBlankOrNull(grupoSector)) && (UtilidadesTramitacion.isBlankOrNull(sector)) && (UtilidadesTramitacion.isBlankOrNull(cartera)) && (UtilidadesTramitacion.isBlankOrNull(canal)) && (UtilidadesTramitacion.isBlankOrNull(moneda))) {
                    List<Object> subProdList = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                    List<VersionSubpColectivoObj> versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.TODO);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    List<VersionSubpColectivoObj> versionSubpColList = this.filtrarColectivos(versionSubpList, lineasColectivos);
                    subProdList = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                    versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.SININT);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                    versionSubpColList = this.filtrarProductosFechaTope(versionSubpColList, colectivo);
                    if (null != nuc) {
                        versionSubpColList = this.filtrarComunidadPropietarios(versionSubpColList, nuc);
                    }
                    if (null != nuc && versionSubpColList.size() > 0) {
                        versionSubpColList = this.filtrarCarteraCliente(nuc, versionSubpColList);
                    }
                    Collections.sort(versionSubpColList, new VersionSubpColectivoObj());
                    this.construyeSalida(versionSubpColList, salida);
                } else {
                    List<VersionSubpObj> subProdList = gprod.buscarProductoSQLClausulas(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad, entidad);
                    List<VersionSubpColectivoObj> versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    List<VersionSubpColectivoObj> versionSubpColList = this.filtrarColectivos(versionSubpList, lineasColectivos);
                    subProdList = gprod.buscarProductoSQLSinIntClausulas(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad, entidad);
                    versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                    versionSubpColList = this.filtrarProductosFechaTope(versionSubpColList, colectivo);
                    if (null != nuc) {
                        versionSubpColList = this.filtrarComunidadPropietarios(versionSubpColList, nuc);
                    }
                    if (null != nuc && versionSubpColList.size() > 0) {
                        versionSubpColList = this.filtrarCarteraCliente(nuc, versionSubpColList);
                    }
                    Collections.sort(versionSubpColList, new VersionSubpColectivoObj());
                    this.construyeSalida(versionSubpColList, salida);
                }
            }
        } else {
            // Con ID de producto o descrición y sin datos en el filtro.
            if ((UtilidadesTramitacion.isBlankOrNull(tipoFinan)) && (UtilidadesTramitacion.isBlankOrNull(grupoDestino)) && (UtilidadesTramitacion.isBlankOrNull(destino)) && (UtilidadesTramitacion.isBlankOrNull(cartera)) && (UtilidadesTramitacion.isBlankOrNull(subdestino)) && (UtilidadesTramitacion.isBlankOrNull(grupoSector)) && (sector == null) && (canal == null) && (UtilidadesTramitacion.isBlankOrNull(moneda))) {
                List<Object> subProdList = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                List<VersionSubpColectivoObj> versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.TODO);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                List<VersionSubpColectivoObj> versionSubpColList = this.filtrarColectivos(versionSubpList, lineasColectivos);
                subProdList = gprod.buscarProductosSQLSinDatEco(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.SINDATECO);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                subProdList = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.SININT);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                subProdList = gprod.buscarProductoSQLSinDatEcoNiInteres(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.NADA);
                versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                versionSubpColList = this.filtrarProductosFechaTope(versionSubpColList, colectivo);
                if (!UtilidadesTramitacion.isBlankOrNull(codSubproducto)) {
                    versionSubpColList = this.filtrarSubproductos(versionSubpColList, codSubproducto);
                }
                if (null != nuc) {
                    versionSubpColList = this.filtrarComunidadPropietarios(versionSubpColList, nuc);
                }
                if (null != nuc && versionSubpColList.size() > 0) {
                    versionSubpColList = this.filtrarCarteraCliente(nuc, versionSubpColList);
                }
                Collections.sort(versionSubpColList, new VersionSubpColectivoObj());
                this.construyeSalida(versionSubpColList, salida);
            } else {
                // Con 'Tipo de financiación'
                if ((UtilidadesTramitacion.isBlankOrNull(grupoDestino)) && (UtilidadesTramitacion.isBlankOrNull(destino)) && (UtilidadesTramitacion.isBlankOrNull(grupoSector)) && (UtilidadesTramitacion.isBlankOrNull(sector)) && (UtilidadesTramitacion.isBlankOrNull(cartera)) && (UtilidadesTramitacion.isBlankOrNull(canal)) && (UtilidadesTramitacion.isBlankOrNull(moneda))) {
                    List<Object> subProdList = gprod.buscarProductosSQL(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                    List<VersionSubpColectivoObj> versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.TODO);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    List<VersionSubpColectivoObj> versionSubpColList = this.filtrarColectivos(versionSubpList, lineasColectivos);
                    subProdList = gprod.buscarProductoSQLSinInteres(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, cartera, titularidad, entidad);
                    versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList, VersionSubpColectivoObj.SININT);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                    versionSubpColList = this.filtrarProductosFechaTope(versionSubpColList, colectivo);
                    if (!UtilidadesTramitacion.isBlankOrNull(codSubproducto)) {
                        versionSubpColList = this.filtrarSubproductos(versionSubpColList, codSubproducto);
                    }
                    if (null != nuc) {
                        versionSubpColList = this.filtrarComunidadPropietarios(versionSubpColList, nuc);
                    }
                    if (null != nuc && versionSubpColList.size() > 0) {
                        versionSubpColList = this.filtrarCarteraCliente(nuc, versionSubpColList);
                    }
                    Collections.sort(versionSubpColList, new VersionSubpColectivoObj());
                    this.construyeSalida(versionSubpColList, salida);
                } else {
                    List<VersionSubpObj> subProdList = gprod.buscarProductoSQLClausulas(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad, entidad);
                    List<VersionSubpColectivoObj> versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    List<VersionSubpColectivoObj> versionSubpColList = this.filtrarColectivos(versionSubpList, lineasColectivos);
                    subProdList = gprod.buscarProductoSQLSinIntClausulas(idprod, descripcion, tipoFinan, destino, subdestino, sector, canal, moneda, fechaDesde, fechaHasta, iPasadas, grupoDestino, grupoSector, cartera, titularidad, entidad);
                    versionSubpList = VersionSubpColectivoObj.getVersionSubpColList(subProdList);
                    versionSubpList = this.eliminarSubproductosNoActivos(versionSubpList);
                    versionSubpList = this.eliminarSubproductosRepetidos(versionSubpList);
                    versionSubpList = this.obtenerPeriodosTransitorios(versionSubpList);
                    versionSubpList = this.eliminarVersionesFuturas(versionSubpList);
                    versionSubpList = this.filtrarProductosAutorizadosUsuario(centro, versionSubpList);
                    versionSubpColList.addAll(this.filtrarColectivos(versionSubpList, lineasColectivos));
                    versionSubpColList = this.filtrarProductosFechaTope(versionSubpColList, colectivo);
                    if (!UtilidadesTramitacion.isBlankOrNull(codSubproducto)) {
                        versionSubpColList = this.filtrarSubproductos(versionSubpColList, codSubproducto);
                    }
                    if (null != nuc) {
                        versionSubpColList = this.filtrarComunidadPropietarios(versionSubpColList, nuc);
                    }
                    if (null != nuc && versionSubpColList.size() > 0) {
                        versionSubpColList = this.filtrarCarteraCliente(nuc, versionSubpColList);
                    }
                    Collections.sort(versionSubpColList, new VersionSubpColectivoObj());
                    this.construyeSalida(versionSubpColList, salida);
                }
            }
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("*************************************************************************************");
            LOGGER.debug("************        Número de elementos ------->    " + salida.size());
            LOGGER.debug("************                                                     ********************");
            LOGGER.debug("************                                                     ********************");
            LOGGER.debug("************                                                     ********************");
            LOGGER.debug("************                                                     ********************");
            LOGGER.debug("************                                                     ********************");
            LOGGER.debug("************                                                     ********************");
            LOGGER.debug("*************************************************************************************");
        }
        if (null != codProdSolic) {
            /*20150326 Es posible que el la entry del producto que quiere buscar el usuario tambien esté vacía,
			 * por lo tanto en ese caso no se aplica el filtro.*/
            // if (null != idprod)
            /*20150803 Corregimos incidencia: tambien tenemos que filtrar el cambio de producto/subproducto cuando no nos informan el código producto
			 * tecleado, es decir, cuando el criterio de búsqueda es otro, por lo tanto no podemos controlar aquí si el código de producto tecleado
			 * está informado o no.*/
            salida = filtradoPermitirCambioProdParam(salida, idprod, codProdSolic, datosSolicitud, nuc, codProductoSubproductoHermes);
        }
        if (!Utilidades.isBlankOrNull(nuc)) {
            salida = filtrarPorTipoPrescriptor(salida, nuc, idprod);
        // Hacemos uso de la sobrecarga
        // salida = filtrarPorTipoPrescriptor(salida,nuc);
        }
        final IContexto[] contextoSalida = ContextosBusquedaProdColectivo.rellenarDatosContexto(salida);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Se ha buscado el producto correctamente");
        }
        return contextoSalida;
    }

    /**
     * Filtra la lista de productos que se pasa como parametros, eliminando
     * aquellos productos para los que el usuario no está autorizado
     *
     * @param centro
     * @param versionSubpList
     * @return
     */
    private List<VersionSubpColectivoObj> filtrarProductosAutorizadosUsuario(final String centro, List<VersionSubpColectivoObj> versionSubpList) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        if (!UtilidadesTramitacion.isBlankOrNull(centro)) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("INICIO: filtrando productos.");
            }
            for (VersionSubpColectivoObj producto : versionSubpList) {
                if (isUsuarioPermitido(producto, centro)) {
                    destList.add(producto);
                }
            }
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("FIN: filtrando productos.");
            }
        } else {
            destList = versionSubpList;
        }
        return destList;
    }

    /**
     * Invocará al servicio CGAL_362 para comprobar si el usuario puede
     * contratar el producto
     *
     * @param producto
     * @return True si el usuario puede contratar el producto, false en otro
     *         caso
     */
    private boolean isUsuarioPermitido(final VersionSubpColectivoObj producto, final String centro) {
        IDatosEntradaTx datosEntradaConsPrmsos = getPrograma(ServicioNegocio.getContexto(), Constantes.CTE_APLIC_CGAL, Constantes.CTE_COD_CONS_PERMISOS);
        datosEntradaConsPrmsos.addCampo(POSICION_TIRA_ID_APLICACION, VALOR_TIRA_ID_APLICACION);
        datosEntradaConsPrmsos.addCampo(POSICION_TIRA_TIPO_ENTIDAD, VALOR_TIRA_TIPO_ENTIDAD);
        datosEntradaConsPrmsos.addCampo(POSICION_TIRA_ID_ENTIDAD, producto.getIdProducto() + "-" + producto.getIdSubprod1());
        datosEntradaConsPrmsos.addCampo(POSICION_TIRA_CENTRO, Helper.fillLeft(centro, 4, '0'));
        IContexto[] cntxtoPrmsos = invocarServicio(getContexto(), datosEntradaConsPrmsos);
        return cntxtoPrmsos.length != 0 && !UtilidadesTramitacion.isBlankOrNull(cntxtoPrmsos[0].getString(CTE_CTXTO_TIENE_PERMISO)) && Constantes.SI.equals(cntxtoPrmsos[0].getString(CTE_CTXTO_TIENE_PERMISO));
    }

    /**
     * Eliminar la versión cero de la rama.
     */
    private void removeVersionCero(List<VersionObj> arbol, VersionObj rama) {
        if (rama.getNodo() != null) {
            if (!(rama.getNodo().getIdSubprod1().equals(new Integer(0)))) {
                arbol.remove(VersionObj.getVersionCero(arbol, rama));
            }
        }
    }

    /**
     * @param version
     * @return
     */
    private BusquedaProdColectivoObj getProducto(VersionSubpColectivoObj version) {
        BusquedaProdColectivoObj obj = new BusquedaProdColectivoObj();
        // Tipo producto.
        obj.setTipo(new Integer(1));
        obj.setIdProducto(version.getIdProducto());
        obj.setDescripcion(version.getDescProd());
        obj.setIdVersion(version.getVersionProd());
        return obj;
    }

    /**
     * @param intereses
     * @return
     */
    private InteresC getInteresMayorPlazo(List<InteresC> intereses) {
        InteresC salida = intereses.get(0);
        Integer plazo = new Integer(0);
        final int size = intereses.size();
        for (int i = 0; i < size; i++) {
            InteresC tmp = intereses.get(i);
            Integer tmpPlazo = tmp.getPlazo();
            if (tmpPlazo.equals(new Integer(0))) {
                tmpPlazo = tmp.getPlazoHasta();
            }
            if (tmpPlazo.intValue() > plazo.intValue()) {
                salida = tmp;
                plazo = tmpPlazo;
            }
        }
        return salida;
    }

    /**
     * @param intereres
     * @param obj
     * @return
     */
    private String getInteresStringC(List<InteresC> intereses, BusquedaProductoObj obj) {
        final int num = intereses.size();
        switch(num) {
            case 0:
                {
                    obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), INTERES_1958062730).toString());
                    break;
                }
            case 1:
                {
                    InteresC interes = intereses.get(0);
                    if ("00".equals(interes.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_3142984).toString());
                    } else if ("01".equals(interes.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_CAMPA_AS_1121213115).toString());
                    } else if ("02".equals(interes.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_1249586564).toString());
                    }
                    break;
                }
            case 2:
                {
                    InteresC interes1 = intereses.get(0);
                    InteresC interes2 = intereses.get(1);
                    if (("00".equals(interes1.getTipo())) && ("02".equals(interes2.getTipo()))) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_INICIAL_FIJO_268281213).toString());
                    } else {
                        InteresC mayor = getInteresMayorPlazo(intereses);
                        if ("00".equals(mayor.getTipo())) {
                            obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_3142984).toString());
                        } else if ("01".equals(mayor.getTipo())) {
                            obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_CAMPA_AS_1121213115).toString());
                        } else if ("02".equals(mayor.getTipo())) {
                            obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_1249586564).toString());
                        } else if ("03".equals(mayor.getTipo())) {
                            obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_BONIFICABLE_1858709010).toString());
                        } else if ("04".equals(mayor.getTipo())) {
                            obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_PENALIZABLE_712625771).toString());
                        } else if ("05".equals(mayor.getTipo())) {
                            obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_CAMPA_AS_1368594439).toString());
                        } else {
                            obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_REFERENCIADO_2130014933).toString());
                        }
                    }
                    break;
                }
            default:
                {
                    InteresC mayor = getInteresMayorPlazo(intereses);
                    if ("00".equals(mayor.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_3142984).toString());
                    } else if ("01".equals(mayor.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_CAMPA_AS_1121213115).toString());
                    } else if ("02".equals(mayor.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_1249586564).toString());
                    } else if ("03".equals(mayor.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_BONIFICABLE_1858709010).toString());
                    } else if ("04".equals(mayor.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_PENALIZABLE_712625771).toString());
                    } else if ("05".equals(mayor.getTipo())) {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), VARIABLE_CAMPA_AS_1368594439).toString());
                    } else {
                        obj.setInteresDesc(new Mensaje(ServicioNegocio.getContexto(), FIJO_REFERENCIADO_2130014933).toString());
                    }
                    break;
                }
        }
        return obj.getInteresDesc();
    }

    /**
     * @param version
     * @return
     */
    public BusquedaProdColectivoObj getSubproducto(VersionSubpColectivoObj versionSubpCol) {
        BusquedaProdColectivoObj obj = new BusquedaProdColectivoObj();
        // Tipo subproducto.
        obj.setTipo(new Integer(2));
        // Estado de un subproducto (pasado, vigente o futuro).
        obj.setEstado(versionSubpCol.getEstado());
        obj.setIdVersion(versionSubpCol.getVersionG());
        obj.setIdProducto(versionSubpCol.getIdProducto());
        obj.setIdSubProducto(versionSubpCol.getIdSub2());
        obj.setDescripcion(versionSubpCol.getIdSub2() + " - " + versionSubpCol.getDescSub());
        obj.setFechaDesde(versionSubpCol.getDateFechaInicio());
        obj.setFechaHasta(versionSubpCol.getDateFechaFin());
        obj.setFechaHastaSubp(versionSubpCol.getDateFechaFinSubp());
        obj.setDestino(versionSubpCol.getDestino());
        obj.setPlazoTotal(versionSubpCol.getPlazoEco());
        GestionInteres gint = new GestionInteres();
        List<InteresC> intereses = gint.obtenerInteresTodosOrden(versionSubpCol.getIdProducto(), versionSubpCol.getIdSubprod1(), versionSubpCol.getVersionInt(), versionSubpCol.getColectivo());
        String sInteres = this.getInteresStringC(intereses, obj);
        obj.setInteresDesc(sInteres);
        return obj;
    }

    /**
     * @param version
     * @return
     */
    public BusquedaProdColectivoObj getColectivo(VersionSubpColectivoObj versionSubpCol) {
        BusquedaProdColectivoObj obj = new BusquedaProdColectivoObj();
        // Tipo colectivo.
        obj.setTipo(new Integer(3));
        obj.setIdProducto(versionSubpCol.getIdProducto());
        obj.setIdSubProducto(versionSubpCol.getIdSubprod1());
        obj.setIdColectivo(versionSubpCol.getColectivo());
        obj.setIdVersion(versionSubpCol.getVersionG());
        // [F001317] Modificación --> Mostrar fechas vigencia de colectivos
        obj.setFechaDesde(versionSubpCol.getDateFechaInicio());
        obj.setFechaHasta(versionSubpCol.getDateFechaFin());
        obj.setFechaHastaSubp(versionSubpCol.getDateFechaFin());
        // FIN Modificación
        obj.setDescripcion(versionSubpCol.getDescColectivo());
        // Añadimos más valores de campos que faltaban para mostrar completa la información en el listado de resultados en el caso de colectivos
        obj.setEstado(versionSubpCol.getEstado());
        obj.setDestino(versionSubpCol.getDestino());
        obj.setPlazoTotal(versionSubpCol.getPlazoEco());
        GestionInteres gint = new GestionInteres();
        List<InteresC> intereses = gint.obtenerInteresTodosOrden(versionSubpCol.getIdProducto(), versionSubpCol.getIdSubprod1(), versionSubpCol.getVersionInt(), versionSubpCol.getColectivo());
        String sInteres = this.getInteresStringC(intereses, obj);
        obj.setInteresDesc(sInteres);
        return obj;
    }

    /**
     * @param salida
     * @param versionList
     */
    private void construyeRama(List<BusquedaProdColectivoObj> salida, List<VersionObj> versionList) {
        VersionObj tmp = null;
        VersionSubpColectivoObj versionSubpCol;
        if (versionList.size() > 0) {
            tmp = versionList.get(0);
            versionSubpCol = tmp.getNodo();
            salida.add(this.getProducto(versionSubpCol));
            final int listSize = versionList.size();
            for (int i = 0; i < listSize; i++) {
                tmp = versionList.get(i);
                List<VersionSubpColectivoObj> nodosVersion = tmp.getNodosVersion();
                final int nodosSize = nodosVersion.size();
                for (int j = 0; j < nodosSize; j++) {
                    versionSubpCol = nodosVersion.get(j);
                    Integer colectivo = versionSubpCol.getColectivo();
                    // ¿ Tratamos con un subproducto o con un colectivo ?
                    BusquedaProdColectivoObj obj = (Constantes.CTE_CERO.equals(colectivo)) ? this.getSubproducto(versionSubpCol) : this.getColectivo(versionSubpCol);
                    salida.add(obj);
                }
            }
        }
    }

    /**
     * El proceso de construcción del árbol se basa en el procesamiento de la
     * lista de resultados formada después de la invocación de los métodos find
     * del Engine asociado. El árbol de salida se construye por ramas, constando
     * cada una de ellas por un nodo padre (producto/subproducto) y los nodos
     * asociados (subproductos/colectivos).
     *
     * @param versionSubpColectivoList
     * @param salida
     */
    private void construyeSalida(final List<VersionSubpColectivoObj> versionSubpColectivoList, List<BusquedaProdColectivoObj> salida) {
        Integer idProd = null;
        Integer versProd = null;
        Integer idSub = null;
        Integer versSub = null;
        Integer versGen = null;
        Integer colectivo = null;
        List<VersionObj> arbol = new ArrayList<VersionObj>(0);
        VersionObj rama = new VersionObj();
        int contadorPasadas = 0;
        final int size = versionSubpColectivoList.size();
        for (int i = 0; i < size; i++) {
            VersionSubpColectivoObj subpCol = versionSubpColectivoList.get(i);
            if (i == 0) {
                idProd = subpCol.getIdProducto();
                versProd = subpCol.getVersionProd();
                idSub = subpCol.getIdSubprod1();
                versSub = subpCol.getVersionSubp();
                versGen = subpCol.getVersionG();
                colectivo = subpCol.getColectivo();
                rama.setNodo(subpCol);
                rama.addNodoVersion(subpCol);
            } else {
                // Mismo producto, misma versión.
                if (idProd.equals(subpCol.getIdProducto()) && versProd.equals(subpCol.getVersionProd())) {
                    // Mismo subproducto, misma versión, mismo colectivo.
                    if ((idSub.equals(subpCol.getIdSubprod1())) && (versSub.equals(subpCol.getVersionSubp())) && (colectivo.equals(subpCol.getColectivo())) && (versGen.equals(subpCol.getVersionG()))) {
                        if (contadorPasadas < (Constantes.CTE_NUMERO_PASADAS + 1)) {
                            rama.addNodoVersion(subpCol);
                        }
                    } else // Mismo subproducto, distinta versión o distinto colectivo.
                    if (idSub.equals(subpCol.getIdSubprod1())) {
                        if (contadorPasadas < Constantes.CTE_NUMERO_PASADAS) {
                            // Añadimos rama al árbol.
                            arbol.add(rama);
                            this.removeVersionCero(arbol, rama);
                            // Nueva rama con la versión actual.
                            rama = new VersionObj();
                            rama.setNodo(subpCol);
                            rama.addNodoVersion(subpCol);
                            versSub = subpCol.getVersionSubp();
                            versGen = subpCol.getVersionG();
                            Date fechaHoy = new Date(DateUtils.getSoloFecha(DateUtils.dateNow()).getTime());
                            Time horaHoy = DateUtils.getSoloHorario(DateUtils.dateNow());
                            Date fechaNula = new Date(DateUtils.parseDate(DateUtils.CTE_DATELOWESTONLYDAY, DateUtils.FORMATO_FECHA_AMERICANO).getTime());
                            if (((DateUtils.isDateGreater(fechaHoy, subpCol.getDateFechaFin())) && (!(subpCol.getDateFechaFin().equals(fechaNula)))) || (fechaHoy.equals(subpCol.getDateFechaFin())) && (DateUtils.isDateGreater(horaHoy, subpCol.getTimeHoraFin()))) {
                                contadorPasadas++;
                            }
                        } else {
                            versSub = subpCol.getVersionSubp();
                            versGen = subpCol.getVersionG();
                            contadorPasadas++;
                        }
                    } else // Distinto subproducto.
                    {
                        contadorPasadas = 0;
                        // Añadimos rama al árbol.
                        arbol.add(rama);
                        this.removeVersionCero(arbol, rama);
                        // Nueva rama con la versión actual.
                        rama = new VersionObj();
                        rama.setNodo(subpCol);
                        rama.addNodoVersion(subpCol);
                        versProd = subpCol.getVersionProd();
                        idSub = subpCol.getIdSubprod1();
                        versSub = subpCol.getVersionSubp();
                        versGen = subpCol.getVersionG();
                        colectivo = subpCol.getColectivo();
                    }
                } else // Mismo producto, distinta versión.
                if (idProd.equals(subpCol.getIdProducto())) {
                    contadorPasadas = 0;
                    // Añadimos rama a la lista de versiones.
                    arbol.add(rama);
                    this.removeVersionCero(arbol, rama);
                    // Formar rama del arbol: producto - subproductos,
                    // colectivos.
                    this.construyeRama(salida, arbol);
                    arbol = new ArrayList<VersionObj>(0);
                    // Nueva rama con la versión actual.
                    rama = new VersionObj();
                    rama.setNodo(subpCol);
                    rama.addNodoVersion(subpCol);
                    idProd = subpCol.getIdProducto();
                    idSub = subpCol.getIdSubprod1();
                    versSub = subpCol.getVersionSubp();
                    versGen = subpCol.getVersionG();
                    colectivo = subpCol.getColectivo();
                } else // Distinto producto.
                {
                    contadorPasadas = 0;
                    // Añadimos rama a la lista de versiones.
                    arbol.add(rama);
                    this.removeVersionCero(arbol, rama);
                    // Formar rama del arbol: producto - subproductos,
                    // colectivos.
                    this.construyeRama(salida, arbol);
                    arbol = new ArrayList<VersionObj>(0);
                    // Nueva rama con la versión actual.
                    rama = new VersionObj();
                    rama.setNodo(subpCol);
                    rama.addNodoVersion(subpCol);
                    idProd = subpCol.getIdProducto();
                    idSub = subpCol.getIdSubprod1();
                    versSub = subpCol.getVersionSubp();
                    versGen = subpCol.getVersionG();
                    colectivo = subpCol.getColectivo();
                }
            }
        }
        if (size > 0) {
            // Añadimos rama a la lista de versiones.
            arbol.add(rama);
            this.removeVersionCero(arbol, rama);
            // Formar rama del arbol: producto - subproductos, colectivos.
            this.construyeRama(salida, arbol);
        }
    }

    /**
     * @param idprod
     * @param descripcion
     * @return
     */
    public IContexto[] getBusquedaProductoCopiar(Integer idprod, String descripcion, String entidad) {
        GestionProducto gprod = new GestionProducto();
        List<ProductoC> productos = gprod.buscarProductos(idprod, descripcion, entidad);
        final IContexto[] contextoSalida = ContextosProducto.rellenarDatosContexto(productos);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Se ha buscado el producto correctamente.");
        }
        return contextoSalida;
    }

    /**
     * Devuelve los colectivos vigentes asociados a un producto. Tres posibles
     * casos: 1 - (colectivo = null) -> Productos, subproductos sin información
     * de colectivos. 2 - (colectivo = -1) -> Productos, subproductos con
     * cualquier colectivo. 3 - (colectivo = <valor>) -> Producto, subproductos
     * que tengan el colectivo determinado.
     *
     * @param versionSubpCol
     *        Producto con identificador de colectivo cero.
     * @param srcList
     *        Objetos recuperados de la tabla AN14TB01 - Relación Versiones.
     * @return
     */
    // private List<VersionSubpColectivoObj> obtenerColectivosVigentes(
    // final List<VersionSubpColectivoObj> srcList,
    // final VersionSubpColectivoObj versionSubp, final Integer colectivo)
    // {
    // // Gestor de colectivos.
    // 
    // GestionColectivos gc = new GestionColectivos();
    // // [F001317] Modificación --> Hay que comprobar también que el colectivo
    // // esté vigente
    // // para el subproducto (se cogen las fechas de vigencia de la tabla
    // // AN21TB01)
    // GestionSubproductoColectivo gsc = new GestionSubproductoColectivo();
    // // FIN Modificacion
    // 
    // List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(
    // 0);
    // 
    // // Si (colectivo = null) -> Sin información de colectivos.
    // if (!(UtilidadesTramitacion.isBlankOrNull(colectivo)))
    // {
    // for (VersionSubpColectivoObj srcVersionSubp : srcList)
    // {
    // // Los colectivos asociados al producto tienen el mismo:
    // // - Identificador de producto.
    // // - Versión de producto.
    // // - Identificador de subproducto.
    // // - Versión de subproducto.
    // // - Versión general.
    // // - Identificador de colectivo distinto de cero.
    // if ((versionSubp.getIdProducto().equals(srcVersionSubp
    // .getIdProducto()))
    // && (versionSubp.getVersionProd().equals(srcVersionSubp
    // .getVersionProd()))
    // && (versionSubp.getIdSubprod1().equals(srcVersionSubp
    // .getIdSubprod1()))
    // && (versionSubp.getVersionSubp().equals(srcVersionSubp
    // .getVersionSubp()))
    // && (versionSubp.getVersionG().equals(srcVersionSubp
    // .getVersionG()))
    // && (!(Constantes.CTE_CERO.equals(srcVersionSubp
    // .getColectivo()))))
    // {
    // // Identificador de colectivo recuperado de la tabla
    // // AN14TB01.
    // Integer versionColectivo = srcVersionSubp.getColectivo();
    // 
    // // Los colectivos se muestran en dos casos:
    // // 1 - Cuando el colectivo enviado como parámetro, tenga el
    // // valor -1 (Todos).
    // // 2 - Cuando el colectivo enviado como parámetro, coincida
    // // con el colectivo a tratar.
    // if ((Constantes.CTE_MENOS_UNO.equals(colectivo))
    // || (versionColectivo.equals(colectivo)))
    // {
    // 
    // ColectivosC colectivoC = gc
    // .obtenerColectivoVigente(new BigDecimal(
    // versionColectivo));
    // // [F001317] Modificación --> Hay que comprobar también
    // // que el colectivo esté vigente
    // // para el subproducto (se cogen las fechas de vigencia
    // // de la tabla AN21TB01)
    // List<SubproductoColectivoC> listaColectivos = gsc
    // .obtenerSubproductosColectivosVigentes(
    // versionSubp.getIdProducto(),
    // versionSubp.getIdSubprod1());
    // 
    // for (SubproductoColectivoC subColC : listaColectivos)
    // {
    // if (colectivoC != null
    // && colectivoC
    // .equals(subColC.getColectivo()))
    // {
    // srcVersionSubp.setDescColectivo(colectivoC
    // .getStrDescripcion());
    // // [F001317] Modificación --> Rellenamos fechas
    // // vigencia del subproducto-colectivo (Tabla
    // // AN21TB01)
    // srcVersionSubp.setDateFechaFin(colectivoC
    // //										.getDateFechaVigenciaHasta());
    // //								srcVersionSubp.setDateFechaInicio(colectivoC
    // //										.getDateFechaVigenciaDesde());
    // 
    // //								srcVersionSubp.setDateFechaFin(subColC
    // //										.getDateFechaVigenciaHasta());
    // //								srcVersionSubp.setDateFechaInicio(subColC
    // //										.getDateFechaVigenciaDesde());
    // // FIN Modificacion
    // destList.add(srcVersionSubp);
    // break;
    // }
    // }
    // 
    // // if (colectivoC != null)
    // // {
    // // srcVersionSubp.setDescColectivo(colectivoC.getStrDescripcion());
    // // destList.add(srcVersionSubp);
    // // }
    // // [F001317] FIN Modificación
    // }
    // }
    // }
    // }
    // 
    // return destList;
    // }
    /**
     * Devuelve los subproductos en estado vigente, futuro, o pasados con
     * periodo transitorio. Los subproductos con versión pasada y periodo
     * transitorio actualizan sus fechas (fechaDesde/fechaHasta) con las fechas
     * del periodo transitorio.
     *
     * @param srcList
     * @return
     */
    private List<VersionSubpColectivoObj> obtenerPeriodosTransitorios(final List<VersionSubpColectivoObj> srcList) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        for (VersionSubpColectivoObj versionSubpCol : srcList) {
            boolean addSubproducto = true;
            // Estado del subproducto (pasado, vigente, futuro).
            final int estado = GestionSubproductoColectivo.obtenerEstadoBusquedaVersion(versionSubpCol);
            versionSubpCol.setEstado(estado);
            if (estado == Constantes.CTE_ESTADO_VERSION_PASADO.intValue()) {
                // Períodos transitorios del tipo 'Solicitud'
                // (Constantes.CTE_CERO)
                // de un subproducto en estado pasado.
                /*
				 * List<PeriodoTransitorioC> periodosTransitoriosList =
				 * GestionPeriodoTransitorio.obtenerPeriodosVersion(
				 * versionSubpCol.getIdProducto(),
				 * versionSubpCol.getIdSubprod1(),
				 * versionSubpCol.getVersionG()); // Hay que comprobar que el
				 * período transitorio esté definido para // la fecha actual
				 * final int iSize = periodosTransitoriosList.size(); for (int
				 * i=iSize; i > 0; i--) { final PeriodoTransitorioC perTrans =
				 * periodosTransitoriosList.get(i-1); if
				 * (!obtenerPeriodoAplicaFecha(perTrans)) {
				 * periodosTransitoriosList.remove(i-1); } }
				 */
                // Períodos transitorios del tipo 'Solicitud'
                // (Constantes.CTE_CERO)
                // de un subproducto en estado pasado.
                final Date now = DateUtils.dateNow();
                // Períodos transitorios del tipo 'Solicitud'
                // (Constantes.CTE_CERO)
                // de un subproducto en estado pasado.
                List<PeriodoTransitorioC> periodosTransitoriosList = GestionPeriodoTransitorio.obtenerPeriodoTransitorioFechas(versionSubpCol.getIdProducto(), versionSubpCol.getIdSubprod1(), Constantes.CTE_CERO, DateUtils.toSQLDate(DateUtils.getSoloFecha(now)), DateUtils.getSoloHorario(now));
                // Hay que comprobar que el período transitorio corresponda a la
                // misma versión general.
                final int iSize = periodosTransitoriosList.size();
                for (int i = iSize; i > 0; i--) {
                    final PeriodoTransitorioC perTrans = periodosTransitoriosList.get(i - 1);
                    if (!perTrans.getPeriodoKey().getIdVersionGeneral().equals(versionSubpCol.getVersionG())) {
                        periodosTransitoriosList.remove(i - 1);
                    }
                }
                addSubproducto = (!(periodosTransitoriosList.isEmpty()));
                if (addSubproducto) {
                    // Un subproducto con versión pasada y periodo transitorio
                    // debe actualizar sus fechas (fechaDesde / fechaHasta).
                    PeriodoTransitorioC periodoTransitorio = periodosTransitoriosList.get(0);
                    versionSubpCol.setDateFechaInicio(periodoTransitorio.getFechaInicio());
                    versionSubpCol.setDateFechaFin(periodoTransitorio.getFechaFin());
                }
            }
            if (addSubproducto) {
                destList.add(versionSubpCol);
            }
        }
        return destList;
    }

    /**
     * Filtra la lista de subproductos de entrada utilizando el subproducto
     * recibido como parámetro.
     *
     * @param srcList
     *        Objetos recuperados de la tabla AN14TB01 - Relación Versiones.
     * @param codSubproducto
     *        Identificador de subproducto a filtrar.
     * @return
     */
    private List<VersionSubpColectivoObj> filtrarSubproductos(final List<VersionSubpColectivoObj> srcList, final Integer codSubproducto) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        for (VersionSubpColectivoObj versionSubp : srcList) {
            if (versionSubp.getIdSubprod1().equals(codSubproducto)) {
                destList.add(versionSubp);
            }
        }
        return destList;
    }

    /**
     * Filtra la lista de productos que se pasa como parametros, eliminando
     * aquellos productos que tienen una fecha tope de solicitud inferior a la
     * actual.
     *
     * @param srcList
     *        Objetos recuperados de la tabla AN14TB01 - Relación Versiones.
     * @return
     */
    private List<VersionSubpColectivoObj> filtrarProductosFechaTope(List<VersionSubpColectivoObj> srcList, Integer idVinculacion) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("INICIO: filtrando fecha tope solicitud.");
        }
        final Date fechaActual = DateUtils.dateNow();
        for (VersionSubpColectivoObj producto : srcList) {
            // Buscamos la fecha tope de solicitud del subproducto
            final List<String> listaTablas = new ArrayList<String>(Constantes.CTE_CERO);
            listaTablas.add(Constantes.CTE_TBL_SUBPRODUCTO);
            // final List<CEcc> lista = GestionVersiones.obtenerDatosVersion(producto.getIdProducto(), producto.getIdSubprod1(),
            // producto.getColectivo(), producto.getVersionG(), listaTablas, idVinculacion);
            final List<CEcc> lista = GestionVersiones.obtenerDatosVersionColectivos(producto.getIdProducto(), producto.getIdSubprod1(), producto.getColectivo(), producto.getVersionG(), producto.getVersionSubp(), listaTablas, idVinculacion);
            if (null != lista) {
                for (CEcc subprd : lista) {
                    final SubProductoC subproducto = (SubProductoC) subprd;
                    // si la fecha tope de solicitud es nula o la fecha actual es superior a la fecha tope de solicitud
                    if (DateUtils.isDateLessEqual(DateUtils.getSoloFecha(subproducto.getFechaSolicitud()), DateUtils.getSoloFecha(DateUtils.parseDate(DateUtils.CTE_DATELOWESTONLYDAY, DateUtils.FORMATO_FECHA_AMERICANO))) || DateUtils.isDateGreater(subproducto.getFechaSolicitud(), fechaActual)) {
                        destList.add(producto);
                    }
                }
            }
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("FIN: filtrando fecha tope solicitud.");
        }
        return destList;
    }

    /**
     *  V360020
     *
     * Elimina los subproductos que estén en estado futuro y no modificación.
     * Para este caso el estado es 5.
     * Los que están en modificación ya han sido eliminados previamente por tener
     * indice de operatividad a cero, ya que no han sido verificados todavía.
     * @param srcList
     * @return El listado filtrado
     */
    private List<VersionSubpColectivoObj> eliminarVersionesFuturas(final List<VersionSubpColectivoObj> srcList) {
        List<VersionSubpColectivoObj> destList = new ArrayList<VersionSubpColectivoObj>(0);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("INICIO: filtrando subproductos en estado futuro");
        }
        for (VersionSubpColectivoObj versionSubpCol : srcList) {
            boolean addSubproducto = true;
            if (versionSubpCol.getEstado() == Constantes.CTE_ESTADO_VERSION_FUTURA_OTRA_CURSO.intValue()) {
                addSubproducto = false;
            }
            if (addSubproducto) {
                destList.add(versionSubpCol);
            }
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("FIN: filtrando subproductos en estado futuro");
        }
        return destList;
    }

    /**
     * Método que realiza un filtrado de los productos devueltos por el servicio de búsqueda con colectivos (ANPM_168) en función
     * de la información que nos proporciona el servicio ANPM_437 (info sobre cambios de productos parametrizada en la tabla AN82TB01).
     *
     * El funcionamiento es el siguiente:
     * Invocamos el servicio ANPM_437. No le vamos a pasar el código producto de la solicitud porque necesitamos que nos devuelva la información
     * bidireccional para aquellos casos en que el producto de la solicitud no se pueda cambiar por determinados productos y viceversa.
     * Para ello, al no pasarle el código del producto se buscará en la tabla AN82TB01 sólo por la agrupación CAMBIOPROD, que es lo que necesitamos.
     *
     * El producto puede estar parametrizado en la AN82TB01 (agrupación CAMBIOPROD) de estas tres maneras:
     *  - ANPMN437020 = 0 --> NO APLICA: El servicio nos dice que el producto no está parametrizado y por lo tanto no va a afectar a la búsqueda.
     *  	No se hace el filtrado nuevo.
     *  - ANPMN437020 = 1 --> NO SE PUEDE CAMBIAR: El servicio nos dice que el producto origen no se puede cambiar por ninguno, sólo por si mismo, y
     *  	tambien que ningún otro producto se puede cambiar por éste, dos casos:
     *  		* Para hacer que este producto no se pueda cambiar por ninguno, en realidad aquí no se puede hacer, porque aquí lo que se hace es
     *  filtrar los resultados dado un posible código producto destino, el que tecleó el usuario, no el de la solicitud (aunque puedan ser iguales).
     *  Sin embargo esto ya se hizo antes: al cargar la ventana de búsqueda de productos ya se hizo una llamada al ANPM_437 para comprobar si se puede
     *  cambiar o no, y si no se puede cambiar ya se deshabilitó el entry del producto para que el usuario no lo pueda cambiar y sólo pueda buscar el
     *  propio producto de la solicitud, por si quiere actualizar la versión general, por ejemplo.
     *  		* El otro caso, hacer que el producto de la solicitud no pueda ser producto destino de ninguna otra solicitud, tiene que hacerse aquí
     *  de tal forma que se elimine en los resultados devueltos por este servicio, A NO SER QUE SEA EL PROPIO PRODUCTO DE LA SOLICITUD, en este caso
     *  se mantiene en los resultados.
     *  - ANPMN437020 = 2 --> EL PRODUCTO NO SE PUEDE CAMBIAR POR UNOS DETERMINADOS PRODUCTOS, Y VICEVERSA. Para hacer este filtrado se hace lo siguiente:
     *    - Por cada contexto en el que ANPMN437020 = 2:
     *     * Si el código producto de la solicitud coincide con el producto origen (ANPMN437010) entonces eliminamos de la búsqueda el producto
     *     	destino (ANPMN437030).
     *     * Si el código producto de la solicitud coincide con el producto destino (ANPMN437030) entonces eliminamos de la búsqueda el producto
     *     	origen (ANPMN437010).
     * Nota importante: hay que tener siempre en cuenta que en los resultados debe permanecer SIEMPRE el producto de la solicitud, en caso de que esté en
     * los resultados antes de este filtrado.
     *
     * Para saber si el producto está parametrizado se invoca el servicio ANPM_437.
     *
     * @param listaProd
     * @param idprod
     * @param codProdSolic
     * @return
     */
    private static List<BusquedaProdColectivoObj> filtradoPermitirCambioProdParam(List<BusquedaProdColectivoObj> listaProd, Integer idprod, BigDecimal codProdSolic, DatosSolicitudC datosSolicitud, BigDecimal nuc, String codProductoSubproductoHermes) {
        IDatosEntradaTx datosEntrada = null;
        IContexto[] resultadoCambiarProd = null;
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        List<BusquedaProdColectivoObj> salida = listaProd;
        List<BigDecimal> listaProdEliminar = new ArrayList<BigDecimal>(1);
        /*20150521 Crearemos una lista para meter en ella los SUBPRODUCTOS que tengamos que eliminar del resultado de la busqueda*/
        List<BusquedaProdColectivoObj> listaSubprodEliminarResto = new ArrayList<BusquedaProdColectivoObj>(1);
        BigDecimal codProductoNombreParam = null;
        BigDecimal codProductoValorParam = null;
        BigDecimal codProductoComparar = null;
        BigDecimal codProductoTecleado = null;
        BigDecimal modoCambio = null;
        /*Invocamos el ANPM_437 para saber si podemos cambiar el subproducto o no*/
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, new Integer(507), new Integer(437));
        // datosEntrada.addCampo("COD_PRODUCTO", new BigDecimal(idprod));
        /*20150203 No vamos a informar el código producto origen en la invocación al ANPM_437, 
		 * necesitamos todos los parametros con agrupación CAMBIOPROD. */
        datosEntrada.addCampo("COD_PRODUCTO", codProdSolic);
        resultadoCambiarProd = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if (null == idprod) {
            /*20150803 En este caso vamos a hacer que si existe el parametro tal que modo cambio = 2, si el código producto de la solicitud es igual
			 * al código producto del nombre del parámetro entonces eliminamos de la búsqueda el código producto de la columna valor.*/
            if (!UtilidadesTramitacion.isBlankOrNull(resultadoCambiarProd)) {
                salida = new ArrayList<BusquedaProdColectivoObj>(1);
            }
            // 20151013 Antes, el new Array... de listaProdEliminar estaba DENTRO del bucle de contextos de parámetro cambio prod/subprod.
            listaProdEliminar = new ArrayList<BigDecimal>(1);
            for (IContexto ctxCambiarProd : resultadoCambiarProd) {
                /*Obtenemos el código de producto parametrizado en la fila de la AN82TB01 que estamos procesando*/
                codProductoNombreParam = ctxCambiarProd.getBigDecimal("ANPMN437010");
                /*20150730 Sólo aplicamos esto cuando el parámetro que estamos recuperando aplica a este caso, es decir,
				 *  que el nombre del parámetro coincida con el producto tecleado*/
                modoCambio = ctxCambiarProd.getBigDecimal("ANPMN437020");
                if (Constantes.CTE_BID_2.equals(modoCambio)) {
                    codProductoValorParam = ctxCambiarProd.getBigDecimal("ANPMN437030");
                    /*Si el modo cambio es NO SE PUEDE CAMBIAR POR ESTE PRODUCTO DESTINO, se elimina del resultado de búsqueda:
					 * si el campo ANPMN437010 (producto nombre) coincide con el producto de la solicitud, se elimina el producto valor (ANPMN437030).*/
                    if (codProdSolic.equals(codProductoNombreParam)) {
                        codProductoComparar = codProductoValorParam;
                        listaProdEliminar.add(codProductoComparar);
                    }
                }
            }
            /*20151013 El bucle de filtrado de productos por cambios parametrizados se pone FUERA del bucle que recorre los parámetros de la AN82TB01.*/
            for (BusquedaProdColectivoObj productoBusqColect : listaProd) {
                /*Si el producto que estamos comprobando NO está en la lista de productos a eliminar y tampoco está en la lista de subproductos a eliminar 
				 * entonces se añade a la lista de resultados.*/
                if (!productoEstaEn(productoBusqColect, listaProdEliminar)) {
                    if (!salida.contains(productoBusqColect)) {
                        salida.add(productoBusqColect);
                    }
                }
            }
        } else {
            codProductoTecleado = new BigDecimal(idprod);
            /*Si el producto tecleado es el mismo que el de la solicitud no se elimina*/
            if (!codProdSolic.equals(codProductoTecleado)) {
                if (!UtilidadesTramitacion.isBlankOrNull(resultadoCambiarProd)) {
                    salida = new ArrayList<BusquedaProdColectivoObj>(1);
                }
                // 20150925 Antes, el new Array... de listaProdEliminar estaba DENTRO del bucle de contextos de parámetro cambio prod/subprod.
                listaProdEliminar = new ArrayList<BigDecimal>(1);
                for (IContexto ctxCambiarProd : resultadoCambiarProd) {
                    /*Obtenemos el código de producto parametrizado en la fila de la AN82TB01 que estamos procesando*/
                    codProductoNombreParam = ctxCambiarProd.getBigDecimal("ANPMN437010");
                    /*20150730 Sólo aplicamos esto cuando el parámetro que estamos recuperando aplica a este caso, es decir,
					 *  que el nombre del parámetro coincida con el producto tecleado*/
                    modoCambio = ctxCambiarProd.getBigDecimal("ANPMN437020");
                    /*Obtenemos la lista de productos a eliminar del resultado*/
                    if (BigDecimal.ZERO.equals(modoCambio)) {
                    /*Si el modo cambio es NO APLICA este producto no se elimina.*/
                    } else if (BigDecimal.ONE.equals(modoCambio)) {
                        /*Si el modo cambio es NO SE CAMBIA, se elimina del resultado de búsqueda. */
                        if (codProductoNombreParam.equals(codProdSolic)) {
                            listaProdEliminar.add(codProductoTecleado);
                        } else if (codProductoNombreParam.equals(codProductoTecleado)) {
                            listaProdEliminar.add(codProductoTecleado);
                        }
                    } else if (Constantes.CTE_BID_2.equals(modoCambio)) {
                        codProductoValorParam = ctxCambiarProd.getBigDecimal("ANPMN437030");
                        /*Si el modo cambio es NO SE PUEDE CAMBIAR POR ESTE PRODUCTO DESTINO, se elimina del resultado de búsqueda:
						 * si el campo ANPMN437010 (producto nombre) coincide con el producto de la solicitud, se elimina el producto valor (ANPMN437030).*/
                        if (codProdSolic.equals(codProductoNombreParam)) {
                            codProductoComparar = codProductoValorParam;
                            listaProdEliminar.add(codProductoComparar);
                        }
                    /* 20150730 Ahora cuando tenemos esta regla, la de lista de destinos no válidos, se hace de forma uni-direccional, es decir, sólo eliminamos los resultados donde 
	 * aparezca el código de producto que está en el campo Valor de la tabla de parámetros, es decir el código producto destino.
	*/
                    /*
						else if (codProdSolic.equals(codProductoValorParam))
						{
							codProductoComparar = codProductoNombreParam;
						}
	*/
                    }
                }
                // parámetros, por lo tanto lo pongo fuera de dicho bucle.
                for (BusquedaProdColectivoObj productoBusqColect : listaProd) {
                    /*Si el producto que estamos comprobando NO está en la lista de productos a eliminar y tampoco está en la lista de subproductos a eliminar 
					 * entonces se añade a la lista de resultados.*/
                    if (!productoEstaEn(productoBusqColect, listaProdEliminar)) {
                        if (!salida.contains(productoBusqColect)) {
                            salida.add(productoBusqColect);
                        }
                    }
                }
            } else {
                /*20150521 En el caso de que se esté buscando el mismo producto que ya estaba antes, comprobamos si este producto está parametrizado
				 * para que nos se pueda cambiar por ningún otro subproducto dentro de ese producto*/
                for (IContexto ctxCambiarProd : resultadoCambiarProd) {
                    codProductoNombreParam = ctxCambiarProd.getBigDecimal("ANPMN437010");
                    if (0 == codProductoNombreParam.compareTo(codProdSolic)) {
                        modoCambio = ctxCambiarProd.getBigDecimal("ANPMN437020");
                        if (BigDecimal.ONE.equals(modoCambio)) {
                            /*Vamos a eliminar de la lista de resultados aquellos subproductos que sean del mismo producto que el de la solicitud
							 * pero DIFERENTES al subproducto de la solicitud, por lo tanto lo que significa lo que almacenamos en la la lista de
							 * subproductos es eso: QUITAREMOS los subproductos que coincida en producto pero que NO tenga el mismo subproducto.*/
                            if (null != datosSolicitud) {
                                salida = new ArrayList<BusquedaProdColectivoObj>(1);
                                BusquedaProdColectivoObj subproductoEliminarResto = new BusquedaProdColectivoObj();
                                subproductoEliminarResto.setIdProducto(new Integer(datosSolicitud.getProducto().intValue()));
                                subproductoEliminarResto.setIdSubProducto(new Integer(datosSolicitud.getSubproducto().intValue()));
                                listaSubprodEliminarResto.add(subproductoEliminarResto);
                            /*20150521 Si el producto no se puede cambiar, modoCambio = 1, entonces no se puede cambiar por
								 * ningún otro subproducto, esto ya está hecho, PERO ADEMAS tampoco se puede cambiar por ningún otro subproducto*/
                            } else {
                                salida = new ArrayList<BusquedaProdColectivoObj>(1);
                                /*Estamos en un alta, pillamos el producto y subproducto que originales, los que tenía el expediente cuando se dió 
								 * de alta, para ello invocamos el CPRO_173 enviandole el usuario de la ejecución y el expediente
								 * 
								 * Este servicio nos devuelve un string con el producto y el subproducto, 7+7=14
								 * */
                                if (null == codProductoSubproductoHermes) {
                                    codProductoSubproductoHermes = obtenerCodProductoSubproductoHermes(nuc);
                                }
                                Integer codProductoOriginal = new Integer(codProductoSubproductoHermes.substring(Constantes.CTE_INT_CERO, Constantes.CTE_INT_SIETE));
                                Integer codSubproductoOriginal = new Integer(codProductoSubproductoHermes.substring(Constantes.CTE_INT_SIETE, Constantes.CTE_INT_CATORCE));
                                BusquedaProdColectivoObj subproductoEliminarResto = new BusquedaProdColectivoObj();
                                subproductoEliminarResto.setIdProducto(codProductoOriginal);
                                subproductoEliminarResto.setIdSubProducto(codSubproductoOriginal);
                                listaSubprodEliminarResto.add(subproductoEliminarResto);
                            }
                            for (BusquedaProdColectivoObj productoBusqColect : listaProd) {
                                if (!subproductoQuitarDeResultado(productoBusqColect, listaSubprodEliminarResto)) {
                                    if (!salida.contains(productoBusqColect)) {
                                        salida.add(productoBusqColect);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return salida;
    }

    /**
     * Quitaremos el subproducto del resultado si el producto que estamos comprobando, productoBusqColect, tiene el mismo producto Y SUBPRODUCTO DIFERENTE que alguno
     * de los que hay en la lista de subproductos del que hay que eliminar el resto de subproductos, listaSubprodEliminarResto
     *
     * @param productoBusqColect
     * @param listaSubprodEliminarResto
     * @return
     */
    private static boolean subproductoQuitarDeResultado(BusquedaProdColectivoObj productoBusqColect, List<BusquedaProdColectivoObj> listaSubprodEliminarResto) {
        boolean resultado = false;
        if (!UtilidadesTramitacion.isBlankOrNull(listaSubprodEliminarResto)) {
            /*Si el resultado es un subproducto*/
            if (Constantes.CTE_INTEGER_UNO != productoBusqColect.getTipo().intValue()) {
                for (BusquedaProdColectivoObj subprodEliminarResto : listaSubprodEliminarResto) {
                    /*Si coinciden los productos y el subproducto es diferente hay que eliminarlo. */
                    if ((0 == productoBusqColect.getIdProducto().compareTo(subprodEliminarResto.getIdProducto())) && (0 != productoBusqColect.getIdSubProducto().compareTo(subprodEliminarResto.getIdSubProducto()))) {
                        resultado = true;
                    }
                }
            }
        }
        return resultado;
    }

    /**
     * Comprueba si el producto está dentro de la lista de productos a eliminar.
     *
     * @param productoBusqColect
     * @param listaProdEliminar
     * @return
     */
    private static boolean productoEstaEn(BusquedaProdColectivoObj productoBusqColect, List<BigDecimal> listaProdEliminar) {
        boolean resultado = false;
        for (BigDecimal prodEliminar : listaProdEliminar) {
            if (prodEliminar.equals(new BigDecimal(productoBusqColect.getIdProducto()))) {
                resultado = true;
            }
        }
        return resultado;
    }

    /**
     * Filtramos los productos que coincidenc on el perscriptor.
     * @param listaProd
     * @param codPrescriptor
     * @return
     */
    public static List<BusquedaProdColectivoObj> filtrarPorTipoPrescriptor(List<BusquedaProdColectivoObj> listaProd, BigDecimal nuc, Integer idProducto) {
        /**
         * Lista con los subrpodcutos filtrados para devolver a la salida.
         */
        List<BusquedaProdColectivoObj> listaSalida = new ArrayList<BusquedaProdColectivoObj>();
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        DatosSolicitudC datosSolicitud = new DatosSolicitudC();
        datosSolicitud = gds.getUltimaVersion(nuc);
        // Consultamos el codigo de prescriptor para el nuc correspondiente.
        BigDecimal codigoPrescriptor = UtilidadesTramitacion.obtenerTipoPrescriptor(nuc);
        /**
         * Si el codigo de prescriptor es 0, no aplica.Devolvemos todos los posibles productos.
         */
        if (codigoPrescriptor != null && 0 != codigoPrescriptor.compareTo(BigDecimal.ZERO)) {
            // 20151008 Si el tipo prescriptor es externo el usuario debe informar el código producto tecleado, por lo tanto si no viene cascamos.
            if (null == idProducto) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_BUS_PROD_TIPO_PRESCR_EXTERNO_NO_PROD, null, null, null);
            }
            BigDecimal bidCodigoProducto = new BigDecimal(idProducto);
            BigDecimal bidCodigoPrescriptor = codigoPrescriptor;
            IContexto[] subproductosRelacionadosList = null;
            /**
             * Tenemos el codigo del prescriptor y el codigo del producto y con ello obtenemos los subproductos validos
             */
            // subproductosRelacionadosList =  UtilidadesTramitacion.compruebaRelacionPrescriptorProducto(bidCodigoProducto,bidCodigoPrescriptor,datosSolicitud.getSubproducto(),datosSolicitud.getIdTarifa());
            subproductosRelacionadosList = UtilidadesTramitacion.compruebaRelacionPrescriptorProducto(bidCodigoProducto, bidCodigoPrescriptor, null, null);
            if (null != subproductosRelacionadosList) {
                for (IContexto subproductoRelacionadoContexto : subproductosRelacionadosList) {
                    Integer codigoSubproductoRelacionado = subproductoRelacionadoContexto.getBigDecimal(Constantes.CTE_CTX_SUBPRODUCTO).intValue();
                    /**
                     * Vamos a filtrar dependiendo del codigo del prescriptor
                     * Los posibles codigos de prescriptor son:
                     * 3: Prescriptor idealista
                     * 4: Prescriptor //ABANCA web
                     * 0: No aplica
                     *
                     * Si el prescriptor es //ABANCA web vamos a devolver
                     * los subproductos: 1,2,3
                     *
                     * Si el prescriptor es Idealista vamos a devolver
                     * el subproducto 4
                     */
                    for (BusquedaProdColectivoObj objetoBusquedaProductoColectivo : listaProd) {
                        if (!UtilidadesTramitacion.isBlankOrNull(objetoBusquedaProductoColectivo.getIdSubProducto()) && objetoBusquedaProductoColectivo.getIdSubProducto().equals(codigoSubproductoRelacionado)) {
                            // Si tenemos correspondencia y no esta ya en la lista lo añadimos
                            if (!listaSalida.contains(objetoBusquedaProductoColectivo)) {
                                listaSalida.add(objetoBusquedaProductoColectivo);
                            }
                        }
                    }
                }
            }
        } else {
            return listaProd;
        }
        return listaSalida;
    }

    /**
     * Filtramos los productos que coincidenc on el perscriptor.
     * @param listaProd
     * @param codPrescriptor
     * @return
     */
    public static List<BusquedaProdColectivoObj> filtrarPorTipoPrescriptor(List<BusquedaProdColectivoObj> listaProd, BigDecimal nuc) {
        // Consultamos el codigo de prescriptor para el nuc correspondiente.
        Integer codigoPrescriptor = consultarPrescriptor(nuc).intValue();
        List<BusquedaProdColectivoObj> listaSalida = new ArrayList<BusquedaProdColectivoObj>();
        /**
         * Vamos a filtrar dependiendo del codigo del descriptor
         * Los posibles codigos de prescriptor son:
         * 3: Prescriptor idealista
         * 4: Prescriptor //ABANCA web
         * 0: No aplica
         *
         * Si el prescriptor es //ABANCA web vamos a devolver
         * los subproductos: 1,2,3
         *
         * Si el prescriptor es Idealista vamos a devolver
         * el subproducto 4
         */
        switch(codigoPrescriptor) {
            case Constantes.CTE_INT_CERO:
                // Si es cero no se hace nada
                return listaProd;
            case Constantes.CTE_INT_TRES:
                // Si es tres es un prescriptor idealista solo podemos devolver el subproducto 4
                for (BusquedaProdColectivoObj objetoBusquedaProductoColectivo : listaProd) {
                    if (!UtilidadesTramitacion.isBlankOrNull(objetoBusquedaProductoColectivo.getIdSubProducto()) && objetoBusquedaProductoColectivo.getIdSubProducto().equals(Constantes.CTE_INTEGER_CUATRO)) {
                        listaSalida.add(objetoBusquedaProductoColectivo);
                    }
                }
                break;
            case Constantes.CTE_INT_CUATRO:
                // Se puden contratar los subproductos 1,2,3
                for (BusquedaProdColectivoObj objetoBusquedaProdColectivo : listaProd) {
                    if (!UtilidadesTramitacion.isBlankOrNull(objetoBusquedaProdColectivo.getIdSubProducto())) {
                        if (objetoBusquedaProdColectivo.getIdSubProducto().equals(Constantes.CTE_INTEGER_UNO) || objetoBusquedaProdColectivo.getIdSubProducto().equals(Constantes.CTE_INTEGER_DOS) || objetoBusquedaProdColectivo.getIdSubProducto().equals(Constantes.CTE_INTEGER_TRES)) {
                            listaSalida.add(objetoBusquedaProdColectivo);
                        }
                    }
                }
                break;
            default:
                break;
        }
        return listaSalida;
    }

    /**
     * Este metodo consulta el prescriptor por nuc
     * @param nuc
     * @return
     */
    public static Integer consultarPrescriptor(BigDecimal nuc) {
        BigDecimal prescriptor = null;
        IDatosEntradaTx datosEntradaTx = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_PRESCRIPTOR, IConstantesTramitacion.CTE_CO_CONSULTA_PRESCRIPTOR);
        // Anahdimnos el campo de entrada del nuc
        datosEntradaTx.addCampo(IConstantesTramitacion.CTE_CPO_ENTRADA_CONSULTA_PRESCRIPTOR_NUC, nuc);
        // Invocar el srv
        IContexto[] salidaConsultaPrescriptor = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx);
        prescriptor = salidaConsultaPrescriptor[0].getBigDecimal(IConstantesTramitacion.CTE_CPO_SALIDA_CONSULTA_PRESCRIPTOR);
        return prescriptor.intValue();
    }

    /**
     * Llamada al servicio de negocio que obtiene el subproducto de catalogo
     * @param nuc
     * @return
     */
    private static String obtenerCodProductoSubproductoHermes(BigDecimal nuc) {
        String codProductoSubproductoHermes = null;
        IDatosEntradaTx datosEntrada = null;
        IContexto[] resultado = null;
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        String usuario = UtilidadesTramitacion.comprobarDatoNull(contextoEjecucion.getUsuario());
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, Constantes.CTE_SN_CONSULTA_PROD_SUBPROD_HERMES_CC, Constantes.CTE_SN_CONSULTA_PROD_SUBPROD_HERMES_CO);
        datosEntrada.addCampo(0, usuario);
        datosEntrada.addCampo(1, nuc);
        resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if (!UtilidadesTramitacion.isBlankOrNull(resultado)) {
            for (IContexto ctx : resultado) {
                if ("CP024CON".equals(ctx.getNombre())) {
                    codProductoSubproductoHermes = UtilidadesTramitacion.comprobarDatoNull(ctx.getString(Constantes.CTE_SN_CONSULTA_PROD_SUBPROD_HERMES_SAL_COD_PROD_SUB_PROD));
                }
            }
        }
        /*numérico ni de 14 caracteres. En estos casos no queremos que de error sino que devuelva código de producto = null*/
        if ((!StringUtils.isNumeric(codProductoSubproductoHermes)) || (Constantes.CTE_INT_CATORCE != codProductoSubproductoHermes.length())) {
            if (StringUtils.equals(Constantes.CTE_STR_PROD_EXP_NOVACION, codProductoSubproductoHermes) || StringUtils.equals(Constantes.CTE_STR_PROD_EXP_AMPLIACION, codProductoSubproductoHermes) || StringUtils.equals(Constantes.CTE_STR_PROD_EXP_SUBROGACION, codProductoSubproductoHermes) || StringUtils.equals(Constantes.CTE_STR_PROD_EXP_SUBROG_AMPLIACION, codProductoSubproductoHermes)) {
                codProductoSubproductoHermes = null;
            } else {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_COD_PRODUCTO_HERMES, null, new String[] { codProductoSubproductoHermes }, null);
            }
        }
        return codProductoSubproductoHermes;
    }

    /**
     * Busca lineas de colectivo
     * @param colectivo
     * @return
     */
    private List<ColectivosLineasColecC> buscarLineasColectivo(Integer colectivo) {
        ColectivosLineasColecEng dao = new ColectivosLineasColecEng();
        List<ColectivosLineasColecC> lineasColectivos = dao.obtenerLineasColectivos(colectivo);
        return lineasColectivos;
    }

    /**
     * Construye una lista de carteras
     * @param clientesAsociados
     * @param nucExpediente
     * @return
     */
    private List<String> construirListaCarteras(IContexto[] clientesAsociados, BigDecimal nucExpediente) {
        List<String> carterasAsociadas = new ArrayList<String>(clientesAsociados.length);
        for (IContexto cliente : clientesAsociados) {
            String codigoCarteraModelo = consultarDetalleCarteraActivaCliente(cliente.getBigDecimal("FC722C0040"));
            String cartera = consultarDetalleCarteraModelo(codigoCarteraModelo, nucExpediente);
            carterasAsociadas.add(cartera);
        }
        return carterasAsociadas;
    }

    /**
     * Busca si la cartera que tenemos en AN03 es la misma que la del cliente sino deberia filtrarse.
     * @param nucExpediente
     * @param carteraCatalogo
     * @return
     */
    public List<VersionSubpColectivoObj> filtrarCarteraCliente(BigDecimal nucExpediente, List<VersionSubpColectivoObj> versionSubpColList) {
        IContexto[] clientesAsociadosAnuc = consultarClientesPorContrato(nucExpediente);
        List<String> carterasAsociadasAnuc = new ArrayList<String>();
        String carteraCatalogo = new String();
        List<VersionSubpColectivoObj> listaSalida = new ArrayList<VersionSubpColectivoObj>();
        carterasAsociadasAnuc = this.construirListaCarteras(clientesAsociadosAnuc, nucExpediente);
        if (null != clientesAsociadosAnuc && clientesAsociadosAnuc.length > 0) {
            if (null != versionSubpColList && versionSubpColList.size() > 0) {
                GestionDatEco gde = new GestionDatEco();
                for (VersionSubpColectivoObj versionSubColecObj : versionSubpColList) {
                    VersionesC version = GestionVersiones.obtenerVersion(versionSubColecObj.getIdProducto(), versionSubColecObj.getIdSubprod1(), versionSubColecObj.getVersionG(), versionSubColecObj.getColectivo());
                    List<DatEcoC> datosEconomicoList = gde.obtenerDatosSubProducto(versionSubColecObj.getIdProducto(), versionSubColecObj.getIdSubprod1(), versionSubColecObj.getColectivo(), version.getAn03tb01(), false);
                    // Tenemos que coger el nivel oficina en la busqsueda
                    for (DatEcoC datoEconomico : datosEconomicoList) {
                        if (datoEconomico.getNivel().equals(ConstantesComun.CTE_INT_DIEZ) || datoEconomico.getNivel().equals(Constantes.CTE_INT_CERO)) {
                            carteraCatalogo = datoEconomico.getCarteraDefecto();
                        }
                        for (String cartera : carterasAsociadasAnuc) {
                            // Cogeremos siempre el nivel de catalogo de la cartera
                            if (null != carteraCatalogo && null != cartera) {
                                if (datoEconomico.getIndCartera().trim().equals(ConstantesComun.CTE_STR_0) || datoEconomico.getIndCartera().trim().equals(ConstantesComun.CTE_STR_EMPTY)) {
                                    // No aplica se añade
                                    if (!listaSalida.contains(versionSubColecObj)) {
                                        listaSalida.add(versionSubColecObj);
                                    }
                                } else if (datoEconomico.getIndCartera().equals(ConstantesComun.CTE_STR_1)) {
                                    if (carteraCatalogo.equals(cartera)) {
                                        if (!listaSalida.contains(versionSubColecObj)) {
                                            listaSalida.add(versionSubColecObj);
                                        }
                                    }
                                } else if (datoEconomico.getIndCartera().equals(ConstantesComun.CTE_STR_2)) {
                                    // Con indicador 2 se mira en catalogo las clausulas restringidas
                                    List<ClausulaRestringuidaC> listaClausulas = GestionClausulasRestringuidas.obtenerClausulasRestringuidasCarteras(versionSubColecObj.getIdProducto(), versionSubColecObj.getIdSubprod1(), "CAT");
                                    for (ClausulaRestringuidaC clausula : listaClausulas) {
                                        if (clausula.getValor().trim().equals(cartera)) {
                                            if (!listaSalida.contains(versionSubColecObj)) {
                                                listaSalida.add(versionSubColecObj);
                                            }
                                        }
                                    }
                                } else if (datoEconomico.getIndCartera().equals(ConstantesComun.CTE_STR_3) || datoEconomico.getIndCartera().equals(ConstantesComun.CTE_STR_4)) {
                                    // Son validos todos los presentes en CG32TB01
                                    List<ParametrosC> listaParametros = GestionParametros.obtenerClausulasCarteras("CAT");
                                    for (ParametrosC parametro : listaParametros) {
                                        if (parametro.getParametrosKey().getCodTabla().trim().equals(cartera)) {
                                            if (!listaSalida.contains(versionSubColecObj)) {
                                                listaSalida.add(versionSubColecObj);
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (!listaSalida.contains(versionSubColecObj)) {
                                    listaSalida.add(versionSubColecObj);
                                }
                            }
                        }
                    }
                }
            }
        } else {
            // Si no tiene clientes no se hace nada.
            listaSalida = versionSubpColList;
        }
        return listaSalida;
    }

    /**
     * Devuelve los clientes titulares asociados a un nuc
     * @param nucExpediente
     */
    public static IContexto[] consultarClientesPorContrato(BigDecimal nucExpediente) {
        // Inicializar los campos del SR
        IDatosEntradaTx datosEntradaTX = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_CLIENTES, IConstantesTramitacion.CTE_CO_CONSULTA_POR_CONTRATO);
        // Añadir el nuc como campo de entrada del servicio de negocio
        datosEntradaTX.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_CONSULTA_POR_CONTRATO, nucExpediente);
        // Invocar el srv
        IContexto[] salidaConsultaClientePorContrato = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTX);
        List<IContexto> clientesTitularesListAux = new ArrayList<IContexto>();
        // Filtrar los clientes titulares
        for (IContexto contextoCliente : salidaConsultaClientePorContrato) {
            if (contextoCliente.getString(IConstantesTramitacion.CTE_CTX_RELACION_CLIENTE).equals(Constantes.CTE_STR_01)) {
                clientesTitularesListAux.add(contextoCliente);
            }
        }
        // Mandar a la salida los clientes titualres filtrados
        salidaConsultaClientePorContrato = clientesTitularesListAux.toArray(new IContexto[clientesTitularesListAux.size()]);
        return salidaConsultaClientePorContrato;
    }

    /**
     * Llama al YINT_035 para consultar la cartera activa de un cliente
     * @param nucExpediente
     */
    public static String consultarDetalleCarteraActivaCliente(BigDecimal numeroCliente) {
        String codigoCarteraModelo = new String();
        // Inicializar los campos del SR
        IDatosEntradaTx datosEntradaTX = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_CARTERAS, IConstantesTramitacion.CTE_CO_DETALLE_CARTERA_ACTIVA);
        // Añadir el nuc como campo de entrada del servicio de negocio
        datosEntradaTX.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_CONSULTA_DETALLE_CARTERA_NUMERO_CLIENTE, numeroCliente);
        // Invocar el srv
        IContexto[] salidaConsultaDetalleCarteraActiva = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTX);
        if (null != salidaConsultaDetalleCarteraActiva && salidaConsultaDetalleCarteraActiva.length > 0) {
            for (IContexto contextoCartera : salidaConsultaDetalleCarteraActiva) {
                codigoCarteraModelo = contextoCartera.getString(IConstantesTramitacion.CTE_CTX_CODIGO_CARTERA_MODELO_YINTN004050);
            }
        }
        return codigoCarteraModelo;
    }

    /**
     * Llama al YINT_013 para consultar la cartera activa de un cliente
     * @param nucExpediente
     */
    public static String consultarDetalleCarteraModelo(String codigoCarteraModelo, BigDecimal nucExpediente) {
        String cartera = new String();
        if (null != codigoCarteraModelo && !codigoCarteraModelo.equals(Constantes.CTE_STRING_EMPTY)) {
            // Inicializar los campos del SR
            IDatosEntradaTx datosEntradaTX = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), IConstantesTramitacion.CTE_CC_CONSULTA_CARTERAS, IConstantesTramitacion.CTE_CO_DETALLE_CARTERA_MODELO);
            // Añadir el nuc como campo de entrada del servicio de negocio
            datosEntradaTX.addCampo(IConstantesTramitacion.CTE_CAMPO_ENTRADA_CONSULTA_DETALLE_CAR_MODELO_CODIGO_CARTERA_MODELO, codigoCarteraModelo);
            // Invocar el srv
            IContexto[] salidaConsultaClientePorContrato = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTX);
            if (null != salidaConsultaClientePorContrato && salidaConsultaClientePorContrato.length > 0) {
                for (IContexto contextoCliente : salidaConsultaClientePorContrato) {
                    cartera = StringUtils.substring(contextoCliente.getString(IConstantesTramitacion.CTE_CTX_CODIGO_TIPO_CARTERA_YINTN002050), 0, 2);
                }
            }
        }
        if (UtilidadesTramitacion.comprobarControlOperatoria(nucExpediente, new BigDecimal(22000), false)) {
            cartera = new String("SP");
        }
        return cartera;
    }

    /**
     * Método que tras comprobar si el participante del NUC es una comunidad de propietarios
     * realiza un filtrado para los productos válidos para comunidad de propietarios
     *
     * @param listaProd
     * @param nuc
     * @return
     */
    private List<VersionSubpColectivoObj> filtrarComunidadPropietarios(List<VersionSubpColectivoObj> listaProd, BigDecimal nuc) {
        List<VersionSubpColectivoObj> listaSalida = new ArrayList<VersionSubpColectivoObj>();
        // Se invoca el FCLI_722 para determinar si es o no comunidad de propietarios
        if (UtilidadesComun.esComunidadPropietarios(nuc)) {
            for (VersionSubpColectivoObj prod : listaProd) {
                // Si se trata de un subproducto exclusivo de Comunidad de bienes,se añade a la lista de Salida
                SubProductoC subp = GestionSubProducto.obtenerSubProductoActivoUtimaVersion(prod.getIdProducto(), prod.getIdSubprod1());
                if (null != subp) {
                    if (CTE_EXCLUSIVIDAD_COM_BIENES.equals(subp.getExclusividad())) {
                        listaSalida.add(prod);
                    }
                }
            }
        } else {
            return listaProd;
        }
        return listaSalida;
    }

    private static final String FIJO_3142984 = "FIJO_3142984";

    private static final String VARIABLE_1249586564 = "VARIABLE_1249586564";

    private static final String VARIABLE_BONIFICABLE_1858709010 = "VARIABLE_BONIFICABLE_1858709010";

    private static final String FIJO_REFERENCIADO_2130014933 = "FIJO_REFERENCIADO_2130014933";

    private static final String FIJO_CAMPA_AS_1121213115 = "FIJO_CAMPA_AS_1121213115";

    private static final String VARIABLE_PENALIZABLE_712625771 = "VARIABLE_PENALIZABLE_712625771";

    private static final String VARIABLE_INICIAL_FIJO_268281213 = "VARIABLE_INICIAL_FIJO_268281213";

    private static final String INTERES_1958062730 = "INTERES_1958062730";

    private static final String VARIABLE_CAMPA_AS_1368594439 = "VARIABLE_CAMPA_AS_1368594439";
}
