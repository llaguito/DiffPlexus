/**
 * Aplicacion de Activo
 * Caixa Galicia © 2009-2010
 * 
 * 
 */

package es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang.StringUtils;

import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.destinos.DestinosC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDestinosPrestamo;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextosDestinosPrestamo;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.CodigosError;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesTramitacion;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.ResultadoDestinosVO;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.ResultadoVO;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.RollbackException;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.log.LogHelper;

/**
 * Servicio para Añadir o Modificar destinos
 * 
 * @author F001288
 * @author F001329
 *
 */
public class DestinosAltaSrv extends ServicioNegocio
{
	private static final int CTE_TAMANO_DESTINO = 218;	
	
	private static final String CTE_ITERACION = "ITERACION";
	private static final String CTE_DATOS_DESTINO_1 = "DATOS_DESTINO1";
	private static final String CTE_DATOS_DESTINO_2 = "DATOS_DESTINO2";
	private static final String CTE_DATOS_DESTINO_3 = "DATOS_DESTINO3";
	private static final String CTE_DATOS_DESTINO_4 = "DATOS_DESTINO4";
	
	/**
	 * Log de la clase.
	 */
	private static final LogHelper LOGGER = LogHelper.getLog(DestinosAltaSrv.class);
	
	
	/**
	 * Constructor sin parametros
	 */
	public DestinosAltaSrv()
	{
		super();
	}
	
	/**
	 * metodo que a partir de un String  de 216 caracterescrea un objeto de tipo DestinoC
	 * @param datosDdestinos
	 * @return <code>DestinosC</code>
	 */
	private DestinosC obtenerDestinoC(String datosDestinos)
	{
		String codigoDestino = datosDestinos.substring(0, 7);
		String ofiSolicitud = datosDestinos.substring(7, 11);
		String numSolicitud = datosDestinos.substring(11, 17);
		String versionSolicitud = datosDestinos.substring(17, 24);
		String nucExpediente = datosDestinos.substring(24, 39);
		String destino = datosDestinos.substring(39, 43);
		String nivelDestino = datosDestinos.substring(43, 48);
		String subDestino = datosDestinos.substring(48, 52);
		String comentario = datosDestinos.substring(52, 202);
		// Se toma como tamaño 8 porque se cuenta el . decimal
		String porcentaje = datosDestinos.substring(202, 210);
		String esPrincipal = datosDestinos.substring(210, 211); 
		String usuario = datosDestinos.substring(211).trim();
		
		DestinosC destinoc = new DestinosC(Integer.valueOf(codigoDestino), 
				destino, Integer.valueOf(nivelDestino), subDestino, comentario, new BigDecimal(porcentaje),
				esPrincipal, usuario);
		
		DatosSolicitudC solicitud = new DatosSolicitudC();
		solicitud.getDatosSolicitudKey().setNucExpediente(new BigDecimal(nucExpediente));
		solicitud.getDatosSolicitudKey().setNumSolicitud(new BigDecimal(numSolicitud));
		solicitud.getDatosSolicitudKey().setOficinaSolicitud(new BigDecimal(ofiSolicitud));
		solicitud.getDatosSolicitudKey().setVersionSolicitud(new BigDecimal(versionSolicitud));
		
		destinoc.setSolicitud(solicitud);
		
		return destinoc;
	}	
	
	/*
	 *  Metodo para trasformar los datos de entrada en destinosC. 
	 *  En 1023 caracteres se pueden recibir como maximo 4 destinos, cada destino 
	 *  ocupara como maximo 216 caracteres * 4 destinos = 864 caracteres
	 *  Codigo destino			7
	 *  Oficina de la solicitud	4
	 *  Numero de la solicitud	6
	 *  Versión de la solicitud	7
	 *  Nuc de expediente		15
	 *  Destino					4
	 *  Nivel del destino		5
	 *  Subdestino				4
	 *  Comentario			    150
	 *  Porcentaje				7
	 *  Es_principal			1
	 *  Usuario					8
	 *  
	 *  El porcentaje debe almacenar a mayores el . de los decimales
	 */
	/**
	 * Metodo que recibe un conjunto de destinos en forma de cadena y los transforma en una lista de objetos
	 * de tipo DestinosC
	 * @param datosDestinos Cadena que se recibe con el conjunto de destinos
	 * @return <code>List<DestinosC></code>
	 */
	private List<DestinosC> obtenerDestinos(String datosDestinos)
	{
		// Se calcula cuantos destinos se estan recibiendo, debe ser un multiplo de 208
		final int numDestinos = datosDestinos.length() / CTE_TAMANO_DESTINO;		
		
		//Creamos una lista para albergar tantos destinos como se pasen como parametro
		List<DestinosC> destinos = new ArrayList<DestinosC>(numDestinos);
		
		// Una vez se conoce el numero de destinos que se reciben, se transforman 
		// en una lista de objetos del tipo DestinosC.
		int j = 0;
		for (int i = 0; i < numDestinos; i++)
		{
			String destino1 = datosDestinos.substring(j, j + CTE_TAMANO_DESTINO);
			
			DestinosC destino = new DestinosC();
			destino = obtenerDestinoC(destino1);
			if (destino != null)
			{
				destinos.add(destino);
			}
			
			// Se incrementa en 209 posiciones para coger la cadena que define el Destino entero
			j += CTE_TAMANO_DESTINO; 
		}

		return destinos;
	}
	
	/**
	 * Metodo que devolverá true si el destino es válido
	 * @param destino
	 * @return <code>ResultadoVO</code> código de error si no es válido
	 */
	private ResultadoVO isValid(IContextoEjecucion contexto, DestinosC destino)
	{ 
		
		ResultadoVO res = new ResultadoVO();
		res.setCodigoResultado(CodigosError.NO_ERROR);
		
		if (destino == null)
		{
			res.setCodigoResultado(CodigosError.ERROR_SIN_DATOS);
		}
		else 
		{
			
			if (UtilidadesTramitacion.isBlankOrNull(destino.getOficinaSolicitud()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getNumSolicitud()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getVersionSolicitud()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getNucExpediente()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getDestino()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getPorcentaje()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getEsPrincipal()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getUsuario()) || 
				UtilidadesTramitacion.isBlankOrNull(destino.getTimestamp()))
			{
				res.setCodigoResultado(CodigosError.ERROR_FALTAN_CAMPOS_OBLIGATORIOS);
			}
					
			// Comprobamos el subdestino. Solo es obligatorio en caso de que
			// el destino principal tenga definidos valores posibles de subdestinos.
			// Hay que tener en cuenta que existen destinos principales sin subdestinos.
			if (res.getCodigoResultado() != CodigosError.NO_ERROR && UtilidadesTramitacion.isBlankOrNull(destino.getSubdestino()) || 
					IConstantesTramitacion.CTE_SIN_SUBDESTINO.equalsIgnoreCase(destino.getSubdestino()))
			{
				// Comprobamos si se trata de un destino principal sin posibles subdestinos
					
				// Llamamos al servicio de consulta de parámetros para obtener la lista
				// de destinos
				IDatosEntradaTx datosEntradaSrvParam = getPrograma(contexto, 
						IConstantesTramitacion.CTE_CC_CONSULTA_PARAM, IConstantesTramitacion.CTE_CO_CONSULTA_PARAM);
				datosEntradaSrvParam.addCampo("OPERACION", IConstantesTramitacion.CTE_OPERACION_CONSULTA_PARAM);
				datosEntradaSrvParam.addCampo("PASO", BigDecimal.ONE);
				IContexto[] salidaSrvParam = invocarServicio(contexto, datosEntradaSrvParam);
						
				// Comprobamos si admite subdestinos en cuyo caso mostramos el error
				// de campo obligatorio al no estar informado
				if (salidaSrvParam != null && BigDecimal.ZERO.intValue() < salidaSrvParam.length) 
				{
					final int iSize = salidaSrvParam.length; 
					for (int i = 0; i < iSize; i++)
					{
						if (salidaSrvParam[i].getString(IConstantesTramitacion.CTE_CAMPO_ID_PARAM)
								.equalsIgnoreCase(IConstantesTramitacion.CTE_ID_DESTINO) &&
							salidaSrvParam[i].getString(IConstantesTramitacion.CTE_CAMPO_VAL_PARAM)
								.equalsIgnoreCase(destino.getDestino()) &&
							!UtilidadesTramitacion.isBlankOrNull(salidaSrvParam[i].getString(
									IConstantesTramitacion.CTE_CAMPO_IND_SUBDESTINO)))
						{
							res.setCodigoResultado(CodigosError.ERROR_FALTAN_CAMPOS_OBLIGATORIOS);
							break;
						}
					}
				}
			}
		}
		
		
		return res;
	}	
	
	/**
	 * Metodo que validará la lista de destinos
	 * @param destinos Lista de destinos
	 * @return <code>ResultadoVO</code> código de error si no es válido
	 */
	private ResultadoVO validarDestinos(IContextoEjecucion contexto, List<DestinosC> destinos)
	{		
		ResultadoVO res = new ResultadoVO();
		res.setCodigoResultado(CodigosError.NO_ERROR);
		final BigDecimal MAX_PORCENTAJE = new BigDecimal(100);
				
		for (DestinosC dest : destinos)
		{			
			res = this.isValid(contexto, dest);
			if (!(CodigosError.NO_ERROR.intValue() == res.getCodigoResultado())) 
			{
				break;
			}
		}
		
		if (CodigosError.NO_ERROR.intValue() == res.getCodigoResultado())
		{
			res.setCodigoResultado(CodigosError.ERROR_SIN_DESTINO_PRINCIPAL);
			// Garantizar que haya como mínimo un destino principal.
			for (DestinosC dest : destinos)
			{
				if (dest.isPrincipal())
				{
					res.setCodigoResultado(CodigosError.NO_ERROR);
					break;
				}
			}
		}
		
		if (CodigosError.NO_ERROR.intValue() == res.getCodigoResultado())
		{
			BigDecimal porcentajeTotal = BigDecimal.ZERO;
			for (DestinosC dest : destinos)
			{
				porcentajeTotal = porcentajeTotal.add(dest.getPorcentaje());
			}
			
			// La suma de porcentajes debe ser igual a 100.
			if (0 != MAX_PORCENTAJE.compareTo(porcentajeTotal))
			{
				res.setCodigoResultado(CodigosError.ERROR_DESTINOS_PORCENTAJE_INCORRECTO);
			}
		}

		return res;
	}
		
	/**
	 * Metodo ejecutar
	 * @param contexto
	 * @param datosEntrada
	 * @return <code>IContexto[]</code>
	 */
	// TODO: Falta definir el código de error del servicio.
	public IContexto[] ejecutar(IContextoEjecucion contexto, IDatosEntradaTx datosEntrada)
	{
		final int ERROR_VALIDACION_DESTINOS = 11;
		final long lInicio = System.currentTimeMillis();
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("INICIO SNANPM160: Alta/modificación de destinos de un préstamo.");						
		}
		
		contexto.setDiarioElectronico(new DiarioElectronico(
				Constantes.CTE_OPERACION_AC,
				Integer.valueOf(0),
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                Constantes.CTE_STRING_EMPTY,
                Constantes.CTE_STRING_EMPTY,
                BigDecimal.ZERO,
                BigDecimal.ZERO,
                Integer.valueOf(0)));
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Obtenemos los parametros de entrada");
		}
				
		String bidIteracion = datosEntrada.getString(CTE_ITERACION);
		String strDatosDestinos1 = datosEntrada.getString(CTE_DATOS_DESTINO_1); 
		String strDatosDestinos2 = datosEntrada.getString(CTE_DATOS_DESTINO_2);
		String strDatosDestinos3 = datosEntrada.getString(CTE_DATOS_DESTINO_3);
		String strDatosDestinos4 = datosEntrada.getString(CTE_DATOS_DESTINO_4);
				
		Integer iteracion = null;
		
		if (bidIteracion != null)
		{
			iteracion = Integer.parseInt(bidIteracion);
		}

		List<DestinosC> listaDestinos = new ArrayList<DestinosC>(0);		
		
		if (!(UtilidadesTramitacion.isEmptyOrNullString(strDatosDestinos1)))
		{
			listaDestinos.addAll(this.obtenerDestinos(strDatosDestinos1));
		}
		
		if (!(UtilidadesTramitacion.isEmptyOrNullString(strDatosDestinos2)))
		{
			listaDestinos.addAll(this.obtenerDestinos(strDatosDestinos2));
		}

		if (!(UtilidadesTramitacion.isEmptyOrNullString(strDatosDestinos3)))
		{
			listaDestinos.addAll(this.obtenerDestinos(strDatosDestinos3));
		}

		if (!(UtilidadesTramitacion.isEmptyOrNullString(strDatosDestinos4)))
		{
			listaDestinos.addAll(this.obtenerDestinos(strDatosDestinos4));
		}
		
		// SE ASIGNA LA SOLICITUD A CADA DESTINO
		GestionDatosSolicitud gds = new GestionDatosSolicitud();

		// Se extrae el priemr destino para obtner la clave foranea de DatosSolicitud (Es comun a todos los destinos)
		DestinosC destino = listaDestinos.get(0);
		
		// Se intenta obtener la solicitud
		DatosSolicitudC solicitud = gds.obtenerDatosSolicitud(destino.getOficinaSolicitud(), 
									destino.getNumSolicitud(), 
									destino.getVersionSolicitud(), 
									destino.getNucExpediente());
		
		// Si la solicitud no existe se crea
		if (solicitud == null)
		{
			solicitud = new DatosSolicitudC();
			solicitud.getDatosSolicitudKey().setNucExpediente(destino.getNucExpediente());
			solicitud.getDatosSolicitudKey().setNumSolicitud(destino.getNumSolicitud());
			solicitud.getDatosSolicitudKey().setOficinaSolicitud(destino.getOficinaSolicitud());
			solicitud.getDatosSolicitudKey().setVersionSolicitud(destino.getVersionSolicitud());
			solicitud.setMaxDestino(BigDecimal.valueOf(listaDestinos.size()));
			
			//20150925 Cuando generamos una versión incompleta a través del alta de destinos Y ES UNA ALTA DE TRAMITACION
			//guardamos canal 1 --> Oficina.
			solicitud.setCanal(BigDecimal.ONE); //Canal 1: Oficina
			/*20151026 Establecemos la marca de última versión*/
			solicitud.setStrIndicador3(Constantes.CTE_STR_S);
			
			gds.altaSolicitudTemporal(solicitud);
		}
		
	
		
		// Para cada destino se añade sus solicitud asociada
		for (DestinosC dest : listaDestinos)
		{			
			dest.setSolicitud(solicitud);
		}
		
	
				
		destino = null;
		Integer codigoError = ERROR_VALIDACION_DESTINOS;		
		
		// Si la lista de destinos es consistente, se insertan en la base de datos.
		ResultadoVO res = this.validarDestinos(contexto, listaDestinos); 
		if (CodigosError.NO_ERROR.intValue() == res.getCodigoResultado())
		{
			try
			{
				GestionDestinosPrestamo gde = new GestionDestinosPrestamo();
				
				destino = listaDestinos.get(0);
				
				// Borrar todos los destinos asociados.
				// Debido a limitaciones del entorno cliente (NS-DK), la gestión de destinos 
				// exige borrar los existentes e insertar de nuevo todo el bloque de destinos.
				gde.deleteDestinos(destino.getOficinaSolicitud(), 
						destino.getNumSolicitud(), destino.getVersionSolicitud(), 
						destino.getNucExpediente());
				
				// Insertar el bloque de destinos.
				ResultadoDestinosVO resultado = gde.guardarListaDestinos(listaDestinos);
				
				// El destino incluido en el resultado (ResultadosDestinosVO) es 
				// el destino principal con mayor porcentaje.
				codigoError = resultado.getCodError();
				destino = resultado.getDatos();
			}
			catch (RollbackException re)
			{
				throw new RuntimeException(
					new StringBuilder
						("ERR_ANPM_010 - Imposible añadir lista de destinos: ")
				   .append
				   		(re.getMessage()).toString());
			}
		}
		else 
		{
			ServicioNegocio.rollback(res.getCodigoResultado(), null, null, null);
		}
		
		List<IContexto> lstContextosSalida = new ArrayList<IContexto>();
		
		/**
		 * Se comprueba la validez de cada uno de los destinos
		 * 	invocamos para ello al modulo de comprobaciones a traves de un servicio de negocio
		 * 	asi no generamos interdependencias.
		 */				
		IContexto[] ctxResultado = GestionDatosSolicitud.ctxComprobacionesTramitacion(
				solicitud.getDatosSolicitudKey().getNucExpediente(),BigDecimal.ZERO,null);	
		
		if(null != ctxResultado){
			String advertencia = ctxResultado[0].getString("ANPMN454030"); // se recupera el campo advertencia del contexto 454 
			String destinoError= ctxResultado[0].getString("ANPMN454040");
			if(null != ctxResultado && StringUtils.isNotEmpty(advertencia)){
				if (StringUtils.isNotEmpty(destinoError))  
				{
					//DatosSolicitudEng eng = new DatosSolicitudEng();
					if(destinoError.trim().equals("5025")){
						//Actualizar marca destino 5025 indicador deudas distintas a vivienda
						solicitud.setIndicadorCarObrasMejoras(BigDecimal.ONE);
						//solicitud.update();
						//eng.update(solicitud);
					}else if(destinoError.trim().equals("5202")){
						//Actualizar marca destino 5202 indicador de obras y mejoras
						solicitud.setIndicadorCarDeudasDistintasVivienda(BigDecimal.ONE);
						//solicitud.update();
						//eng.update(solicitud);
					}
				}
			}
			
			if (StringUtils.isNotEmpty(advertencia))  // si la advertencia no es vacía, entonces añadimos el contexto del ANPMN454 al contexto de salida
			{
				lstContextosSalida.add(ctxResultado[0]);
			}else{
				/**
				 * En este punto solo puede venir errado el 5202 si no es asi puede ser una modificacion y el dato ser diferente de 0, actualizamos.
				 */
				if(0 == solicitud.getIndicadorCarDeudasDistintasVivienda().compareTo(BigDecimal.ONE)){
					solicitud.setIndicadorCarDeudasDistintasVivienda(BigDecimal.ZERO);
					//solicitud.update();
				}
			}
		}
		
		// Generar el contexto de salida.
		// Tras realizar el alta devolvemos el destino principal o el destino que 
		// provoca el error de validación.
		final IContexto[] contextoSalidaDestino = ContextosDestinosPrestamo.rellenarDatosContexto(destino, codigoError);
		
		if(null != contextoSalidaDestino){
			lstContextosSalida.add(contextoSalidaDestino[0]);
		}
		
		IContexto[] contextoSalida = lstContextosSalida.toArray(new IContexto[lstContextosSalida.size()]);
		 
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("Se han añadido/modificado correctamente los destinos de un prestamo");
		}
		
		if(LOGGER.isDebugEnabled())
		{
			LOGGER.debug("FIN SNANPM160: añadidir/modificar los destinos" +
					"Tiempo total: " + (System.currentTimeMillis() - lInicio) + "ms");
		}
		
		return contextoSalida;		
	}	
}
