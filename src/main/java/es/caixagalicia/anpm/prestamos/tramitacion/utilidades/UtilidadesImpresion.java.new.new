package es.caixagalicia.anpm.prestamos.tramitacion.utilidades;

import java.math.BigDecimal;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import org.apache.commons.lang.StringUtils;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.campanhas.CampanhaC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.campanhas.CampanhaEng;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.parametro.ParametroC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.parametro.ParametroEng;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionClausulaDocumentos;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionParametro;
import es.caixagalicia.anpm.prestamos.comun.LogModificacionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.comisiones.ComisionC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.cuentas.DatosCuentasC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.gastosadic.GastosAdicionalesC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.gastosadic.GastosAdicionalesEng;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.gastosadic.GastosAdicionalesKey;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionCapitalC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionesInteresC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudEng;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.tae.AplicaTaeC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionHistoricoImpresion;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionPreformalizacion;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionTae;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoDatosSOW;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoDocumentoInternoMinutar;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoErrorImpresionFIPER;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoImpresionFiper_OVHipotecarios;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.fachada.contextos.ContextoImpresionFormalizacion;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Enumerados.Met_impresion_doc;
import es.caixagalicia.anpm.prestamos.tramitacionmultimedio.aplicacion.AbstractSolicitudMultimedio;
import es.caixagalicia.ifrt.contextos.ContextoFactory;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.IRegistro;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.fechas.DateHelper;
import es.caixagalicia.ifrt.impresion.ConfiguracionImpresion;
import es.caixagalicia.ifrt.impresion.gestorImpresion.Documento;
import es.caixagalicia.ifrt.impresion.gestorImpresion.RespuestaImpresion;
import es.caixagalicia.ifrt.impresion.gestorImpresion.TipoImpresion;
import es.caixagalicia.ifrt.impresion.gestorImpresion.parametros.Parametros;
import es.caixagalicia.ifrt.log.LogHelper;
import es.caixagalicia.ifrt.mainframe.ctgfacade.CtgFacade;
import es.caixagalicia.ifrt.parametros.Configuracion;
import es.caixagalicia.ifrt.sow.SOW;
import es.caixagalicia.ifrt.util.Helper;
import es.caixagalicia.ifrt.mensajes.Mensaje;

public class UtilidadesImpresion {

    // Campo especialidad
    private static final String CMPO_CTXTO_SOL_ESPECIALIDAD = "ANPMN050120";

    // Parámetros de configuración ANPMCFG_FICHEROS_RUTA_SALIDA, para la ruta de salida
    // de los documentos pre-contractuales y contractuales: FIPER, OV, OV Hipotecaria,
    // minuta interna,...
    private static final String CTE_RUTA_SALIDA_FICHEROS_APLICACION = "ANPM";

    private static final String CTE_RUTA_SALIDA_FICHEROS_GRUPO_CONF = "FICHEROS";

    private static final String CTE_RUTA_SALIDA_FICHEROS_PARAM_CONF = "RUTA_SALIDA";

    // Campos de entrada
    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_OFICINA_SOLICITUD = "OFICINA_SOLICITUD";

    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_NUMERO_SOLICITUD = "NUMERO_SOLICITUD";

    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_VERSION_SOLICITUD = "VERSION_SOLICITUD";

    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_NUC_EXPEDIENTE = "NUC_EXPEDIENTE";

    // private static final String NOMBRE_CAMPO_GUARDAR_IMPRESION = "GUARDAR_IMPRESION"; // OPCIONAL
    // private static final String NOMBRE_CAMPO_GUARDAR_COMO = "GUARDAR_COMO"; // OPCIONAL
    private static final String NOMBRE_CAMPO_PANTALLA_ORIGEN = "PANTALLA_ORIGEN";

    // Código de operacion del servicio que consulta el detalle de un producto
    private static final Integer ID_CODOP_DETALLE_PRODUCTO = Integer.valueOf(48);

    // Posiciones para el servicio de consulta del subproducto de una solicitud
    // OBLIGATORIO
    private static final int CTE_POSICION_TIRA_ID_PRODUCTO = 0;

    // OPCIONAL
    private static final int CTE_POSICION_TIRA_ID_SUBPRODUCTO = 1;

    // OBLIGATORIO
    private static final int CTE_POSICION_TIRA_COLECTIVO = 2;

    // OBLIGATORIO
    private static final int CTE_POSICION_TIRA_ID_VERSION_GENERAL = 3;

    // OPCIONAL
    private static final int CTE_POSICION_TIRA_COD_COLECTIVO = 9;

    // Codigo de operacion del servicio de consulta cuentas
    private static final Integer ID_COOP_CONS_CUENTAS_SOL = Integer.valueOf(175);

    // Codigo de operacion del servicio que consulta el cuadro de amortizacion
    private static final Integer ID_CODOP_CONSULTA_AMORTIZACION = Integer.valueOf(266);

    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_DIGITO_SOLICITUD = "DIGITO_SOLICITUD";

    private static final String NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN = "SERVICIO_ORIGEN";

    private static final String VALOR_CAMPO_SRV_PANTALLA_PREFORMA = "0";

    // 2013-07-09 Inclusión impresión Fiper y OV para Hipotecarios - G000895
    private static final String VALOR_CAMPO_SRV_PANTALLA_FIPER_OV = "3";

    private static final String VALOR_CAMPO_SRV_PANTALLA_OV_HIPOTECARIOS = "4";

    // Cuenta contable de MEFC
    private static final Integer ID_CUENTA_MEFC = Integer.valueOf(565);

    // Codigo de operacion del servicio de consulta de los titulares de un expediente de una solicitud
    private static final Integer ID_CODOP_CONSULTA_TITULARES = Integer.valueOf(0);

    // Campos para el servicio de consulta de titulares del expediente
    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_APLICACION = "APLICACION";

    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_CODOPER = "CODOPER";

    // OBLIGATORIO
    private static final String NOMBRE_CAMPO_NUC = "NUC";

    // Nombre del contexto de datos solicitud
    private static final String ID_CTXTO_DATOS_SOLICITUD = "ANPMN050";

    private static final String CAMPO_CTXTO_SOL_OFICINA = "ANPMN050010";

    private static final String CAMPO_CTXTO_SOL_NUMERO = "ANPMN050020";

    private static final String CAMPO_CTXTO_SOL_VERSION = "ANPMN050030";

    private static final String CAMPO_CTXTO_SOL_NUC = "ANPMN050040";

    private static final String CMPO_CTXTO_SOL_PLAZO = "ANPMN050710";

    private static final String CAMPO_CTXTO_SOL_DIGITO = "ANPMN050070";

    private static final String CAMPO_CTXTO_SOL_IDPRODUCTO = "ANPMN050080";

    private static final String CAMPO_CTXTO_SOL_SUBPRODUCTO = "ANPMN050090";

    private static final String CAMPO_CTXTO_SOL_COLECTIVO = "ANPMN050110";

    private static final String CAMPO_CTXTO_SOL_ESPECIALIDAD = "ANPMN050120";

    private static final String CAMPO_CTXTO_SOL_VERSION_GENERAL = "ANPMN050100";

    // private static final String CAMPO_CTXTO_SOL_TIPO_EXP = 			"ANPMN050270";
    // private static final String CAMPO_CTXTO_SOL_IMP_SOLIC = 		"ANPMN050580";
    private static final String CAMPO_CTXTO_SOL_DIV_IMP_SOL = "ANPMN050590";

    private static final String CAMPO_CTXTO_SOL_IMP_TOTAL = "ANPMN050630";

    // private static final String CAMPO_CTXTO_ESTADO_SOLICITUD =      "ANPMN050520";
    // private static final String CAMPO_CTXTO_OFICINA_CONTABLE = 		"ANPMN050170";
    private static final String CTE_DAT_SOL_FECH_IMPR_FIPPER = "ANPMN050988";

    // 20150925 Se añade campo Indicador modo alta.
    // private static final String CAMPO_CTXTO_SOL_IND_MODO_ALTA = 	"ANPMN050887";
    private static final String CTE_DAT_SOL_ID_TARIFA = "ANPMN050886";

    private static final String CAMPO_CTXTO_SOL_UNIDAD_PLAZO = "ANPMN050730";

    private static final String CAMPO_CTXTO_SOL_TIPO_CALCULO = "ANPMN050889";

    private static final String CAMPO_CTXTO_SOL_IND_CAPITAL_NEGATIVO = "ANPMN050891";

    private static final String CAMPO_CTXTO_SOL_COD_COLECTIVO = "ANPMN050893";

    private static final String CTE_CONTINENTE = "ANPMN050924";

    private static final String CTE_CONTENIDO = "ANPMN050934";

    // Calcular corretaje
    private static final String CMPO_CTXTO_SOL_CORRETAJE = "ANPMN050998";

    // Campos del contexto de comision a verificar
    private static final String ID_CTXTO_COMISION = "ANPMN005";

    private static final String CMPO_CTXTO_COM_TIPO = "ANPMN005060";

    private static final String CMPO_CTXTO_COM_PORCENTAJE = "ANPMN005080";

    // Codigos de error del servicio
    private static final int ERROR_VALIDACION_COMISIONES = Integer.valueOf(10794);

    // Error. Fecha concesion
    private static final Integer CTE_MSG_ERROR_FECHA_CONCESION = Integer.valueOf(10808);

    private static final String ID_DOCUMENTO_IMPRESION = "PMOSST";

    // private static final String ID_CTX_GASTOS_ADIC = 					"CPSIN001";
    private static final String ID_CTX_GASTOS_ADIC_ID_CONCEPTO = "CPSIN001010";

    private static final String ID_CTX_GASTOS_ADIC_DESCR_CONCEPTO = "CPSIN001020";

    // private static final String ID_CTX_GASTOS_ADIC_IND_GASTO_COMISION = "CPSIN001030";
    // private static final String ID_CTX_GASTOS_ADIC_IMPORTE_POR_DEFECTO = "CPSIN001040";
    private static final String ID_CTX_GASTOS_ADIC_PORCENTAJE1 = "CPSIN001050";

    // private static final String ID_CTX_GASTOS_ADIC_PORCENTAJE2 = 		"CPSIN001060";
    // private static final String ID_CTX_GASTOS_ADIC_FIJO_CALC = 			"CPSIN001070";
    private static final String ID_CTX_GASTOS_ADIC_FACTOR_ACT = "CPSIN001080";

    private static final String ID_CTX_GASTOS_ADIC_NUM_PERIODOS = "CPSIN001090";

    private static final String ID_CTX_GASTOS_ADIC_IMPORTE_CALC = "CPSIN001100";

    // private static final String ID_CTX_GASTOS_ADIC_APLICA_TAE =         "CPSIN001110";
    private static final String ID_CTX_GASTOS_ADIC_CONTINENTE = "CPSIN001130";

    private static final String ID_CTX_GASTOS_ADIC_CONTENIDO = "CPSIN001140";

    private static final Integer CTE_SN_CC_GASTOS_ADIC = Integer.valueOf(734);

    private static final Integer CTE_SN_CO_GASTOS_ADIC = Integer.valueOf(1);

    // private static final String ID_CTX_DATOS_SOL_TIPO_EXPEDIENTE = "ANPMN050270";
    // 20150204 Campos necesarios para invocar el servicio de EEXP que nos indica si un expediente cumple el compromiso.
    // EEXP
    private static final Integer CTE_SN_COMPROMISO_CC = Integer.valueOf(502);

    private static final Integer CTE_SN_COMPROMISO_CO = Integer.valueOf(998);

    private static final String CTE_SN_COMPROMISO_ENT_OPER = "Operacion";

    private static final String CTE_SN_COMPROMISO_ENT_NUC = "Nuc";

    private static final String CTE_SN_COMPROMISO_SAL_IND_EXP_COMPR = "EEXPN205010";

    private static final String CTE_SN_COMPROMISO_SAL_IND_CUMPLE_COMPR = "EEXPN205020";

    // public static final String COD_DOCUMENTO_GD_OFERTA_VINCULANTE = "15035";
    // public static final String COD_DOCUMENTO_GD_DOC_INTERNO_MINUTA = "06012";
    // public static final String COD_DOCUMENTO_GD_FORMALIZACION = "06026";
    // public static final String COD_DOCUMENTO_GD_INFO_PREVIA = "6014";
    // public static final String COD_DOCUMENTO_GD_POLIZA= "15060";
    // public static final String COD_DOCUMENTO_GD_DOC_FIPER = "6015";
    private static final LogHelper LOGGER = LogHelper.getLog(UtilidadesImpresion.class);

    // TIPO DE IMPRESION
    public static final int INFO_PREVIA = 1;

    public static final int POLIZA = 2;

    public static final int OFERTA_VINCULANTE = 3;

    // 2013-07-09 Inclusión impresión Fiper y OV para Hipotecarios - G000895
    public static final int FIPER = 4;

    public static final int DOC_INTERNO_MINUTA = 5;

    public static final int OFERTA_VINCULANTE_HIPOTECARIOS = 6;

    public static final int RECIBO_FORMALIZACION = 7;

    public static final int CONTRATO_CREDIVENTAS = 8;

    public static final int INFORMACION_NORMALIZADA_EUROPEA = 9;

    public static final int TABLA_PAGOS = 10;

    public static final int OV_MOVIL = 11;

    // Opcion imprimir OV Hipotecarios
    private static final String IMPRIMIR_OV = "1";

    // Opcion imprimir + generar FIPER
    private static final String IMPRIMIR_GENERAR_FIPER = "0";

    // private static final String GENERAR_FIPER ="1";
    private static final boolean esEntornoAbanca = true;

    // 2016-06-06 - Contexto condiciones interes
    private static final String ID_CTXTO_CONDICIONES_INTERES = "ANPMN052";

    private static final String ID_CTXTO_CONDICIONES_INTERES_ORDEN = "ANPMN052040";

    private static final String ID_CTXTO_CONDICIONES_TIPO_CONDICION = "ANPMN052050";

    private static final String ID_CTXTO_CONDICIONES_INTERES_PLAZO = "ANPMN052110";

    private static final String ID_CTXTO_CONDICIONES_INTERES_INTERES = "ANPMN052130";

    private static final String ID_CTXTO_CONDICIONES_INTERES_DIF_NO_BONIFICADO = "ANPMN052270";

    private final String ID_CTX_PERSONAL = "ANPMN100";

    private final String ID_CTX_DOC_INTERNO = "ANPMN101";

    private final String ID_CTX_PROG_AMORTIZACION = "ANPMN075";

    private final String ID_CTX_FIPER = "ANPMN103";

    private final String ID_PROP_TAE_PERSONAL = "ANPMN100020";

    private final String ID_PROP_TAE_HIPOTECARIOS = "ANPMN101610";

    private final String ID_PROP_TAE_FIPER = "ANPMN103190";

    private final String ID_CTX_GASTOS_ESTUDIO = "ANPMN103210";

    private final String ID_CTX_COMISION_APERTURA = "ANPMN103220";

    private BigDecimal oficina = null;

    private BigDecimal numero = null;

    private BigDecimal version = null;

    private BigDecimal nuc = null;

    private String guardarImpresion = null;

    private String guardarComo = null;

    private String pantallaOrigen = null;

    private String indSoloGenerar = null;

    private String regenerarVersion = null;

    private String tipoExpediente = null;

    private String descripcion = null;

    private String codigoDocumento = StringUtils.EMPTY;

    private String id_doc = StringUtils.EMPTY;

    private String tae = StringUtils.EMPTY;

    private boolean cumpleCompromiso = false;

    private boolean documentoGenerado = false;

    private boolean exito = true;

    private boolean fiperImpresa = false;

    private boolean noImprimir = false;

    private boolean esPreconcedido = false;

    private Integer modelo = null;

    private int tipoImpresion = 0;

    private ConfiguracionImpresion configuracionImpresion = null;

    private es.caixagalicia.ifrt.impresion.Configuracion configuracion = null;

    private RespuestaImpresion respuesta = null;

    private Parametros parametros = new Parametros();

    private List<IContexto> contextosImpresion = new ArrayList<IContexto>(0);

    private IContexto[] contextosSolicitud = null;

    private IContexto contextoDatosSolicitud = null;

    private IContexto[] contextosGastosAdicionales = null;

    // private IContexto[] contextosSOW = null;
    private IContexto[] contextosErrorFiper = null;

    private IContexto[] datosExpediente = null;

    private IContexto[] contextosIntereses = null;

    private IContexto[] contextosAmortizacion = null;

    private IContexto contextoAmortizacion = null;

    private IContexto[] ctxsImpresion = null;

    private IContexto contextoDocumento = null;

    private IContexto contextoFiper = null;

    private ArrayList<IContexto> contextosDatosSOW = new ArrayList<IContexto>();

    // IContexto[] ctxtoDatosSOW = null;
    private DatosSolicitudC solicitud = null;

    private GestionDatosSolicitud gds = new GestionDatosSolicitud();

    // 20140616 Cambio provisional fecha última entrega AN37TB01
    private Date fechaUltimaEntrega = null;

    private BigDecimal ultimaCuota = null;

    // 20150209 La fecha primera entrega tambien se va a recuperar de la matriz
    // de pagos antes de totalizar por años el cuadro de amortización.
    private Date fechaPrimeraEntrega = null;

    private Date fechaPrimerPago = null;

    /**
     * Método que contiene la lógica de los servicios de impresión.
     *
     * @param contexto
     * @param imprimirDoc
     * @return
     */
    public IContexto[] imprimir(IContextoEjecucion contexto, ImprimirDocumentosVO imprimirDoc) {
        recogeDatos(imprimirDoc);
        comprobacionesPrevias();
        comprobacionesPreconcedido();
        cargaContextos(tipoImpresion);
        parametros.setNucCabecera(nuc.toString());
        parametros.getParametrosImpresion().setNumeroCopias("2");
        parametros.getParametrosImpresion().setTextoPieOriginal("CLIENTE");
        parametros.getParametrosImpresion().setTextoPieCopia_1(new Mensaje(ServicioNegocio.getContexto(), OFICINA_1546109685).toString());
        configuracionImpresion.setFormato(Constantes.CTE_FORMATO_PDF);
        switch(tipoImpresion) {
            case INFO_PREVIA:
                preparaModeloDescripcionYContexto("IP", ContextoImpresionFormalizacion.PASO_DOC_IMPRESION_PREVIA);
                LOGGER.info("FIN Creando contexto de impresión");
                parametrosImpresion(true, "2");
                // Actualizamos la fecha de impresion de Inf. Previa
                actualizarFechaImpresion(solicitud, INFO_PREVIA, contextoAmortizacion);
                /*20151005 Actualizamos tambien la TAE cuando generamos una Info Previa*/
                contextoDocumento = UtilidadesTramitacion.getContexto(ctxsImpresion, ID_CTX_PERSONAL);
                // Eliminamos el % al final de la cadena que contiene el valor TAE
                tae = contextoDocumento.getString(ID_PROP_TAE_PERSONAL).substring(0, contextoDocumento.getString(ID_PROP_TAE_PERSONAL).length() - 1);
                exito = actualizarTAE(solicitud, UtilidadesTramitacion.stringToBigDecimal(tae, Locale.getDefault()), UtilidadesTramitacion.getContexto(contextosAmortizacion, ID_CTX_PROG_AMORTIZACION), fechaUltimaEntrega);
                // 2018-02-08 - Si es preconcedido de ASF: no imprimir, solo generar
                if (UtilidadesComun.esPreconcedidoASF(solicitud.getTipoExpediente())) {
                    indSoloGenerar = "1";
                }
                if (exito) {
                    if (!UtilidadesTramitacion.isBlankOrNull(guardarImpresion) && guardarImpresion.equalsIgnoreCase(Constantes.CTE_LETRA_S)) {
                        if (UtilidadesTramitacion.isBlankOrNull(guardarComo)) {
                            configuracionImpresion.setFormato(Constantes.CTE_FORMATO_PDF);
                        } else {
                            configuracionImpresion.setFormato(Constantes.CTE_FORMATO_PDF);
                        }
                    } else {
                        configuracion.setImpresion(configuracionImpresion);
                        if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                            // id_doc = ID_DOCUMENTO_IMPRESION + Constantes.CTE_BID_ID_DOC_IMP_PREVIA;
                            UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                            ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                        } else {
                            id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                        }
                        // tiene que ser cuando sea igual a 0
                        if ("0".equals(indSoloGenerar)) {
                            if (UtilidadesTramitacion.comprobarControlOperatoria(nuc, new BigDecimal(150007), true)) {
                                respuesta = Documento.imprimir(id_doc, ctxsImpresion, parametros);
                                documentoGenerado = true;
                                respuesta = adjuntarDocumentoGestorDocumentacion2(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud, respuesta, documentoGenerado, esPreconcedido);
                            } else {
                                noImprimir = true;
                            }
                        }
                    }
                }
                // 20150925 Tambien vamos a generar si está indSoloGenerar activado, esto lo hacemos porque en este caso no se imprima.
                if ((null != respuesta && Constantes.CTE_STRING_CERO.equals(respuesta.getCodigoError())) || ("1".equals(indSoloGenerar))) {
                    if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                        exito = false;
                    } else {
                        /* ESTA LLAMADA INCLUYE EL GUARDADO DEL PDF EN EL DIRECTORIO. */
                        respuesta = adjuntarDocumentoGestorDocumentacion2(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud, respuesta, documentoGenerado, esPreconcedido);
                    }
                } else if (noImprimir) {
                    if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                        exito = false;
                    } else {
                        respuesta = adjuntarDocumentoGestorDocumentacion2(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud, respuesta, documentoGenerado, esPreconcedido);
                    }
                }
                if (null != respuesta && null != respuesta.getvaloresSOW()) {
                    contextosDatosSOW.add(ContextoDatosSOW.rellenarContextoDatosSOW(respuesta.getvaloresSOW()));
                }
                break;
            case INFORMACION_NORMALIZADA_EUROPEA:
                preparaModeloDescripcionYContexto("IP", ContextoImpresionFormalizacion.PASO_DOC_INFORMACION_NORMALIZADA_EUROPEA);
                LOGGER.info("FIN Creando contexto de impresión");
                parametrosImpresion(true, "1");
                parametros.getParametrosImpresion().setTextoPieOriginal("OFICINA");
                // Actualizamos la fecha de impresion de Inf. Previa
                exito = actualizarFechaImpresion(solicitud, INFORMACION_NORMALIZADA_EUROPEA, contextoAmortizacion);
                if (exito) {
                    if (!UtilidadesTramitacion.isBlankOrNull(guardarImpresion) && guardarImpresion.equalsIgnoreCase(Constantes.CTE_LETRA_S)) {
                        if (UtilidadesTramitacion.isBlankOrNull(guardarComo)) {
                            configuracionImpresion.setFormato(Constantes.CTE_FORMATO_PDF);
                        } else {
                            configuracionImpresion.setFormato(Constantes.CTE_FORMATO_PDF);
                        }
                    } else {
                        configuracion.setImpresion(configuracionImpresion);
                        if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                            UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                            ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                        } else {
                            id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                        }
                    }
                }
                // 2018-02-08 - Si es preconcedido de ASF: no imprimir, solo generar
                if (UtilidadesComun.esPreconcedidoASF(solicitud.getTipoExpediente())) {
                    indSoloGenerar = "1";
                }
                if ("0".equals(indSoloGenerar)) {
                    respuesta = Documento.imprimir(id_doc, ctxsImpresion, parametros);
                    // documentoGenerado = true;
                    // respuesta = adjuntarDocumentoGestorDocumentacion2(nuc, descripcion, id_doc,codigoDocumento,ctxsImpresion, tipoImpresion, contextoDatosSolicitud, respuesta, documentoGenerado);
                    // respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc,codigoDocumento,ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                    guardarDocumentoEnServidor(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                    contextosDatosSOW.add(ContextoDatosSOW.rellenarContextoDatosSOW(respuesta.getvaloresSOW()));
                }
                if (exito) {
                    if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                        exito = false;
                    } else if ("1".equals(indSoloGenerar)) {
                        /* ESTA LLAMADA INCLUYE EL GUARDADO DEL PDF EN EL DIRECTORIO. */
                        // respuesta = adjuntarDocumentoGestorDocumentacion2(nuc, descripcion, id_doc,codigoDocumento,ctxsImpresion, tipoImpresion, contextoDatosSolicitud, respuesta, documentoGenerado);
                        respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                        contextosDatosSOW.add(ContextoDatosSOW.rellenarContextoDatosSOW(respuesta.getvaloresSOW()));
                    }
                    if ("2".equals(indSoloGenerar)) {
                        guardarDocumentoEnServidor(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                    }
                }
                break;
            case CONTRATO_CREDIVENTAS:
                modelo = GestionClausulaDocumentos.obtenerModeloDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "PO", solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                descripcion = GestionClausulaDocumentos.obtenerDescripcionDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "PO", solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                ctxsImpresion = ContextoImpresionFormalizacion.rellenarDatosContexto(contextosImpresion.toArray(new IContexto[0]), ContextoImpresionFormalizacion.PASO_DOC_CONTRATO_CREDIVENTAS, modelo);
                ctxsImpresion = ContextoImpresionFormalizacion.rellenarContratoCrediventas(imprimirDoc, ctxsImpresion);
                // Rellenar los campos de Aplazos en caso de llamada API/REST
                parametros.getParametrosImpresion().setNumeroCopias("2");
                parametros.getParametrosImpresion().setTextoPieOriginal(" ");
                if (solicitud.getEspecialidad().equals(Constantes.CTE_STR_D)) {
                    if (Constantes.CTE_LETRA_S.equals(contextoDatosSolicitud.getString(CMPO_CTXTO_SOL_CORRETAJE))) {
                        // Parámetros impresión
                        parametros.getParametrosImpresion().setNumeroCopias("2");
                        parametros.getParametrosImpresion().setTextoPieCopia_1("OFICINA");
                        parametros.getParametrosImpresion().setTextoPieOriginal("CLIENTE");
                    } else {
                        parametros.getParametrosImpresion().setNumeroCopias("1");
                        parametros.getParametrosImpresion().setTextoPieOriginal(" ");
                    }
                }
                if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                    UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                    ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                } else {
                    id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                }
                if ("0".equals(indSoloGenerar)) {
                    codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                    Documento.imprimir(id_doc, ctxsImpresion, parametros);
                    respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                }
                // Actualizamos la TAE
                // Obtenemos el valor de la TAE del contexto de impresion del documento
                contextoDocumento = UtilidadesTramitacion.getContexto(ctxsImpresion, ID_CTX_PERSONAL);
                // Eliminamos el % al final de la cadena que contiene el valor TAE
                tae = contextoDocumento.getString(ID_PROP_TAE_PERSONAL).substring(0, contextoDocumento.getString(ID_PROP_TAE_PERSONAL).length() - 1);
                exito = actualizarTAE(solicitud, UtilidadesTramitacion.stringToBigDecimal(tae, Locale.getDefault()), UtilidadesTramitacion.getContexto(contextosAmortizacion, ID_CTX_PROG_AMORTIZACION), fechaUltimaEntrega);
                if (exito) {
                    // Actualizamos la fecha de impresion de la Poliza
                    /*20150226 La fecha de impresión de la póliza se actualiza con el campo que nos viene de la llamada al servicio de cuadro
					 * amortización: ANPM_266 -> ANPMR203 -> .. (ANPMN075540)*/
                    exito = actualizarFechaImpresion(solicitud, POLIZA, contextoAmortizacion);
                }
                if (exito) {
                    codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                    if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                        exito = false;
                    } else if ("1".equals(indSoloGenerar)) {
                        // ESTA LAMADA INCLUYE GUARDADO DE PDF A DIRECTORIO.
                        respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                        contextosDatosSOW.add(ContextoDatosSOW.rellenarContextoDatosSOW(respuesta.getvaloresSOW()));
                    }
                    if ("2".equals(indSoloGenerar)) {
                        guardarDocumentoEnServidor(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                    }
                }
                break;
            case POLIZA:
                modelo = GestionClausulaDocumentos.obtenerModeloDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "PO", solicitud.getTipoExpediente().intValue(), (esPreconcedido ? 1 : solicitud.getIdColectivo().intValue()));
                descripcion = GestionClausulaDocumentos.obtenerDescripcionDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "PO", solicitud.getTipoExpediente().intValue(), (esPreconcedido ? 1 : solicitud.getIdColectivo().intValue()));
                ctxsImpresion = ContextoImpresionFormalizacion.rellenarDatosContexto(contextosImpresion.toArray(new IContexto[0]), ContextoImpresionFormalizacion.PASO_DOC_POLIZA_PRESTAMO, modelo);
                /*codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
				parametros.getParametrosGestorDocumental().setCodigoGestorDocumental(codigoDocumento); // Tipo de documento (obligatorio)
				parametros.getParametrosGestorDocumental().setCodigoCliente(Constantes.CTE_CERO.toString()); // Código cliente (obligatorio)
				parametros.getParametrosGestorDocumental().setDescripcionGestoDocumental(descripcion); // Opcional
				
				// Array de NUCs, obligatorio al menos uno
				parametros.getParametrosGestorDocumental().setNuc(new String[] {nuc.toString()}); 
				parametros.getParametrosGestorDocumental().setSobreescribir(false);
				parametros.getParametrosGestorDocumental().habilitar();
		 
				configuracionImpresion.setCgsi4440("2"); //Número de Copias
				parametros.setTipoImpresion(TipoImpresion.IMPRIMIR);*/
                parametros.getParametrosImpresion().setNumeroCopias("2");
                parametros.getParametrosImpresion().setTextoPieOriginal(" ");
                if (contextoDatosSolicitud.getString(CMPO_CTXTO_SOL_ESPECIALIDAD).equals(Constantes.CTE_STR_D)) {
                    if (Constantes.CTE_LETRA_S.equals(contextoDatosSolicitud.getString(CMPO_CTXTO_SOL_CORRETAJE))) {
                        // Parámetros impresión
                        parametros.getParametrosImpresion().setNumeroCopias("2");
                        parametros.getParametrosImpresion().setTextoPieCopia_1("OFICINA");
                        parametros.getParametrosImpresion().setTextoPieOriginal(new Mensaje(ServicioNegocio.getContexto(), CLIENTE_860587514).toString());
                    } else {
                        parametros.getParametrosImpresion().setNumeroCopias("1");
                        parametros.getParametrosImpresion().setTextoPieOriginal(" ");
                    }
                }
                if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                    // id_doc = ID_DOCUMENTO_IMPRESION + Constantes.CTE_BID_ID_DOC_IMP_POLIZA;
                    UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                    ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                } else {
                    id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                }
                // Actualizamos la TAE
                // Obtenemos el valor de la TAE del contexto de impresion del documento
                contextoDocumento = UtilidadesTramitacion.getContexto(ctxsImpresion, ID_CTX_PERSONAL);
                // Eliminamos el % al final de la cadena que contiene el valor TAE
                tae = contextoDocumento.getString(ID_PROP_TAE_PERSONAL).substring(0, contextoDocumento.getString(ID_PROP_TAE_PERSONAL).length() - 1);
                exito = actualizarTAE(solicitud, UtilidadesTramitacion.stringToBigDecimal(tae, Locale.getDefault()), UtilidadesTramitacion.getContexto(contextosAmortizacion, ID_CTX_PROG_AMORTIZACION), fechaUltimaEntrega);
                if (exito) {
                    // Actualizamos la fecha de impresion de la Poliza
                    // 20150226 La fecha de impresión de la póliza se actualiza con el campo que nos viene de la
                    // llamada al servicio de cuadro de amortización: ANPM_266 -> ANPMR203 -> .. (ANPMN075540)
                    exito = actualizarFechaImpresion(solicitud, POLIZA, contextoAmortizacion);
                }
                // Solo se imprime si IND_SOLO_GENERAR <> 1 y prescriptor valodo para el subproducto
                // 2016-02-15 - Solo se imprime si el prescriptor es valido para el subproducto
                // boolean prescriptorValido = UtilidadesTramitacion.esPrescriptorValido(
                // solicitud.getDatosSolicitudKey().getNucExpediente(),
                // new Integer(solicitud.getProducto().intValue()),
                // new Integer(solicitud.getSubproducto().intValue()),
                // solicitud.getTipoPrescriptor(),
                // solicitud.getIdTarifa());
                // 2016-04-01 - Se sustituye la comprobacion anterior de prescriptor valido por una llamada
                // al servicio de comprobaciones (ANPM_454)
                GestionDatosSolicitud.ctxComprobacionesTramitacion(solicitud.getDatosSolicitudKey().getNucExpediente(), ConstantesComun.CTE_BID_8, null);
                // 2018-02-08 - Si es preconcedido de ASF: no imprimir, solo generar
                if (UtilidadesComun.esPreconcedidoASF(solicitud.getTipoExpediente())) {
                    indSoloGenerar = "1";
                }
                if (exito && (("0".equals(indSoloGenerar)))) {
                    if (UtilidadesTramitacion.comprobarControlOperatoria(nuc, new BigDecimal(150007), true)) {
                        respuesta = Documento.imprimir(id_doc, ctxsImpresion, parametros);
                    } else {
                        noImprimir = true;
                    }
                }
                // 20150925 Tambien vamos a generar si está indSoloGenerar activado, esto lo hacemos porque en este caso no se imprima.
                if ((null != respuesta && Constantes.CTE_STRING_CERO.equals(respuesta.getCodigoError())) || ("1".equals(indSoloGenerar))) {
                    codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                    if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                        exito = false;
                    } else {
                        // adjuntar documentos a gestión documental, por ahora comentado
                        // ESTA LAMADA INCLUYE GUARDADO DE PDF A DIRECTORIO.
                        respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                        contextosDatosSOW.add(ContextoDatosSOW.rellenarContextoDatosSOW(respuesta.getvaloresSOW()));
                    }
                } else // Para el valor 2 únicamente guarda en la ruta del servidor
                if ("2".equals(indSoloGenerar)) {
                    codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                    respuesta = guardarDocumentoEnServidor(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                } else {
                    if (noImprimir) {
                        codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                        if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                            exito = false;
                        } else {
                            // adjuntar documentos a gestión documental, por ahora comentado
                            // ESTA LAMADA INCLUYE GUARDADO DE PDF A DIRECTORIO.
                            respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                            contextosDatosSOW.add(ContextoDatosSOW.rellenarContextoDatosSOW(respuesta.getvaloresSOW()));
                        }
                    }
                }
                break;
            case OFERTA_VINCULANTE:
                // Comprobar que no sea ASF
                if (UtilidadesComun.esASF(solicitud.getEntidad())) {
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_OV_ES_ASF.intValue(), null, null, new String[] { Constantes.CTE_STRING_BLANK });
                } else // Comprobar que no sea novacion o ampliacion
                if (UtilidadesComun.esExpedienteNovacion(solicitud.getTipoExpediente()) || UtilidadesComun.esExpedienteAmpliacion(solicitud.getTipoExpediente())) {
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_OV_ES_NOV_AMPL.intValue(), null, null, new String[] { Constantes.CTE_STRING_BLANK });
                }
                // Se consulta como PO si es una solicitud temporal y VO en caso contrario
                String tipoDocumento = tipoDocumento(imprimirDoc.isSolicitudTemporal());
                modelo = GestionClausulaDocumentos.obtenerModeloDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), tipoDocumento, solicitud.getTipoExpediente().intValue(), (esPreconcedido ? 1 : solicitud.getIdColectivo().intValue()));
                descripcion = GestionClausulaDocumentos.obtenerDescripcionDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), tipoDocumento, solicitud.getTipoExpediente().intValue(), (esPreconcedido ? 1 : solicitud.getIdColectivo().intValue()));
                ctxsImpresion = ContextoImpresionFormalizacion.rellenarDatosContexto(contextosImpresion.toArray(new IContexto[0]), ContextoImpresionFormalizacion.PASO_DOC_OFERTA_VINCULANTE, modelo);
                // Si no se han guardado los datos de la OV para esta versión del expediente, se guardan.
                if (!GestionPreformalizacion.existeVersion(solicitud)) {
                    ContextoImpresionFormalizacion.guardarContextoOV(ctxsImpresion[0], solicitud);
                }
                if (esPreconcedido && imprimirDoc.isSolicitudTemporal()) {
                    tipoImpresion = OV_MOVIL;
                }
                codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                // Tipo de documento (obligatorio)
                parametros.getParametrosGestorDocumental().setCodigoGestorDocumental(codigoDocumento);
                // Código cliente (obligatorio)
                parametros.getParametrosGestorDocumental().setCodigoCliente(Constantes.CTE_CERO.toString());
                // Opcional
                parametros.getParametrosGestorDocumental().setDescripcionGestoDocumental(descripcion);
                // Array de NUCs, obligatorio al menos uno
                parametros.getParametrosGestorDocumental().setNuc(new String[] { nuc.toString() });
                parametros.getParametrosGestorDocumental().setSobreescribir(false);
                parametros.getParametrosGestorDocumental().habilitar();
                // Número de Copias
                configuracionImpresion.setCgsi4440("2");
                parametros.setTipoImpresion(TipoImpresion.IMPRIMIR);
                /**
                 * Actualizar la fecha en el campo AN251190
                 */
                exito = actualizarFechaImpresion(solicitud, OFERTA_VINCULANTE, contextoAmortizacion);
                if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                    // Soltar error de no asociado a ningun modelo de documento
                    // id_doc = ID_DOCUMENTO_IMPRESION + Constantes.CTE_BID_ID_DOC_IMP_VINCULANTE;
                    UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                    ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                } else {
                    id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                }
                if (!esPreconcedido) {
                    respuesta = Documento.imprimir(id_doc, ctxsImpresion, parametros);
                    documentoGenerado = true;
                } else {
                    documentoGenerado = false;
                }
                if (((null != respuesta) && Constantes.CTE_STRING_CERO.equals(respuesta.getCodigoError())) || (esPreconcedido)) {
                    if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                        exito = false;
                    } else {
                        // adjuntar documentos a gestión documental
                        // ESTA LAMADA INCLUYE GUARDADO DE PDF A DIRECTORIO.
                        respuesta = adjuntarDocumentoGestorDocumentacion2(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud, respuesta, documentoGenerado, esPreconcedido);
                    }
                }
                if (null != respuesta && null != respuesta.getvaloresSOW()) {
                    contextosDatosSOW.add(ContextoDatosSOW.rellenarContextoDatosSOW(respuesta.getvaloresSOW()));
                }
                break;
            // 2013-07-09 Inclusión impresión Fiper, Documento Interno para Minutar y OV para Hipotecarios - G000895
            case FIPER:
                if (fiperImpresa && esEntornoAbanca && ("N".equals(regenerarVersion) || StringUtils.isBlank(regenerarVersion)))
                    break;
                modelo = GestionClausulaDocumentos.obtenerModeloDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), Constantes.CTE_TIPO_DOCUMENTO_FIPER, solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                descripcion = GestionClausulaDocumentos.obtenerDescripcionDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), Constantes.CTE_TIPO_DOCUMENTO_FIPER, solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                ctxsImpresion = ContextoImpresionFiper_OVHipotecarios.rellenarDatosContexto(contextosImpresion.toArray(new IContexto[contextosImpresion.size()]), ContextoImpresionFiper_OVHipotecarios.PASO_DOC_FIPER, modelo);
                // en la tabla AN48TB01
                if (null != ctxsImpresion) {
                    contextoFiper = UtilidadesTramitacion.getContexto(ctxsImpresion, ID_CTX_FIPER);
                    String strComisionApertura = contextoFiper.getString(ID_CTX_COMISION_APERTURA);
                    String strComisionGastosEstudio = contextoFiper.getString(ID_CTX_GASTOS_ESTUDIO);
                    BigDecimal impComisionApertura = null;
                    BigDecimal impComisionGastosEstudio = null;
                    int resComisionApertura = strComisionApertura.indexOf("mín");
                    if (resComisionApertura != -1) {
                        int longitud = strComisionApertura.length();
                        strComisionApertura = strComisionApertura.substring(resComisionApertura + 4, longitud);
                    }
                    int resGastosEstudio = strComisionGastosEstudio.indexOf("mín");
                    if (resGastosEstudio != -1) {
                        int longitud = strComisionGastosEstudio.length();
                        strComisionGastosEstudio = strComisionGastosEstudio.substring(resGastosEstudio + 4, longitud);
                    }
                    impComisionApertura = UtilidadesTramitacion.stringToBigDecimal(strComisionApertura, Locale.getDefault());
                    impComisionGastosEstudio = UtilidadesTramitacion.stringToBigDecimal(strComisionGastosEstudio, Locale.getDefault());
                    GestionHistoricoImpresion.modificarComisiones(solicitud.getDatosSolicitudKey().getOficinaSolicitud(), solicitud.getDatosSolicitudKey().getNumSolicitud(), nuc, Constantes.CTE_TIPO_DOCUMENTO_FIPER, impComisionApertura, impComisionGastosEstudio);
                }
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.info("FIN Creando contexto de impresion");
                }
                // Numero de copias
                configuracionImpresion.setCgsi4440("2");
                configuracionImpresion.setCgsi4441(new Mensaje(ServicioNegocio.getContexto(), CLIENTE_860587514).toString());
                configuracionImpresion.setCgsi4442("OFICINA");
                /*codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
				parametros.getParametrosGestorDocumental().setCodigoGestorDocumental(codigoDocumento); // Tipo de documento (obligatorio)
				parametros.getParametrosGestorDocumental().setCodigoCliente(Constantes.CTE_CERO.toString()); // Código cliente (obligatorio)
				parametros.getParametrosGestorDocumental().setDescripcionGestoDocumental(descripcion); // Opcional
				
				// Array de NUCs, obligatorio al menos uno
				parametros.getParametrosGestorDocumental().setNuc(new String[] {nuc.toString()}); 
				parametros.getParametrosGestorDocumental().setSobreescribir(false);
				parametros.getParametrosGestorDocumental().habilitar();
		 
				parametros.setTipoImpresion(TipoImpresion.IMPRIMIR);*/
                configuracion.setImpresion(configuracionImpresion);
                if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                    UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                    ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                } else {
                    id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                }
                // Actualizamos la fecha de impresion de la FIPER
                exito = actualizarFechaImpresion(solicitud, FIPER, contextoAmortizacion);
                codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                if (exito && UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                    exito = false;
                } else {
                    // Adjuntar a gestion documental
                    // ESTA LAMADA INCLUYE GUARDADO DE PDF A DIRECTORIO.
                    respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                // respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc,codigoDocumento,ctxsImpresion);
                }
                contextoFiper = UtilidadesTramitacion.getContexto(ctxsImpresion, ID_CTX_FIPER);
                exito = actualizarTAE(solicitud, contextoFiper.getBigDecimal(ID_PROP_TAE_FIPER), UtilidadesTramitacion.getContexto(contextosAmortizacion, ID_CTX_PROG_AMORTIZACION), fechaUltimaEntrega);
                if (UtilidadesTramitacion.isBlankOrNull(pantallaOrigen) || pantallaOrigen.equals(IMPRIMIR_GENERAR_FIPER) && Constantes.CTE_STRING_CERO.equals(respuesta.getCodigoError())) {
                    // id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                    // exito = ImpresionHelper.imprimir(id_doc, strTipoImpresionFiper, ctxsImpresion, prop,configuracion);
                    respuesta = Documento.imprimir(id_doc, ctxsImpresion, parametros);
                }
                break;
            case DOC_INTERNO_MINUTA:
                modelo = GestionClausulaDocumentos.obtenerModeloDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "DI", solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                descripcion = GestionClausulaDocumentos.obtenerDescripcionDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "DI", solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                ctxsImpresion = ContextoDocumentoInternoMinutar.rellenarDatosContexto(contexto, contextosImpresion.toArray(new IContexto[0]), modelo);
                if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                    UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                    ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                } else {
                    id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                }
                // Actualizamos la TAE
                // Obtenemos el valor de la TAE del contexto de impresion del documento
                contextoDocumento = UtilidadesTramitacion.getContexto(ctxsImpresion, ID_CTX_DOC_INTERNO);
                exito = actualizarTAE(solicitud, UtilidadesTramitacion.stringToBigDecimal(contextoDocumento.getString(ID_PROP_TAE_HIPOTECARIOS), Locale.getDefault()), UtilidadesTramitacion.getContexto(contextosAmortizacion, ID_CTX_PROG_AMORTIZACION), fechaUltimaEntrega);
                codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                    exito = false;
                } else {
                    // adjuntar documentos a gestión documental
                    // ESTA LLAMADA INCLUYE GUARDADO DE PDF A DIRECTORIO.
                    respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                // respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc,codigoDocumento,ctxsImpresion);
                }
                // contextoDatosSolicitud);
                break;
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                // Comprobar que no sea novacion o ampliacion
                if (UtilidadesComun.esExpedienteNovacion(solicitud.getTipoExpediente()) || UtilidadesComun.esExpedienteAmpliacion(solicitud.getTipoExpediente())) {
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_OV_ES_NOV_AMPL.intValue(), null, null, new String[] { Constantes.CTE_STRING_BLANK });
                }
                modelo = GestionClausulaDocumentos.obtenerModeloDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "OV", solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                descripcion = GestionClausulaDocumentos.obtenerDescripcionDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), "OV", solicitud.getTipoExpediente().intValue(), solicitud.getIdColectivo().intValue());
                ctxsImpresion = ContextoImpresionFiper_OVHipotecarios.rellenarDatosContexto(contextosImpresion.toArray(new IContexto[contextosImpresion.size()]), ContextoImpresionFiper_OVHipotecarios.PASO_DOC_OV_HIPOTECARIOS, modelo);
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("FIN Creando contexto de impresion");
                }
                // Si no se han guardado los datos de la OV para esta versión del expediente, se guardan.
                if (!GestionPreformalizacion.existeVersion(solicitud)) {
                    ContextoImpresionFiper_OVHipotecarios.guardarContextoOVHipotecarios(ctxsImpresion[0], solicitud, contextosImpresion.toArray(new IContexto[contextosImpresion.size()]), fechaUltimaEntrega, ultimaCuota, /*20150209*/
                    fechaPrimeraEntrega, fechaPrimerPago);
                }
                // Numero de copias
                configuracionImpresion.setCgsi4440("1");
                configuracionImpresion.setCgsi4441("");
                configuracion.setImpresion(configuracionImpresion);
                if (UtilidadesTramitacion.isBlankOrNull(modelo)) {
                    // Soltar error de no asociado a ningun modelo de documento
                    // id_doc = ID_DOCUMENTO_IMPRESION + Constantes.CTE_BID_ID_DOC_IMP_VINCULANTE;
                    UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), solicitud);
                    ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION_MODELO_DOC.intValue(), null, null, null);
                } else {
                    id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                }
                // pantallaOrigen -> En OV Hipotecarios es el botón que se pulsa en la pantalla de Preformalizacion
                // Si se pulsa Imprimir (pantallaOrigen = 1) se imprime la OV y se guarda en Gestion Documental
                // Si se pulsa Aceptar (pantallaOrigen = 2) se guarda la OV en Gestion Documental
                /**
                 * Actualizar la fecha de la oferta vinculante campo AN251190
                 */
                exito = actualizarFechaImpresion(solicitud, OFERTA_VINCULANTE_HIPOTECARIOS, contextoAmortizacion);
                codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
                if (UtilidadesTramitacion.isBlankOrNull(codigoDocumento)) {
                    exito = false;
                } else {
                    // Adjuntar documentos a gestión documental
                    // ESTA LAMADA INCLUYE GUARDADO DE PDF A DIRECTORIO.
                    respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc, codigoDocumento, ctxsImpresion, tipoImpresion, contextoDatosSolicitud);
                // respuesta = adjuntarDocumentoGestorDocumentacion(nuc, descripcion, id_doc,codigoDocumento,ctxsImpresion);
                }
                contextoFiper = UtilidadesTramitacion.getContexto(ctxsImpresion, ID_CTX_FIPER);
                exito = actualizarTAE(solicitud, contextoFiper.getBigDecimal(ID_PROP_TAE_FIPER), UtilidadesTramitacion.getContexto(contextosAmortizacion, ID_CTX_PROG_AMORTIZACION), fechaUltimaEntrega);
                if (!UtilidadesTramitacion.isBlankOrNull(pantallaOrigen) && pantallaOrigen.equals(IMPRIMIR_OV) && Constantes.CTE_STRING_CERO.equals(respuesta.getCodigoError())) {
                    // Imprimir
                    // id_doc = ID_DOCUMENTO_IMPRESION + modelo;
                    // exito = ImpresionHelper.imprimir(id_doc, Constantes.CTE_IMPRIMIR_DOCUMENTO, ctxsImpresion, prop, configuracion);
                    respuesta = Documento.imprimir(id_doc, ctxsImpresion, parametros);
                }
                break;
            default:
                break;
        }
        if (null != respuesta && !Constantes.CTE_STRING_CERO.equals(respuesta.getCodigoError())) {
            UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION.intValue(), solicitud);
            ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION.intValue(), null, new String[] { respuesta.getDescripcionerror() + respuesta.getCodigoError() }, null);
        } else if (!exito) {
            UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_IMPRESION.intValue(), solicitud);
            ServicioNegocio.rollback(CodigosError.ERROR_IMPRESION.intValue(), null, null, null);
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("FIN UTILIDADES_IMPRESION: Imprimir");
        }
        IContexto[] contextoSalida = null;
        IContexto[] contextoSow = contextosDatosSOW.toArray(new IContexto[contextosDatosSOW.size()]);
        if (FIPER == tipoImpresion) {
            contextoSalida = new IContexto[contextosDatosSOW.size() + 1];
            for (int i = 0; i < contextosDatosSOW.size(); i++) {
                contextoSalida[i] = contextoSow[i];
            }
            contextoSalida[contextosDatosSOW.size()] = contextosErrorFiper[0];
        } else
            // Si no es FIPER no sale el contextosErrorFiper
            contextoSalida = contextoSow;
        return contextoSalida;
    }

    /**
     * Pequeño método que configura los parámetros de impresión para cada documento
     *
     * @param parametrosAdicionales
     * @param numeroCopias
     */
    private void parametrosImpresion(boolean parametrosAdicionales, String numeroCopias) {
        if (parametrosAdicionales) {
            codigoDocumento = obtenerCodigoDocumento(tipoImpresion);
            // Tipo de documento (obligatorio)
            parametros.getParametrosGestorDocumental().setCodigoGestorDocumental(codigoDocumento);
            // Código cliente (obligatorio)
            parametros.getParametrosGestorDocumental().setCodigoCliente(Constantes.CTE_CERO.toString());
            // Opcional
            parametros.getParametrosGestorDocumental().setDescripcionGestoDocumental(descripcion);
            // Array de NUCs, obligatorio al menos uno
            parametros.getParametrosGestorDocumental().setNuc(new String[] { nuc.toString() });
            parametros.getParametrosGestorDocumental().setSobreescribir(false);
            parametros.getParametrosGestorDocumental().habilitar();
            // Número de Copias
            configuracionImpresion.setCgsi4440(numeroCopias);
            parametros.setTipoImpresion(TipoImpresion.IMPRIMIR);
        }
        if (numeroCopias.equals("1")) {
            parametros.getParametrosImpresion().setTextoPieOriginal("CLIENTE");
        } else {
            parametros.getParametrosImpresion().setTextoPieOriginal("CLIENTE");
            parametros.getParametrosImpresion().setTextoPieCopia_1(new Mensaje(ServicioNegocio.getContexto(), OFICINA_1546109685).toString());
        }
    }

    /**
     * Método que incializa 3 atributos comunes a todas las impresiones
     *
     * @param claveDocumento
     * @param pasoDocumento
     */
    private void preparaModeloDescripcionYContexto(String claveDocumento, int pasoDocumento) {
        int codigoColectivo = solicitud.getIdColectivo().intValue();
        if (esPreconcedido && ContextoImpresionFormalizacion.PASO_DOC_INFORMACION_NORMALIZADA_EUROPEA == pasoDocumento) {
            codigoColectivo = 1;
        }
        modelo = GestionClausulaDocumentos.obtenerModeloDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), claveDocumento, solicitud.getTipoExpediente().intValue(), codigoColectivo);
        descripcion = GestionClausulaDocumentos.obtenerDescripcionDocumento(solicitud.getProducto().intValue(), solicitud.getSubproducto().intValue(), solicitud.getVersionGeneral().intValue(), solicitud.getLineaColectivo().intValue(), claveDocumento, solicitud.getTipoExpediente().intValue(), codigoColectivo);
        ctxsImpresion = ContextoImpresionFormalizacion.rellenarDatosContexto(contextosImpresion.toArray(new IContexto[contextosImpresion.size()]), pasoDocumento, modelo);
    }

    /**
     * Recoge los datos de entrada, obtiene los datos de expediente y los de la solicitud
     *
     * @param entrada
     */
    private void recogeDatos(ImprimirDocumentosVO entrada) {
        // Campos  recuperados del VO entrada
        oficina = entrada.getBidOficinaSolicitud();
        numero = entrada.getBidNumeroSolicitud();
        version = entrada.getBidVersionSolicitud();
        nuc = entrada.getBidNucExpediente();
        // de la infoprevia
        guardarImpresion = entrada.getStrGuardarImpresion();
        // de la infoprevia
        guardarComo = entrada.getStrGuardarComo();
        // de poliza, ofertaVinculanteHipotecarios, fiper. Tambien indican si se generan e imprimen o sólo se imprimen estos docs.
        pantallaOrigen = entrada.getStrPantallaOrigen();
        // infoprevia, poliza, ofertavinculante, fiper, docInternoMinuta
        tipoImpresion = entrada.getTipoImpresion();
        // "0":Generar e imprimir,"1":Sólo generar,"2":Guardar en ruta del servidor. Aplica para Info previa y Póliza, de momento.
        indSoloGenerar = entrada.getIndSoloGenerar();
        // Se añade campo al servicio ANPM_261 para controlar la generación del documento
        regenerarVersion = entrada.getRegenerarVersion();
        LOGGER.info("Entrada ANPM_256 - OFICINA_SOLICITUD: ".concat(null != oficina ? oficina.toString() : "null"));
        LOGGER.info("Entrada ANPM_256 - NUMERO_SOLICITUD: ".concat(null != numero ? numero.toString() : "null"));
        LOGGER.info("Entrada ANPM_256 - VERSION_SOLICITUD: ".concat(null != version ? version.toString() : "null"));
        LOGGER.info("Entrada ANPM_256 - NUC_EXPEDIENTE: ".concat(null != nuc ? nuc.toString() : "null"));
        LOGGER.info("Entrada ANPM_256 - GUARDAR_IMPRESION: ".concat(null != guardarImpresion ? guardarImpresion : "null"));
        LOGGER.info("Entrada ANPM_256 - GUARDAR_COMO: ".concat(null != guardarComo ? guardarComo : "null"));
        LOGGER.info("Entrada ANPM_256 - IND_SOLO_GENERAR: ".concat(null != indSoloGenerar ? indSoloGenerar : "null"));
        // 20160205 - Llamada a EEXP_272 (refactorizacion para realizar la llamada solo una vez)
        datosExpediente = UtilidadesTramitacion.obtenerDatosExpediente(nuc);
        // Se añaden los datos de expediente a los contextos de impresión
        contextosImpresion.addAll(Arrays.asList(datosExpediente));
        // 20151124 Optimizamos esta consulta obteniendo la versión incompleta por el indicador de última versión, AN251280.
        solicitud = gds.getUltimaVersionCompleta(nuc);
        if (UtilidadesTramitacion.isBlankOrNull(oficina) || UtilidadesTramitacion.isBlankOrNull(numero) || UtilidadesTramitacion.isBlankOrNull(version)) {
            oficina = solicitud.getDatosSolicitudKey().getOficinaSolicitud();
            numero = solicitud.getDatosSolicitudKey().getNumSolicitud();
            version = solicitud.getDatosSolicitudKey().getVersionSolicitud();
        }
        if (UtilidadesTramitacion.esHipotecario(solicitud.getTipoExpediente())) {
            tipoExpediente = Constantes.CTE_STR_H;
        } else {
            tipoExpediente = Constantes.CTE_STR_P;
        }
        configuracionImpresion = new ConfiguracionImpresion();
        configuracion = new es.caixagalicia.ifrt.impresion.Configuracion();
        esPreconcedido = AbstractSolicitudMultimedio.esPreconcedido(solicitud.getTipoPrescriptor(), solicitud.getCanal(), solicitud.getIndModoAlta());
    }

    /**
     * Método que recoge las comprobaciones previas a la ejecución del servicio.
     * - Si se va a generar la info previa "normal" y la solicitud es de Crediventa cascamos porque ese documento ya está generado
     * - Si la solicitud entra por solicitud-Contrato, en el caso de la póliza si no tiene las cuentas informadas lanzamos rollback
     * - Llamamos a EEXP_998 para saber si el expediente cumple el compromiso
     */
    private void comprobacionesPrevias() {
        // Si no es una impresion permitida lanzamos un rollBack
        if (!UtilidadesTramitacion.impresionPermitida(solicitud.getEstadoSolicitud().toString())) {
            // Se llama al CGAL_373 para recuperar la descripción del estado de la solicitud para el mensaje de error
            IDatosEntradaTx entrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), Constantes.CTE_CC_GESTION_PARAM, Constantes.CTE_CO_GESTION_PARAM);
            entrada.addCampo(0, "C");
            entrada.addCampo(1, "ESO");
            entrada.addCampo(2, StringUtils.leftPad(solicitud.getEstadoSolicitud().toString(), 4, "0"));
            IContexto[] salida = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
            // Si la llamada ha dado resultados se recoge la descripción
            String estado = StringUtils.EMPTY;
            if (null != salida && 0 < salida.length && null != salida[0].getString("CG151C050")) {
                estado = salida[0].getString("CG151C050").trim();
            }
            // Lanzamos un rollBack
            // Si no la impresión continuaría normalmente
            UtilidadesTramitacion.enviarCorreo(CodigosError.ERROR_ESTADO_SOLICITUD_IMPRESION_DOCUMENTOS, solicitud, new String[] { estado, obtieneClaveImpresion(tipoImpresion) });
            ServicioNegocio.rollback(CodigosError.ERROR_ESTADO_SOLICITUD_IMPRESION_DOCUMENTOS, null, new String[] { estado, obtieneClaveImpresion(tipoImpresion) }, new String[] { estado.toLowerCase() });
        }
        if (INFO_PREVIA == tipoImpresion && 0 == ConstantesComun.CTE_IND_MODO_ALTA_CREDIVENTAS.compareTo(solicitud.getIndModoAlta())) {
            UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_CREDIVENTAS_NO_GEN_INFO_PREVIA, solicitud);
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_CREDIVENTAS_NO_GEN_INFO_PREVIA, null, null, null);
        }
        if (OFERTA_VINCULANTE == tipoImpresion || POLIZA == tipoImpresion || // corretaje
        CONTRATO_CREDIVENTAS == tipoImpresion) {
            // - Si no es ASF: comprobar las cuentas en funcion de la parametrizacion en la CG32 (como hasta ahora)
            if (UtilidadesComun.esASF(solicitud.getEntidad())) {
                if (POLIZA == tipoImpresion || CONTRATO_CREDIVENTAS == tipoImpresion) {
                    comprobarCuentas(solicitud);
                }
            } else {
                if (Constantes.CTE_STR_S.equals(UtilidadesTramitacion.comprobarSolicitudContrato(solicitud))) {
                    if (POLIZA == tipoImpresion || CONTRATO_CREDIVENTAS == tipoImpresion) {
                        comprobarCuentas(solicitud);
                    }
                    /*Al actualizar compromiso, si no lo cumple entonces generamos nueva versión, por lo tanto se debe imprimir la póliza de
					 * la versión que acaba de generar.
					 * 
					 * 20150316 Si se imprime la póliza o la oferta vinculante personal:
					 *  - Si la solicitud entra por Solicitud-Contrato:
					 *   * Si es póliza tienen que estar informadas las cuentas del cliente.
					 *   * Se comprueba si la solicitud cumple el compromiso:
					 *    - Si es póliza se actualiza el indicador de que cumple compromiso, AN251290 (ds.strIndicador4)
					 *   * Si lo cumple no hay que hacer nada más.
					 *   * Si no lo cumple:
					 *    - Generamos nueva versión anulando la comisión de apertura.
					 * 
					 * */
                    cumpleCompromiso = cumpleCompromiso(nuc);
                    if (POLIZA == tipoImpresion || CONTRATO_CREDIVENTAS == tipoImpresion) {
                        /*Actualizamos el compromiso, columna AN251290.
						 * Lo actualizamos igual que en PMOS: si se cumple guardamos un 1, si no se cumple guardamos un 2.
						 * 
						 * */
                        if (cumpleCompromiso) {
                            solicitud.setStrIndicador4(Constantes.CTE_STR_1);
                        } else {
                            solicitud.setStrIndicador4(Constantes.CTE_STR_2);
                        }
                        /*Actualizamos la solicitud en base de datos*/
                        gds.updateSolicitud(solicitud);
                    }
                    if (!cumpleCompromiso) {
                        /*20150331 Si la comisión de apertura ya está anulada no generamos versión para anularla.*/
                        if (!comisionAperturaEstaAnulada(solicitud)) {
                            /*Si no cumple el compromiso generamos una nueva versión para anular la comisión de apertura. */
                            solicitud = gds.generarVersionCompleta(solicitud);
                            if (CONTRATO_CREDIVENTAS == tipoImpresion) {
                                // LOG que registra los campos modificados en los datos de solicitud.
                                LogModificacionDatosSolicitud.lanzarLogModificacionDatosSolicitud(nuc, ConstantesComun.CTE_STR_COD_PROCEDENCIA_A248);
                            } else if (POLIZA == tipoImpresion) {
                                // LOG que registra los campos modificados en los datos de solicitud.
                                LogModificacionDatosSolicitud.lanzarLogModificacionDatosSolicitud(nuc, ConstantesComun.CTE_STR_COD_PROCEDENCIA_A249);
                            }
                            // 20160203 - Comprobar si debe anularse o no la comision de apertura, en funcion del
                            // tipo prescriptor e indicador condonacion apertura de la tabla AN82TB01
                            boolean anularComision = compruebaAnularComisionApertura(solicitud);
                            if (anularComision) {
                                /*Anulamos la comisión de apertura y actualizamos en BD. */
                                anularComisionApertura(solicitud);
                            }
                            /*Recuperamos la nueva versión de la solicitud para que el método que
							 * rellena los contextos de la solicitud pille los datos de la versión
							 * nueva*/
                            version = solicitud.getDatosSolicitudKey().getVersionSolicitud();
                        }
                    }
                }
            }
        }
    /*20151127 Si es la impresión/generación de la póliza entonces vamos a recuperar el tipo prescriptor de EEXP y actualizarlo
		 * en la solicitud.*/
    // 2016-04-12 - La actualizacion de centro contable y tipo prescriptor ya se realiza
    // en el servicio de comprobaciones (ANPM_454)
    /*
		if (POLIZA == tipoImpresion)
		{
			tipoPrescriptorEEXP = UtilidadesTramitacion.obtenerTipoPrescriptorEEXP(nuc);
			tipoPrescriptorANPM = UtilidadesTramitacion.traducirTipoPrescriptor(tipoPrescriptorEEXP);
			oficinaContableEEXP = UtilidadesTramitacion.obtenerOficinaContableEEXP(nuc); // 20160127 se añade el campo oficinaContable 
			
			solicitud.setTipoPrescriptor(tipoPrescriptorANPM);
			solicitud.setOficinaContable(oficinaContableEEXP); //20160127 Se setea el valor oficina contable en la tabla 25TB01
			//Actualizamos la solicitud en base de datos
			resDatosSol = gds.updateSolicitud(solicitud);
		}
		*/
    }

    /**
     * Comprueba si estamos en una entidad ASF
     * Hace la comprobacion por entorno de ejecucion
     * Lo valida con la constante definida en utilidades comun
     */
    public static boolean comprobacionASF(IContexto ctxtoSolicitud) {
        String entidad = ctxtoSolicitud.getString("ANPMN050310").trim();
        if (entidad.equals(ConstantesComun.CTE_ENTIDAD_ASF)) {
            return true;
        }
        return false;
    }

    /**
     * Método que recoge las comprobaciones previas correspondientes a banca móvil
     *
     * @param contexto
     */
    private void comprobacionesPreconcedido() {
        // Se obtiene el número para banca móvil de la AN82
        BigDecimal numeroSolicitud = new BigDecimal(UtilidadesComun.consultaParametroAgrupacion("NUMERO", UtilidadesComun.consultaAgrupacion("BMOVIL")).trim());
        // Modificación para que guarde la solicitud antes de la generación en caso de ser banca móvil
        if (POLIZA == tipoImpresion && 0 == numeroSolicitud.compareTo(solicitud.getDatosSolicitudKey().getNumSolicitud()) && AbstractSolicitudMultimedio.esPreconcedido(solicitud.getTipoPrescriptor(), solicitud.getCanal(), solicitud.getIndModoAlta())) {
            GestionDatosSolicitud gds = new GestionDatosSolicitud();
            // Borra la versión con el número de solicitud de la AN82 y guarda la misma versión pero con
            // el número de la CG32 correspondiente a la oficina dada.
            gds.finalizarSolicitud(solicitud, ServicioNegocio.getContexto(), false, false);
            // Sustituye el objeto actual por la versión actualizada con el número correcto.
            solicitud = gds.getUltimaVersion(solicitud.getDatosSolicitudKey().getNucExpediente());
        }
    }

    /**
     * Método que recoge la lógica relacionada con la carga de contextos
     */
    private void cargaContextos(int tipoImpresion) {
        contextosSolicitud = GestionDatosSolicitud.rellenarDatosContexto(solicitud, true);
        contextosImpresion.addAll(java.util.Arrays.asList(contextosSolicitud));
        final int n = contextosSolicitud.length;
        for (int i = 0; i < n && contextoDatosSolicitud == null; i++) {
            if (ID_CTXTO_DATOS_SOLICITUD.equals(contextosSolicitud[i].getNombre())) {
                contextoDatosSolicitud = contextosSolicitud[i];
            }
        }
        /*20140915 Tal y como estaba no estaba obteniendo valores de la cuenta cuando era oferta vinculante hipotecaria.*/
        contextosImpresion.addAll(Arrays.asList(consultarProductoSolicitud(contextoDatosSolicitud)));
        contextosImpresion.addAll(Arrays.asList(consultarDatosCuentas(solicitud)));
        // Consulta titulares
        final IContexto[] aContextoTitulares = consultaTitulares(contextoDatosSolicitud);
        if (aContextoTitulares != null && aContextoTitulares.length > 0 && aContextoTitulares[0] != null) {
            contextosImpresion.addAll(Arrays.asList(aContextoTitulares));
        }
        // consultamos gastos adicionales.
        if (Constantes.CTE_STR_H.equals(tipoExpediente) || (Constantes.CTE_STR_P.equals(tipoExpediente) && 0 != Constantes.CTE_BID_3.compareTo(solicitud.getIndModoAlta()))) {
            // 2016-06-06 - Obtener contextos de condiciones de interes
            contextosIntereses = UtilidadesTramitacion.getContextos(contextosSolicitud, ID_CTXTO_CONDICIONES_INTERES);
            contextosGastosAdicionales = consultarGastosAdicionales(contextoDatosSolicitud, tipoExpediente, UtilidadesTramitacion.consultaFechaInicioExpediente(datosExpediente), contextosIntereses, tipoImpresion);
        }
        if (!UtilidadesTramitacion.isBlankOrNull(contextosGastosAdicionales)) {
            contextosImpresion.addAll(Arrays.asList(contextosGastosAdicionales));
        }
        // Primera llamada al ANPM_266 -> ANPMR203 -> AMPMR206
        contextosAmortizacion = consultarAmortizacion(solicitud, pantallaOrigen, contextoDatosSolicitud, tipoImpresion);
        if (!UtilidadesTramitacion.isBlankOrNull(contextosAmortizacion)) {
            contextoAmortizacion = contextosAmortizacion[0];
        }
        // Se guarda fechaUltimaEntrega y ultimaCuota para enviarle a
        // guardar oferta vinculante en la AN37TB01 para OV Hipotecaria.
        obtenerCamposCtxAmortPorPosteriorSobreescritura(contextoAmortizacion);
        contextosImpresion.addAll(Arrays.asList(contextosAmortizacion));
        if (OFERTA_VINCULANTE == tipoImpresion || POLIZA == tipoImpresion || // corretaje
        CONTRATO_CREDIVENTAS == tipoImpresion) {
            IContexto contextoComisionA = null;
            IContexto contextoComisionB = null;
            for (IContexto contextoActual : contextosSolicitud) {
                if (contextoActual.getNombre().equals(ID_CTXTO_COMISION)) {
                    if (Constantes.TIPO_COMISION_ADELANTO.equals(contextoActual.getString(CMPO_CTXTO_COM_TIPO))) {
                        contextoComisionA = contextoActual;
                    }
                    if (Constantes.TIPO_COMISION_CANCELACION.equals(contextoActual.getString(CMPO_CTXTO_COM_TIPO))) {
                        contextoComisionB = contextoActual;
                    }
                }
            }
            // Comprobar que la comisión de adelanto y la cancelación son iguales
            if ((null == contextoComisionA && null == contextoComisionB) || contextoComisionA.getBigDecimal(CMPO_CTXTO_COM_PORCENTAJE).equals(contextoComisionB.getBigDecimal(CMPO_CTXTO_COM_PORCENTAJE))) {
                if (Constantes.CTE_LETRA_S.equals(contextoDatosSolicitud.getString(CMPO_CTXTO_SOL_CORRETAJE))) {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.info("INICIO Consulta corretaje");
                    }
                    contextosImpresion.addAll(Arrays.asList(llamadaAlProgramaCorretaje(contextoDatosSolicitud)));
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.info("FIN Consulta corretaje");
                    }
                }
            } else {
                // Error las comisiones no son iguales
                UtilidadesTramitacion.enviarCorreo(ERROR_VALIDACION_COMISIONES, solicitud);
                ServicioNegocio.rollback(ERROR_VALIDACION_COMISIONES, null, null, null);
            }
        }
        // Actualizamos el histórico de impresion de documentos.
        // 20150722 Tenemos que grabar en el histórico de impresión antes de actualizar las fechas de impresión de los documentos, porque si no en el
        // objeto solicitud va a pillar la fecha de impresion nueva, y para comprobar si guardamos en el histórico o no necesitamos la fecha que había antes.*/
        fiperImpresa = actualizarHistoricoImpresion(gds, tipoImpresion, contextoDatosSolicitud, contextoAmortizacion, solicitud, UtilidadesTramitacion.obtenerOficinaContableEEXP(datosExpediente), contextosIntereses, contextosGastosAdicionales);
        // con el codigo "1" y la descripcion del error.
        if (tipoImpresion == FIPER) {
            contextosErrorFiper = new IContexto[1];
            if (fiperImpresa && ("N".equals(regenerarVersion) || StringUtils.isBlank(regenerarVersion))) {
                // $OP-LBL-NL-2$
                contextosErrorFiper[0] = ContextoErrorImpresionFIPER.rellenarContextoErrorImpresionFIPER(BigDecimal.ONE, new Mensaje(ServicioNegocio.getContexto(), FIPER_EST_IMPRESA_1144425086).toString() + new Mensaje(ServicioNegocio.getContexto(), QUIERE_SACAR_COPIA_TAREA_GESTI_N_DOCUMENTACI_N_134346366).toString());
            } else if (// en caso de que se quiera regenerar versión no se muestra el mensaje
            fiperImpresa && esEntornoAbanca && "S".equals(regenerarVersion)) {
                contextosErrorFiper[0] = ContextoErrorImpresionFIPER.rellenarContextoErrorImpresionFIPER(BigDecimal.ZERO, // mensaje vacío
                "");
            }
        }
    }

    /**
     * Metodo que realiza las comprobaciones
     *
     * @param nuc Datos para la cabecera de la impresion.
     * @param codigoDocumento Tipo de documento
     * @param obdetalle Datos del impreso
     *
     * @return RespuestaImpresion indicando si acabo bien o no.
     */
    public static RespuestaImpresion adjuntarDocumentoGestorDocumentacion(BigDecimal nuc, String descripcion, String codigoImpreso, String codDocumento, IContexto[] obdetalle, int tipoImpresion, final IContexto contextoSolicitud) {
        Parametros parametros = new Parametros();
        parametros.setNucCabecera(nuc.toString());
        // Código cliente (obligatorio)
        parametros.getParametrosGestorDocumental().setCodigoCliente(Constantes.CTE_CERO.toString());
        // Tipo de documento (obligatorio)
        parametros.getParametrosGestorDocumental().setCodigoGestorDocumental(codDocumento);
        // Opcional
        parametros.getParametrosGestorDocumental().setDescripcionGestoDocumental(descripcion);
        // Array de NUCs, obligatorio al menos uno
        parametros.getParametrosGestorDocumental().setNuc(new String[] { nuc.toString() });
        parametros.getParametrosGestorDocumental().setSobreescribir(false);
        parametros.getParametrosGestorDocumental().habilitar();
        RespuestaImpresion respuesta = Documento.generarPDF(codigoImpreso, obdetalle, parametros);
        String nombreFichero = StringUtils.EMPTY;
        String entidadStr = null;
        String oficinaStr = null;
        String numSolicStr = null;
        String digitoStr = null;
        String nucStr = null;
        String versionStr = null;
        Date fechaHoy = null;
        String tipoDocumento = null;
        /*EDIT V360144 20140627*/
        /*Rosa: "Otra cosa que tenemos que hacer es que cuando llamamos 
		 * al stream para generar los documentos, estos documentos además 
		 * de guardarlos en la gestión documental, tenemos que almacenarlos 
		 * en la misma ruta donde se guarda el fichero que generamos en el batch anpm_300."*/
        /*En rutaSalidaFichero tenemos que concatenarle /CARPETA_DOC/ donde CARPETA_DOC puede ser:
		 * 
			INFOPREVIA
			POLIZA
			OVPERSONAL
			FIPER
			DOCINTERNOMINUTA
			OVHIPOTECARIOS
			RECIBO
			TABLA_PAGOS
		*/
        // boolean indTablaPagos = false;
        String rutaSalidaFichero = Configuracion.getInstance().getValor(CTE_RUTA_SALIDA_FICHEROS_APLICACION, CTE_RUTA_SALIDA_FICHEROS_GRUPO_CONF, CTE_RUTA_SALIDA_FICHEROS_PARAM_CONF).trim();
        switch(tipoImpresion) {
            case INFO_PREVIA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM001D_INFOPREVIA");
                    break;
                }
            case INFORMACION_NORMALIZADA_EUROPEA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM001D_INFOPREVIA");
                    break;
                }
            case POLIZA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM002D_POLIZA");
                    break;
                }
            case CONTRATO_CREDIVENTAS:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM002D_POLIZA");
                    break;
                }
            case OFERTA_VINCULANTE:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM003D_OVPERSONAL");
                    break;
                }
            case FIPER:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM004D_FIPER");
                    break;
                }
            case DOC_INTERNO_MINUTA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM005D_DOCINTERNOMINUTA");
                    break;
                }
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM006D_OVHIPOTECARIOS");
                    break;
                }
            case RECIBO_FORMALIZACION:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM007D_RECIBO");
                    break;
                }
            // }
            default:
                {
                    break;
                }
        }
        // La estructura del nombre del fichero:
        // <ENTIDAD>_<OFICINA>_<NUM_SOL>_<DIGITO>_<FECHA_AAAAMMDD>_<NUC>.PDF
        versionStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION).toString();
        if (esEntornoAbanca) {
            String nombreCodigoEntidad = "";
            if (comprobacionASF(contextoSolicitud)) {
                nombreCodigoEntidad = IConstantesSolicitud.CTE_PARAMETRO_NOMBRE_CODIGO_ENTIDAD_ASF;
            } else {
                nombreCodigoEntidad = IConstantesSolicitud.CTE_PARAMETRO_NOMBRE_CODIGO_ENTIDAD_ABANCA;
            }
            // entidadStr = nombreFichero.concat(Constantes.CTE_COD_ENTIDAD_ABANCA);
            entidadStr = nombreFichero.concat(UtilidadesTramitacion.obtenerValorParametroUnico(IConstantesSolicitud.CTE_PARAMETRO_AGRUPACION_GENERAL, nombreCodigoEntidad));
        // if (indTablaPagos)
        // {
        // //<NUC><_><pagos><_><V><XX> --> XX es un contador de 01 a 99
        // 
        // nombreFichero = nombreFichero.concat(nuc.toString());
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_SEPARACION_GUION_BAJO);
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_LITERAL_PAGOS);
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_SEPARACION_GUION_BAJO);
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_LITERAL_V);
        // 
        // if ((null != versionStr) && (1 == versionStr.length()))
        // {
        // nombreFichero = nombreFichero.concat("0"+ versionStr);
        // }
        // else
        // {
        // nombreFichero = nombreFichero.concat(versionStr);
        // }
        // }
        }
        // Obtenemos oficina
        oficinaStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_OFICINA).toString();
        // Obtenemos número solicitud
        numSolicStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUMERO).toString();
        // Obtenemos digito solicitud
        digitoStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_DIGITO).toString();
        fechaHoy = new Date(DateHelper.getInstance().askTime().getTime());
        // nuc
        nucStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUC).toString();
        versionStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION).toString();
        // if (!indTablaPagos)
        // {
        nombreFichero = nombreFichero.concat(entidadStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(oficinaStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(numSolicStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(digitoStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(DateHelper.sqlDateToString(fechaHoy, DateHelper.FORMATO_YYYYMMDD));
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(nucStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(versionStr);
        if ((null == respuesta) || (null == respuesta.getvaloresSOW())) {
            switch(tipoImpresion) {
                case INFO_PREVIA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), INFO_PREVIA_1986072003).toString();
                        break;
                    }
                case INFORMACION_NORMALIZADA_EUROPEA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), INFO_PREVIA_1986072003).toString();
                        break;
                    }
                case POLIZA:
                    {
                        tipoDocumento = "POLIZA";
                        break;
                    }
                case CONTRATO_CREDIVENTAS:
                    {
                        tipoDocumento = "POLIZA";
                        break;
                    }
                case OFERTA_VINCULANTE:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), OV_PERSONAL_872698791).toString();
                        break;
                    }
                case FIPER:
                    {
                        tipoDocumento = "FIPER";
                        break;
                    }
                case DOC_INTERNO_MINUTA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), DOC_INTERNO_MINUTA_945634467).toString();
                        break;
                    }
                case OFERTA_VINCULANTE_HIPOTECARIOS:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), OV_HIPOTECARIA_397170850).toString();
                        break;
                    }
                case RECIBO_FORMALIZACION:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), RECIBO_FORMALIZ_1990707436).toString();
                        break;
                    }
                // }
                default:
                    {
                        tipoDocumento = StringUtils.EMPTY;
                        break;
                    }
            }
            /*
			20141029: Cuando se adjunta el documento a la gestión documental y por algún motivo
			 acaba mal el método Documento.generarPDF(..) no se hace rollback, se continúa la ejecución.
			EDIT: sólo se hace rollback cuando acaba mal el método y además se intenta imprimir algún documento
			que no sea el recibo de formalización, es decir, cuando se intenta generar el recibo de formalización
			y añadirlo a la gestión documental, si al llamar al método interno no acaba bien pero no lanza un rollback
			nosotros tampoco lanzamos el rollback.
			*/
            DatosSolicitudEng solicitudDao = new DatosSolicitudEng();
            DatosSolicitudC solicitud = solicitudDao.getUltimaVersion(nuc);
            if (RECIBO_FORMALIZACION != tipoImpresion) {
                if (null == respuesta) {
                    UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF, solicitud);
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF, new String[] { tipoDocumento }, new String[] { nucStr }, null);
                } else if (null == respuesta.getvaloresSOW() && !StringUtils.isBlank(respuesta.getDescripcionerror())) {
                    UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF_DESCR, solicitud);
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF_DESCR, new String[] { tipoDocumento }, new String[] { nucStr }, new String[] { respuesta.getDescripcionerror() });
                }
            }
        }
        if ((null != respuesta.getvaloresSOW()) && Constantes.CTE_STR_0.equals(respuesta.getCodigoError())) {
            // Copia el fichero almacenado en el servidor de objetos a la ruta especificada
            SOW.obtener(respuesta.getvaloresSOW().getAplicacion(), respuesta.getvaloresSOW().getColeccion(), new BigDecimal(respuesta.getvaloresSOW().getAgrupacion()), new BigDecimal(respuesta.getvaloresSOW().getSecuencia()), respuesta.getvaloresSOW().getObjeto(), rutaSalidaFichero, nombreFichero);
        }
        return respuesta;
    }

    /**
     * Sobrecarga del método para prueba: BORRAR!
     */
    public static RespuestaImpresion adjuntarDocumentoGestorDocumentacion2(BigDecimal nuc, String descripcion, String codigoImpreso, String codDocumento, IContexto[] obdetalle, int tipoImpresion, final IContexto contextoSolicitud, RespuestaImpresion respuesta, boolean documentoGenerado, boolean esPreconcedido) {
        Parametros parametros = new Parametros();
        parametros.setNucCabecera(nuc.toString());
        // Código cliente (obligatorio)
        parametros.getParametrosGestorDocumental().setCodigoCliente(Constantes.CTE_CERO.toString());
        // Tipo de documento (obligatorio)
        parametros.getParametrosGestorDocumental().setCodigoGestorDocumental(codDocumento);
        // Opcional
        parametros.getParametrosGestorDocumental().setDescripcionGestoDocumental(descripcion);
        // Array de NUCs, obligatorio al menos uno
        parametros.getParametrosGestorDocumental().setNuc(new String[] { nuc.toString() });
        parametros.getParametrosGestorDocumental().setSobreescribir(false);
        parametros.getParametrosGestorDocumental().habilitar();
        if (("PMOSST20671".equals(codigoImpreso) || "PMOSST20703".equals(codigoImpreso) || // Doc.interno para minutar
        "PMOSST20190".equals(codigoImpreso) || // O.V. Hipotecarios
        "PMOSST20189".equals(codigoImpreso) || // Póliza
        "PMOSST20338".equals(codigoImpreso) || // Póliza
        "PMOSST20702".equals(codigoImpreso)) && false == documentoGenerado) {
            if (// Para cuando la OV es móvil, 259
            OV_MOVIL == tipoImpresion || // Para el 256, información previa
            (INFO_PREVIA == tipoImpresion && esPreconcedido)) {
                respuesta = Documento.generarPDFaGDOC(codigoImpreso, obdetalle, parametros);
            } else {
                respuesta = Documento.generarPDF(codigoImpreso, obdetalle, parametros);
            }
        }
        /*
		if(("PMOSST20190".equals(codigoImpreso) // Doc.interno para minutar
		  ||"PMOSST20189".equals(codigoImpreso) // O.V. Hipotecarios
		  ||"PMOSST20338".equals(codigoImpreso))// Póliza
		&& false == documentoGenerado) 
		{
			respuesta = Documento.generarPDF(codigoImpreso, obdetalle, parametros);
		}*/
        // if ("S".equals(enviarCorreo))
        // {
        // String correoRemitente = "";
        // String correoDestinatario = "";
        // String tipoCorreo = "";
        // 
        // IRegistro[] direccionesCorreo = ctxDireccionesCorreo.getRegistro("ANPMN260010");
        // 
        // for (IRegistro obtenerMail : direccionesCorreo)
        // {
        // tipoCorreo = obtenerMail.getString("ANPMN260011");
        // 
        // if ("R".equals(tipoCorreo))
        // {
        // correoRemitente = obtenerMail.getString("ANPMN260012");
        // }
        // else if ("D".equals(tipoCorreo))
        // {
        // correoDestinatario = obtenerMail.getString("ANPMN260012");
        // }
        // }
        // parametros.getParametrosCorreo().setDestinatarios(correoDestinatario); // Obligatorio
        // parametros.getParametrosCorreo().setRemitente(correoRemitente); // Opcional
        // }
        String nombreFichero = StringUtils.EMPTY;
        String entidadStr = null;
        String oficinaStr = null;
        String numSolicStr = null;
        String digitoStr = null;
        String nucStr = null;
        String versionStr = null;
        Date fechaHoy = null;
        String tipoDocumento = null;
        /*EDIT V360144 20140627*/
        /*Rosa: "Otra cosa que tenemos que hacer es que cuando llamamos 
		 * al stream para generar los documentos, estos documentos además 
		 * de guardarlos en la gestión documental, tenemos que almacenarlos 
		 * en la misma ruta donde se guarda el fichero que generamos en el batch anpm_300."


		/*En rutaSalidaFichero tenemos que concatenarle /CARPETA_DOC/ donde CARPETA_DOC puede ser:
		 * 
			INFOPREVIA
			POLIZA
			OVPERSONAL
			FIPER
			DOCINTERNOMINUTA
			OVHIPOTECARIOS
			RECIBO
			TABLA_PAGOS
		*/
        // boolean indTablaPagos = false;
        String rutaSalidaFichero = Configuracion.getInstance().getValor(CTE_RUTA_SALIDA_FICHEROS_APLICACION, CTE_RUTA_SALIDA_FICHEROS_GRUPO_CONF, CTE_RUTA_SALIDA_FICHEROS_PARAM_CONF).trim();
        switch(tipoImpresion) {
            case INFO_PREVIA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM001D_INFOPREVIA");
                    break;
                }
            case INFORMACION_NORMALIZADA_EUROPEA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM001D_INFOPREVIA");
                    break;
                }
            case POLIZA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM002D_POLIZA");
                    break;
                }
            case CONTRATO_CREDIVENTAS:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM002D_POLIZA");
                    break;
                }
            case OFERTA_VINCULANTE:
            case OV_MOVIL:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM003D_OVPERSONAL");
                    break;
                }
            case FIPER:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM004D_FIPER");
                    break;
                }
            case DOC_INTERNO_MINUTA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM005D_DOCINTERNOMINUTA");
                    break;
                }
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM006D_OVHIPOTECARIOS");
                    break;
                }
            case RECIBO_FORMALIZACION:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM007D_RECIBO");
                    break;
                }
            // }
            default:
                {
                    break;
                }
        }
        // La estructura del nombre del fichero:
        // <ENTIDAD>_<OFICINA>_<NUM_SOL>_<DIGITO>_<FECHA_AAAAMMDD>_<NUC>.PDF
        versionStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION).toString();
        if (esEntornoAbanca) {
            String nombreCodigoEntidad = "";
            if (comprobacionASF(contextoSolicitud)) {
                nombreCodigoEntidad = IConstantesSolicitud.CTE_PARAMETRO_NOMBRE_CODIGO_ENTIDAD_ASF;
            } else {
                nombreCodigoEntidad = IConstantesSolicitud.CTE_PARAMETRO_NOMBRE_CODIGO_ENTIDAD_ABANCA;
            }
            // entidadStr = nombreFichero.concat(Constantes.CTE_COD_ENTIDAD_ABANCA);
            entidadStr = nombreFichero.concat(UtilidadesTramitacion.obtenerValorParametroUnico(IConstantesSolicitud.CTE_PARAMETRO_AGRUPACION_GENERAL, nombreCodigoEntidad));
        // if (indTablaPagos)
        // {
        // //<NUC><_><pagos><_><V><XX> --> XX es un contador de 01 a 99
        // 
        // nombreFichero = nombreFichero.concat(nuc.toString());
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_SEPARACION_GUION_BAJO);
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_LITERAL_PAGOS);
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_SEPARACION_GUION_BAJO);
        // nombreFichero = nombreFichero.concat(IConstantesTramitacion.CTE_LITERAL_V);
        // 
        // if ((null != versionStr) && (1 == versionStr.length()))
        // {
        // nombreFichero = nombreFichero.concat("0"+ versionStr);
        // }
        // else
        // {
        // nombreFichero = nombreFichero.concat(versionStr);
        // }
        // }
        }
        // Obtenemos oficina
        oficinaStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_OFICINA).toString();
        // Obtenemos número solicitud
        numSolicStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUMERO).toString();
        // Obtenemos digito solicitud
        digitoStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_DIGITO).toString();
        fechaHoy = new Date(DateHelper.getInstance().askTime().getTime());
        // nuc
        nucStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUC).toString();
        versionStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION).toString();
        // if (!indTablaPagos)
        // {
        nombreFichero = nombreFichero.concat(entidadStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(oficinaStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(numSolicStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(digitoStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(DateHelper.sqlDateToString(fechaHoy, DateHelper.FORMATO_YYYYMMDD));
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(nucStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(versionStr);
        if ((null == respuesta) || (null == respuesta.getvaloresSOW())) {
            switch(tipoImpresion) {
                case INFO_PREVIA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), INFO_PREVIA_1986072003).toString();
                        break;
                    }
                case INFORMACION_NORMALIZADA_EUROPEA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), INFO_PREVIA_1986072003).toString();
                        break;
                    }
                case POLIZA:
                    {
                        tipoDocumento = "POLIZA";
                        break;
                    }
                case CONTRATO_CREDIVENTAS:
                    {
                        tipoDocumento = "POLIZA";
                        break;
                    }
                case OFERTA_VINCULANTE:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), OV_PERSONAL_872698791).toString();
                        break;
                    }
                case FIPER:
                    {
                        tipoDocumento = "FIPER";
                        break;
                    }
                case DOC_INTERNO_MINUTA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), DOC_INTERNO_MINUTA_945634467).toString();
                        break;
                    }
                case OFERTA_VINCULANTE_HIPOTECARIOS:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), OV_HIPOTECARIA_397170850).toString();
                        break;
                    }
                case RECIBO_FORMALIZACION:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), RECIBO_FORMALIZ_1990707436).toString();
                        break;
                    }
                // }
                default:
                    {
                        tipoDocumento = StringUtils.EMPTY;
                        break;
                    }
            }
            /*
			20141029: Cuando se adjunta el documento a la gestión documental y por algún motivo
			 acaba mal el método Documento.generarPDF(..) no se hace rollback, se continúa la ejecución.
			EDIT: sólo se hace rollback cuando acaba mal el método y además se intenta imprimir algún documento
			que no sea el recibo de formalización, es decir, cuando se intenta generar el recibo de formalización
			y añadirlo a la gestión documental, si al llamar al método interno no acaba bien pero no lanza un rollback
			nosotros tampoco lanzamos el rollback.
			*/
            DatosSolicitudEng solicitudDao = new DatosSolicitudEng();
            DatosSolicitudC solicitud = solicitudDao.getUltimaVersion(nuc);
            if (RECIBO_FORMALIZACION != tipoImpresion) {
                if (null == respuesta) {
                    LOGGER.info("ANPM_256 - adjuntarDocumentoGestorDocumentacion2 - Dentro de condicion error (null == respuesta)");
                    UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF, solicitud);
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF, new String[] { tipoDocumento }, new String[] { nucStr }, null);
                } else if (null == respuesta.getvaloresSOW() && !StringUtils.isBlank(respuesta.getDescripcionerror())) {
                    LOGGER.info("ANPM_256 - adjuntarDocumentoGestorDocumentacion2 - Dentro de condicion error (null == respuesta.getValoresSOW)");
                    UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF_DESCR, solicitud);
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF_DESCR, new String[] { tipoDocumento }, new String[] { nucStr }, new String[] { respuesta.getDescripcionerror() });
                }
            }
        }
        if ((null != respuesta.getvaloresSOW()) && Constantes.CTE_STR_0.equals(respuesta.getCodigoError())) {
            LOGGER.info("ANPM_256 - adjuntarDocumentoGestorDocumentacion2 - OK: null != getValoresSOW, respuesta.error = 0");
            SOW.obtener(respuesta.getvaloresSOW().getAplicacion(), respuesta.getvaloresSOW().getColeccion(), new BigDecimal(respuesta.getvaloresSOW().getAgrupacion()), new BigDecimal(respuesta.getvaloresSOW().getSecuencia()), respuesta.getvaloresSOW().getObjeto(), rutaSalidaFichero, nombreFichero);
        }
        return respuesta;
    }

    /**
     * Metodo que realiza las comprobaciones
     *
     * @param nuc Datos para la cabecera de la impresion.
     * @param codigoDocumento Tipo de documento
     * @param obdetalle Datos del impreso
     *
     * @return RespuestaImpresion indicando si acabo bien o no.
     */
    /*
	public static RespuestaImpresion adjuntarDocumentoGestorDocumentacion(BigDecimal nuc, String descripcion,  
		String codigoImpreso, String codDocumento, IContexto[] obdetalle)
	{
//		boolean exito2 = false;
		
//		Propiedades propiedadesGD = new Propiedades();
//		Configuracion configuracion2 = new Configuracion();
//		
//		// configuramos las propiedades para imprimir.
//		if (null != nuc)
//		{
//			propiedadesGD.setNuc(nuc.toString());
//		}
		
//		ConfiguracionGestorDocumentacion configuracionGestorDocumentacion = 
//			new ConfiguracionGestorDocumentacion();

		//BigDecimal numCliente = obtenerCliente(nuc);
		
		
		// si cod cliente a 0 --> al gestor documentos del contrato
		// Solo cod cliente --> al gestor de documentos del cliente

		//varios nucs --> varios documentos
//		String[] nucs = new String[1];
//		nucs[0] = nuc.toString();		
//		configuracionGestorDocumentacion.setNucs(nucs);

//		configuracionGestorDocumentacion.setCodCliente(Constantes.CTE_CERO.toString());		
//		configuracionGestorDocumentacion.setCodDocumentoGD(codDocumento);
//		configuracionGestorDocumentacion.setDescripcion(descripcion);
//			
//		configuracion2.setGestorDocumentacion(configuracionGestorDocumentacion);
//		
//		ConfiguracionImpresion configuracionImpresion2 = new ConfiguracionImpresion();
//		
//		//solo guarda en gestión documentación
//		configuracionImpresion2.setFormato("PDF");
//		configuracionImpresion2.setVisualizacion("V");
//		configuracion2.setImpresion(configuracionImpresion2);
		
//		exito2 = ImpresionHelper.imprimir(codigoImpreso, "V", obdetalle,
//				propiedadesGD, configuracion2);
		
		
		// Parámetros
		Parametros parametros = new Parametros();
		// Gestor documental 
		parametros.getParametrosGestorDocumental().setCodigoCliente(Constantes.CTE_CERO.toString()); // Código cliente (obligatorio)
		parametros.getParametrosGestorDocumental().setCodigoGestorDocumental(codDocumento); // Tipo de documento (obligatorio)
		parametros.getParametrosGestorDocumental().setDescripcionGestoDocumental(descripcion); // Opcional
		// Array de NUCs, obligatorio al menos uno
		parametros.getParametrosGestorDocumental().setNuc(new String[] {nuc.toString()}); 
		parametros.getParametrosGestorDocumental().setSobreescribir(false);
		parametros.getParametrosGestorDocumental().habilitar();

		RespuestaImpresion respuesta = Documento.generarPDF(codigoImpreso, obdetalle, parametros);
		
		
		//EDIT V360144 20140627
		//*Rosa: "Otra cosa que tenemos que hacer es que cuando llamamos 
		 //* al stream para generar los documentos, estos documentos además 
		 //* de guardarlos en la gestión documental, tenemos que almacenarlos 
		 //* en la misma ruta donde se guarda el fichero que generamos en el batch anpm_300."


		//FIN EDIT V360144 20140627 
		return respuesta;
		
//		return exito2;
	}	
	*/
    /**
     * @param oficina
     * @param numero
     * @param version
     * @param nuc
     * @param pantallaOrigen
     * @param contextoDatosSolicitud
     * @return
     */
    private IContexto[] consultarAmortizacion(DatosSolicitudC solicitud, final String pantallaOrigen, final IContexto contextoDatosSolicitud, int tipoImpresion) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("INICIO Consulta del cuadro de amortizacion");
        }
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        DatosSolicitudC solicitudB = gds.obtenerDatosSolicitud(solicitud.getDatosSolicitudKey().getOficinaSolicitud(), solicitud.getDatosSolicitudKey().getNumSolicitud(), solicitud.getDatosSolicitudKey().getVersionSolicitud(), solicitud.getDatosSolicitudKey().getNucExpediente());
        if (null == solicitudB) {
            LOGGER.info("no hay datos para la consulta de la an25tb01, Oficina:" + solicitud.getDatosSolicitudKey().getOficinaSolicitud() + "Numero solicitud:" + solicitud.getDatosSolicitudKey().getNumSolicitud() + "Versión solicitud:" + solicitud.getDatosSolicitudKey().getVersionSolicitud() + "Nuc expediente" + solicitud.getDatosSolicitudKey().getNucExpediente());
        }
        final IDatosEntradaTx datosEntradaConsultaAmortizacion = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), Constantes.ID_CUENTA_ANPM, ID_CODOP_CONSULTA_AMORTIZACION);
        datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_OFICINA_SOLICITUD, solicitud.getDatosSolicitudKey().getOficinaSolicitud());
        datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_NUMERO_SOLICITUD, solicitud.getDatosSolicitudKey().getNumSolicitud());
        datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_VERSION_SOLICITUD, solicitud.getDatosSolicitudKey().getVersionSolicitud());
        datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_NUC_EXPEDIENTE, solicitud.getDatosSolicitudKey().getNucExpediente());
        datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_DIGITO_SOLICITUD, contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_DIGITO));
        switch(tipoImpresion) {
            case INFO_PREVIA:
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_PANTALLA_ORIGEN, VALOR_CAMPO_SRV_PANTALLA_PREFORMA);
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN, Constantes.CTE_BID_COP_IMPRIMIR_PREVIA);
                break;
            case INFORMACION_NORMALIZADA_EUROPEA:
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_PANTALLA_ORIGEN, VALOR_CAMPO_SRV_PANTALLA_PREFORMA);
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN, Constantes.CTE_BID_COP_IMPRIMIR_PREVIA);
                break;
            case POLIZA:
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN, Constantes.CTE_BID_COP_IMPRIMIR_POLIZA);
                if (!UtilidadesTramitacion.isBlankOrNull(pantallaOrigen)) {
                    datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_PANTALLA_ORIGEN, pantallaOrigen);
                }
                break;
            case CONTRATO_CREDIVENTAS:
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN, Constantes.CTE_BID_COP_IMPRIMIR_POLIZA);
                if (!UtilidadesTramitacion.isBlankOrNull(pantallaOrigen)) {
                    datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_PANTALLA_ORIGEN, pantallaOrigen);
                }
                break;
            case OFERTA_VINCULANTE:
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_PANTALLA_ORIGEN, VALOR_CAMPO_SRV_PANTALLA_PREFORMA);
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN, Constantes.CTE_BID_COP_IMPRIMIR_VINCULANTE);
                break;
            // 2013-07-09 Inclusión impresión Fiper y OV para Hipotecarios - G000895
            case FIPER:
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_PANTALLA_ORIGEN, VALOR_CAMPO_SRV_PANTALLA_FIPER_OV);
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN, Constantes.CTE_BID_COP_IMPRIMIR_FIPER);
                break;
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_PANTALLA_ORIGEN, VALOR_CAMPO_SRV_PANTALLA_OV_HIPOTECARIOS);
                datosEntradaConsultaAmortizacion.addCampo(NOMBRE_CAMPO_SRV_SERVICIO_ORIGEN, Constantes.CTE_BID_COP_IMPRIMIR_VINCULANTE);
                break;
            default:
                break;
        }
        final IContexto[] aCntxtoSldaProgAmort = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaAmortizacion);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("FIN Consulta cuadro de amortización");
        }
        return aCntxtoSldaProgAmort;
    }

    /**
     * @param oficina
     * @param numero
     * @param version
     * @param nuc
     * @return Datos de las cuentas asociadas a la solicitud
     */
    private IContexto[] consultarDatosCuentas(DatosSolicitudC solicitud) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("INICIO Consulta cuentas solicitud");
        }
        IDatosEntradaTx datosEntradaDatosCuentas = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), Constantes.ID_CUENTA_ANPM, ID_COOP_CONS_CUENTAS_SOL);
        datosEntradaDatosCuentas.addCampo(NOMBRE_CAMPO_OFICINA_SOLICITUD, solicitud.getDatosSolicitudKey().getOficinaSolicitud());
        datosEntradaDatosCuentas.addCampo(NOMBRE_CAMPO_NUMERO_SOLICITUD, solicitud.getDatosSolicitudKey().getNumSolicitud());
        datosEntradaDatosCuentas.addCampo(NOMBRE_CAMPO_VERSION_SOLICITUD, solicitud.getDatosSolicitudKey().getVersionSolicitud());
        datosEntradaDatosCuentas.addCampo(NOMBRE_CAMPO_NUC_EXPEDIENTE, solicitud.getDatosSolicitudKey().getNucExpediente());
        final IContexto[] aConsultaCuentas = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaDatosCuentas);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("FIN Consulta cuentas solicitud");
        }
        return aConsultaCuentas;
    }

    /**
     * @param contextoDatosSolicitud
     * @return Datos de los titulares asociados a la solicitud
     */
    private IContexto[] consultaTitulares(IContexto contextoDatosSolicitud) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("INICIO Consulta titulares del expediente de la solicitud");
        }
        IDatosEntradaTx datosEntradaConsultaTitulares = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), ID_CUENTA_MEFC, ID_CODOP_CONSULTA_TITULARES);
        datosEntradaConsultaTitulares.addCampo(NOMBRE_CAMPO_APLICACION, "ANPM");
        datosEntradaConsultaTitulares.addCampo(NOMBRE_CAMPO_CODOPER, Constantes.CODOPER_CONSULTA);
        datosEntradaConsultaTitulares.addCampo(NOMBRE_CAMPO_NUC, contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUC));
        final IContexto[] aContextoTitulares = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaTitulares);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("FIN Consulta titulares del expediente de la solicitud");
        }
        return aContextoTitulares;
    }

    /**
     * @param contextoDatosSolicitud
     * @return Datos del producto asociado a la solicitud
     */
    private IContexto[] consultarProductoSolicitud(IContexto contextoDatosSolicitud) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("INICIO Consulta producto solicitud");
        }
        IDatosEntradaTx datosEntradaDatosProducto = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), Constantes.ID_CUENTA_ANPM, ID_CODOP_DETALLE_PRODUCTO);
        datosEntradaDatosProducto.addCampo(CTE_POSICION_TIRA_ID_PRODUCTO, contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_IDPRODUCTO));
        datosEntradaDatosProducto.addCampo(CTE_POSICION_TIRA_ID_SUBPRODUCTO, contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_SUBPRODUCTO));
        datosEntradaDatosProducto.addCampo(CTE_POSICION_TIRA_COLECTIVO, contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_COLECTIVO));
        datosEntradaDatosProducto.addCampo(CTE_POSICION_TIRA_ID_VERSION_GENERAL, contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION_GENERAL));
        datosEntradaDatosProducto.addCampo(CTE_POSICION_TIRA_COD_COLECTIVO, contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_COD_COLECTIVO));
        IContexto[] aCtxtoProducto = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaDatosProducto);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.info("FIN Consulta producto solicitud");
        }
        return aCtxtoProducto;
    }

    /**
     * @param contextoSolicitud
     * @return Resulta de la consulta de corretaje
     */
    private IContexto[] llamadaAlProgramaCorretaje(IContexto contextoSolicitud) {
        // Nombre del programa
        final String ID_PROG_CORRETAJE = "ANPMR201";
        // Contexto Programa
        final String ID_CTXTO_PROG_CORRETAJE = "ANPMN073";
        final String ANPMN073_DIVISA = "ANPMN073010";
        final String ANPMN073_IMP_CONCEDIDO = "ANPMN073020";
        final String ANPMN073_PLAZO_CONCEDIDO = "ANPMN073030";
        final String ANPMN073_FECHA_CONCESION = "ANPMN073040";
        final String ANPMN073_GARANTIA = "ANPMN073050";
        final String ANPMN073_OFICINA = "ANPMN073090";
        final String ANPMN073_NUMERO = "ANPMN073100";
        final String ANPMN073_VERSION = "ANPMN073110";
        final String ANPMN073_NUC = "ANPMN073120";
        // Campos del contexto solicitud
        final String CMPO_CTXTO_SOL_DIVISA = "ANPMN050590";
        final String CMPO_CTXTO_SOL_IMPORTE = "ANPMN050580";
        final String CMPO_CTXTO_SOL_PLAZO = "ANPMN050710";
        final String CMPO_CTXTO_SOL_FECHA = "ANPMN050994";
        final String CMPO_CTXTO_FORMALIZACION_FECHA = "ANPMN050920";
        final String CMPO_CTXTO_SOL_TIPO_GARANTIA = "ANPMN050220";
        final String CMPO_CTXTO_SOL_GARANTIA_CONTABLE = "ANPMN050260";
        final String CMPO_CTXTO_SOL_GARANTIA_OFICINA = "ANPMN050230";
        final String strDivisa = contextoSolicitud.getString(CMPO_CTXTO_SOL_DIVISA);
        final BigDecimal bidImporte = contextoSolicitud.getBigDecimal(CMPO_CTXTO_SOL_IMPORTE);
        final BigDecimal bidPlazo = contextoSolicitud.getBigDecimal(CMPO_CTXTO_SOL_PLAZO);
        final String strFechaConcesion = contextoSolicitud.getString(CMPO_CTXTO_SOL_FECHA);
        final String strFechaFormalizacion = contextoSolicitud.getString(CMPO_CTXTO_FORMALIZACION_FECHA);
        if (0 == DateUtils.dateLowest().compareTo(DateUtils.parseDate(strFechaConcesion, DateUtils.FORMATO_FECHA_CORTO))) {
            ServicioNegocio.rollback(CTE_MSG_ERROR_FECHA_CONCESION, null, null, null);
        }
        /*BigDecimal	bidFechaConcesion = new BigDecimal(
				DateUtils.formatDate(
					DateUtils.parseDate(strFechaConcesion, DateUtils.FORMATO_FECHA_CORTO),
					"yyyyMMdd"));*/
        BigDecimal bidFechaFormalizacion = new BigDecimal(DateUtils.formatDate(DateUtils.parseDate(strFechaFormalizacion, DateUtils.FORMATO_FECHA_CORTO), "yyyyMMdd"));
        final BigDecimal bidTipoGarantia = contextoSolicitud.getBigDecimal(CMPO_CTXTO_SOL_TIPO_GARANTIA);
        final BigDecimal bidGarantia;
        if (Constantes.CTE_EXPEDIENTE_EN_GARANTIA.equals(bidTipoGarantia)) {
            bidGarantia = contextoSolicitud.getBigDecimal(CMPO_CTXTO_SOL_GARANTIA_CONTABLE);
        } else {
            bidGarantia = contextoSolicitud.getBigDecimal(CMPO_CTXTO_SOL_GARANTIA_OFICINA);
        }
        IContexto contextoProgramaCorretaje = ContextoFactory.getInstance().getContexto(ID_CTXTO_PROG_CORRETAJE);
        contextoProgramaCorretaje.put(ANPMN073_DIVISA, strDivisa);
        contextoProgramaCorretaje.put(ANPMN073_IMP_CONCEDIDO, bidImporte);
        contextoProgramaCorretaje.put(ANPMN073_PLAZO_CONCEDIDO, bidPlazo);
        contextoProgramaCorretaje.put(ANPMN073_FECHA_CONCESION, bidFechaFormalizacion);
        contextoProgramaCorretaje.put(ANPMN073_GARANTIA, bidGarantia);
        if (null != contextoSolicitud.getBigDecimal("ANPMN050010") && null != contextoSolicitud.getBigDecimal("ANPMN050020") && null != contextoSolicitud.getBigDecimal("ANPMN050030") && null != contextoSolicitud.getBigDecimal("ANPMN050040")) {
            contextoProgramaCorretaje.put(ANPMN073_OFICINA, contextoSolicitud.getBigDecimal("ANPMN050010"));
            contextoProgramaCorretaje.put(ANPMN073_NUMERO, contextoSolicitud.getBigDecimal("ANPMN050020"));
            contextoProgramaCorretaje.put(ANPMN073_VERSION, contextoSolicitud.getBigDecimal("ANPMN050030"));
            contextoProgramaCorretaje.put(ANPMN073_NUC, contextoSolicitud.getBigDecimal("ANPMN050040"));
        }
        CtgFacade ctg = new CtgFacade();
        return ctg.invocarProgramaCics(contextoProgramaCorretaje, ID_PROG_CORRETAJE);
    }

    /**
     * Consulta el código del documento en la tabla de Parametros (CAG.AN82TB01)
     * @param e
     */
    // 05-09-2013 - G000895
    public static String obtenerCodigoDocumento(int tipoImpresion) {
        String codigoDocumento = "";
        // Consultamos el valor del porcentaje del seguro de fluctuacion de la tabla de parametros
        final IDatosEntradaTx datosEntradaConsultaParametroSrv = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), Constantes.ID_CUENTA_ANPM, IConstantesTramitacion.CTE_CO_CONSULTA_PARAMETRO);
        datosEntradaConsultaParametroSrv.addCampo(IConstantesTramitacion.NOMBRE_CAMPO_PARAMETRO, obtieneClaveImpresion(tipoImpresion));
        // Llamada al servicio ANPM_180: Recuperamos el valor del parametro correspondiente de la agrupacion GEST_DOCUM
        // Contexto Parametros: ANPMN080
        final IContexto[] aContextoParametro = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaConsultaParametroSrv);
        if (null != aContextoParametro && 0 != aContextoParametro.length && aContextoParametro[0].getNombre().equals(IConstantesTramitacion.CTXTO_PARAMETRO) && !Helper.isNullOrEmpty(aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR))) {
            codigoDocumento = aContextoParametro[0].getString(IConstantesTramitacion.CTXTO_PARAMETRO_VALOR);
        }
        return codigoDocumento;
    }

    /**
     * Método auxiliar para obtener el tipo de impresión en texto
     * @param tipoImpresion
     * @return
     */
    private static String obtieneClaveImpresion(int tipoImpresion) {
        String nombreParametro = "";
        switch(tipoImpresion) {
            case INFO_PREVIA:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_INFO_PREVIA;
                break;
            case INFORMACION_NORMALIZADA_EUROPEA:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_INFO_PREVIA;
                break;
            case FIPER:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_FIPER;
                break;
            case POLIZA:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_POLIZA;
                break;
            case OFERTA_VINCULANTE:
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_OV;
                break;
            case DOC_INTERNO_MINUTA:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_DOC_INTERNO_MINUTAR;
                break;
            case RECIBO_FORMALIZACION:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_RECIBO_FORMALIZACION;
                break;
            case CONTRATO_CREDIVENTAS:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_POLIZA;
                break;
            case TABLA_PAGOS:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_TABLA_PAGOS;
                break;
            case OV_MOVIL:
                nombreParametro = IConstantesTramitacion.VALOR_PARAMETRO_CODIGO_OV_MOVIL;
                break;
        }
        return nombreParametro;
    }

    // /**
    // * Comprueba si la solicitud entra por solicitud-contrato, para ello invoca el servicio ANPM_441
    // * 20150324 Ahora el ANPM_441 comprueba otra cosa diferente: comprueba si la solicitud
    // * tiene tramos variables no referenciados, por lo tanto ya no nos vale, porque el criterio que
    // * se maneja aquí sigue siendo el mismo, es decir que la solicitud entre por Solicitud-Contrato.
    // *
    // *@param solicitud
    // *
    // * 20151123 optimización de códio
    // */
    // public static boolean solicitudVaPorSolicitudContrato(DatosSolicitudC solicitud)
    // {
    // boolean vaPorSolicContr = false;
    // IDatosEntradaTx datosEntrada = null;
    // IContexto[] resultado = null;
    // IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
    // 
    // datosEntrada = ServicioNegocio.getPrograma(
    // contextoEjecucion,
    // Constantes.CTE_SN_COMPR_SOLIC_CONTR_CC,
    // Constantes.CTE_SN_COMPR_SOLIC_CONTR_CO);
    // 
    // datosEntrada.addCampo(Constantes.CTE_SN_COMPR_SOLIC_ENT_OFI_SOLIC, solicitud.getDatosSolicitudKey().getOficinaSolicitud());
    // datosEntrada.addCampo(Constantes.CTE_SN_COMPR_SOLIC_ENT_NUM_SOLIC, solicitud.getDatosSolicitudKey().getNumSolicitud());
    // datosEntrada.addCampo(Constantes.CTE_SN_COMPR_SOLIC_ENT_VER_SOLIC, solicitud.getDatosSolicitudKey().getVersionSolicitud());
    // datosEntrada.addCampo(Constantes.CTE_SN_COMPR_SOLIC_ENT_NUC_EXPEDIENTE, solicitud.getDatosSolicitudKey().getNucExpediente());
    // 
    // resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
    // 
    // if (! UtilidadesTramitacion.isBlankOrNull(resultado))
    // {
    // if (Constantes.CTE_STR_S.equals(resultado[0].getString(Constantes.CTE_SN_COMPR_SOLIC_SAL_IND_SOLIC_CONTR)))
    // {
    // vaPorSolicContr = true;
    // }
    // }
    // 
    // return vaPorSolicContr;
    // }
    /**
     * Método que comprueba si una solicitud cumple el compromiso 24 H o no.
     * Para ello invoca el servicio EEXP_998
     *
     * @param oficina
     * @param numero
     * @param version
     * @param nuc
     * @return
     */
    private boolean cumpleCompromiso(BigDecimal nuc) {
        IDatosEntradaTx datosEntrada = null;
        IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
        IContexto[] resultado = null;
        boolean cumpleCompromiso = false;
        /*Obtenemos el compromiso*/
        datosEntrada = ServicioNegocio.getPrograma(contextoEjecucion, CTE_SN_COMPROMISO_CC, CTE_SN_COMPROMISO_CO);
        datosEntrada.addCampo(CTE_SN_COMPROMISO_ENT_OPER, "C");
        // En EEXP, ConsultaExpCompromisoSrv:
        // - 'C' se consulta solo si el expediente es tipo compromiso y si cumple o no el compromiso y los datos del inicio y fin del compromiso
        datosEntrada.addCampo(CTE_SN_COMPROMISO_ENT_NUC, nuc);
        resultado = ServicioNegocio.invocarServicio(contextoEjecucion, datosEntrada);
        if (!UtilidadesTramitacion.isBlankOrNull(resultado)) {
            if (Constantes.CTE_STR_S.equals(resultado[0].getString(CTE_SN_COMPROMISO_SAL_IND_EXP_COMPR))) {
                /*20150205 Si nos llega una N --> guardamos un 2 (no cumple), caso contrario: 1 (cumple)*/
                if (Constantes.CTE_STR_N.equals(resultado[0].getString(CTE_SN_COMPROMISO_SAL_IND_CUMPLE_COMPR))) {
                    cumpleCompromiso = false;
                } else {
                    cumpleCompromiso = true;
                }
            }
        }
        return cumpleCompromiso;
    }

    /**
     * Comprueba si debe anularse o no la comision de apertura, en funcion del tipo
     * de prescriptor de la solicitud y del indicador de condonacion de comision de
     * apertura almacenado en la tabla CAG.AN82TB01 para el producto.
     * <br>
     * La comprobacion se realiza de la siguiente manera:
     * <ul>
     * <li>Si tipo prescriptor = 0 o 9: comportamiento por defecto (se condona)</li>
     * <li>Si tipo prescriptor = 2: se lee el indicador de condonacion de BD (AN82TB01)
     *     para el producto:
     * 	   <ul>
     * 	   <li>Si no hay registros: se condona (por defecto)</li>
     *     <li>Si indicador = "N": no se condona</li>
     *     <li>Si indicador != "N": se condona (por defecto)</li>
     * 	   </ul>
     * </li>
     * </ul>
     *
     * @param datosSolicitud datos de la solicitud
     * @return true si debe anularse la comision de apertura, false si no debe anularse.
     */
    private boolean compruebaAnularComisionApertura(DatosSolicitudC datosSolicitud) {
        // Inicializaciones
        // Por defecto se condona la comision
        boolean anularComision = true;
        BigDecimal tipoPrescriptor = datosSolicitud.getTipoPrescriptor();
        String producto = datosSolicitud.getProducto().toString();
        // Comprobar si se anula o no la comision de apertura
        if (tipoPrescriptor.equals(Constantes.CTE_TIPO_PRESCRIPTOR_EXTERNO)) {
            // Prescriptor externo (2): se condona o no en funcion de indicador
            String indCondonaComisionApertura = null;
            // llamamos a la tabla AN82TB01 para saber si se condona o no la comisión de apertura
            indCondonaComisionApertura = UtilidadesTramitacion.obtenerParametroUnicoANPM(Constantes.CTE_AGRUPACION, producto);
            if (StringUtils.isNotBlank(indCondonaComisionApertura)) {
                if (indCondonaComisionApertura.equals(Constantes.CTE_STR_N)) {
                    // Indicador = "N": no se condona
                    anularComision = false;
                }
            // Indicador = "S": se condona (por defecto)
            }
        // Indicador = Nulo o blanco: se condona (por defecto)
        }
        return anularComision;
    }

    /**
     * Método que anula la comisión de apertura de una solicitud.
     * Además actualiza el cambio en la tabla de comisiones, AN28TB01.
     *
     * @param datosSolicitud
     */
    private void anularComisionApertura(DatosSolicitudC datosSolicitud) {
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        List<ComisionC> comisiones = null;
        /*20150224 Rosa: "en el caso de que no se cumpla el compromiso, es decir cuando guardamos un 2 en
		 *  ese campo tenemos que poner a 0 los campos del porcentaje y el importe mínimo de la comisión 
		 *  de apertura.  ( Son los campos AN280070 Y AN280090 para el tipo de comisión = 003)"*/
        /*20150226 Se comenta porque se va a hacer en Host*/
        /*20150227 Se descomenta porque se va a hacer aqui PERO en la versión nueva que acabamos de generar.*/
        comisiones = datosSolicitud.getComisiones();
        for (ComisionC comision : comisiones) {
            if (Constantes.TIPO_COMISION_APERTURA.equals(comision.getComisionesKey().getStrTipoComision())) {
                comision.setBidPorcentajeComision(BigDecimal.ZERO);
                comision.setBidImporteMinimo(BigDecimal.ZERO);
            }
        }
        gds.updateSolicitud(datosSolicitud);
    }

    /**
     * Método que comprueba el número y tipo de cuentas de la solicitud
     *
     * @param datosSolicitud
     */
    private void comprobarCuentas(DatosSolicitudC datosSolicitud) {
        boolean tieneCuentaAbono = false;
        boolean tieneCuentaCargo = false;
        List<DatosCuentasC> cuentas = null;
        BigDecimal nuc = null;
        nuc = datosSolicitud.getDatosSolicitudKey().getNucExpediente();
        cuentas = datosSolicitud.getCuentas();
        /*Sólo puede haber dos, una de cargo y una de abono.*/
        if (Constantes.CTE_INT_DOS >= cuentas.size()) {
            for (DatosCuentasC cuenta : cuentas) {
                if (Constantes.CTE_TIPO_CUENTA_CONTABLE.equals(cuenta.getTipoCuenta())) {
                    tieneCuentaCargo = true;
                } else if (Constantes.CTE_TIPO_CUENTA_ABONO.equals(cuenta.getTipoCuenta())) {
                    tieneCuentaAbono = true;
                }
            }
            if (!tieneCuentaCargo || !tieneCuentaAbono) {
                UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_POLIZA_MULTICREDITO_NO_CUENTAS, datosSolicitud);
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_POLIZA_MULTICREDITO_NO_CUENTAS, null, new String[] { nuc.toString() }, null);
            }
        } else {
            UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_POLIZA_MULTICREDITO_MAS_DOS_CUENTAS, datosSolicitud);
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_POLIZA_MULTICREDITO_MAS_DOS_CUENTAS, null, new String[] { nuc.toString() }, null);
        }
    }

    /**
     * Actualiza (a día de hoy) la fecha impresión del documento que se indica como parámetro de entrada
     * @param oficina
     * @param numero
     * @param version
     * @param nuc
     * @param tipoImpresion
     */
    // 10-09-2013 - G000895
    private boolean actualizarFechaImpresion(DatosSolicitudC datosSolicitud, int tipoImpresion, IContexto contextoAmortizacion) {
        boolean exito = false;
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        final String strCtxtoAmortFechaImprPoliza = "ANPMN075540";
        String fechaImpresionPolizaStr = null;
        Date fechaImpresionPoliza = null;
        switch(tipoImpresion) {
            case FIPER:
                datosSolicitud.setDateFechaImpresionFipper(DateUtils.toSQLDate(DateUtils.dateNow()));
                break;
            case POLIZA:
                // datosSolicitud.setFechaValorFirma(DateUtils.toSQLDate(DateUtils.dateNow()));
                /*Si nos viene informada el campo ANPMN075540 con la fecha impresión de la poliza actualizamos la columna AN251070*/
                fechaImpresionPolizaStr = contextoAmortizacion.getString(strCtxtoAmortFechaImprPoliza);
                if (!StringUtils.isBlank(fechaImpresionPolizaStr)) {
                    fechaImpresionPoliza = DateHelper.stringASqlDate(fechaImpresionPolizaStr, DateHelper.FORMATO_YYYY_MM_DD_GUION);
                    datosSolicitud.setFechaValorFirma(fechaImpresionPoliza);
                }
                break;
            case INFO_PREVIA:
                datosSolicitud.setDateFechaImpresion(DateUtils.toSQLDate(DateUtils.dateNow()));
                break;
            case INFORMACION_NORMALIZADA_EUROPEA:
                datosSolicitud.setDateFechaImpresion(DateUtils.toSQLDate(DateUtils.dateNow()));
                break;
            case OFERTA_VINCULANTE:
                datosSolicitud.setDateFecha2(DateUtils.toSQLDate(DateUtils.dateNow()));
                break;
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                datosSolicitud.setDateFecha2(DateUtils.toSQLDate(DateUtils.dateNow()));
                break;
        }
        final ResultadoDatosSolicitudVO resultado = gds.updateSolicitud(datosSolicitud);
        if (resultado.getCodError() != 0) {
            exito = false;
        } else {
            exito = true;
        }
        return exito;
    }

    /**
     * Actualiza el valor del campo TAE (AN250990)
     * @param oficina
     * @param numero
     * @param version
     * @param nuc
     * @param bidTAE
     */
    // 07-11-2013 - G000895
    private boolean actualizarTAE(DatosSolicitudC datosSolicitud, BigDecimal bidTAE, IContexto ctxProgAmortizacion, Date fechaUltimoVencimiento) {
        String strAmortizacionCapital = "ANPMN075550";
        boolean exito = false;
        // 20151123 Optimización de código para reducir
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        // DatosSolicitudC datosSolicitud = gds.obtenerDatosSolicitud(oficina, numero,
        // version, nuc);
        // Asignamos el dato de la TAE a la solicitud (campo AN250990)
        datosSolicitud.setTAE(bidTAE);
        if (!UtilidadesTramitacion.isBlankOrNull(ctxProgAmortizacion.getBigDecimal(strAmortizacionCapital))) {
            datosSolicitud.setBidImporte2(ctxProgAmortizacion.getBigDecimal(strAmortizacionCapital));
        }
        // por ahora sólo para ASF
        if (UtilidadesComun.esASF(datosSolicitud.getEntidad())) {
            // corrección 30-01-2018: sólo cuando el indicador de periodo minimo de liquidación es 2 tanto en capital como interes
            Boolean indPeriodoMinEs2 = Boolean.TRUE;
            // miramos si hay algún indicador distinto de 2 para condiciones de interés
            List<CondicionesInteresC> lstCondicionesInteres = datosSolicitud.getCondicionesInteres();
            if ((null != lstCondicionesInteres) && (0 < lstCondicionesInteres.size())) {
                for (CondicionesInteresC condicionInteres : lstCondicionesInteres) {
                    if (!(condicionInteres.getIntIndPeriodoMinimoLiquidacion().compareTo(Constantes.CTE_DOS) == 0)) {
                        indPeriodoMinEs2 = Boolean.FALSE;
                        break;
                    }
                }
            }
            // miramos si hay algún indicador distinto de 2 para condiciones de capital
            if (indPeriodoMinEs2) {
                List<CondicionCapitalC> condicionesCapital = datosSolicitud.getCondicionesCapital();
                if ((null != condicionesCapital) && (0 < condicionesCapital.size())) {
                    for (CondicionCapitalC condicionCapital : condicionesCapital) {
                        if (!(condicionCapital.getIntIndPeriodoMinimoLiquidacion().compareTo(Constantes.CTE_DOS) == 0)) {
                            indPeriodoMinEs2 = Boolean.FALSE;
                            break;
                        }
                    }
                }
            }
            if (indPeriodoMinEs2) {
                if (UtilidadesComun.esASF(datosSolicitud.getEntidad())) {
                    if (!Helper.isNullOrEmpty(fechaUltimoVencimiento)) {
                        Calendar calendar = Calendar.getInstance();
                        calendar.setTime(fechaUltimoVencimiento);
                        // Calendar.DAY_OF_MONTH,1
                        calendar.add(Calendar.DATE, -1);
                        java.sql.Date fechaVencimientoFinal = new java.sql.Date(calendar.getTime().getTime());
                        datosSolicitud.setFechaVencimientoFinal(fechaVencimientoFinal);
                    }
                }
            }
        }
        // final ResultadoDatosSolicitudVO resultado = gds.guardarSolicitud(datosSolicitud);
        final ResultadoDatosSolicitudVO resultado = gds.updateSolicitud(datosSolicitud);
        if (resultado.getCodError() != 0) {
            exito = false;
        } else {
            exito = true;
        }
        return exito;
    }

    /**
     * Método provisional para obtener la fecha de ultima entrega y la ultima cuota
     * antes de que se sobreescriba el registro de pagos en el que están.
     * Esto ocurre en ContextoImpresionFiper_OVHipotecarios.anhadirRegistroAnual(..).
     *
     * @param contextoAmortizacion
     */
    private void obtenerCamposCtxAmortPorPosteriorSobreescritura(IContexto contextoAmortizacion) {
        String fechaUltimaEntregaStr = null;
        String fechaPrimerPagoStr = null;
        String fechaPrimeraEntregaStr = null;
        final String strCtxtoRegMatrizPago = "ANPMN075140";
        final String strCtxtoCmpoRegPagoFchPago = "ANPMN075142";
        final String strCtxtoCmpoRegPagoImpCapital = "ANPMN075143";
        final String strCtxtoCmpoRegPagoImpInteres = "ANPMN075144";
        final String strCtxtoCmpoRegPagoImpTotal = "ANPMN075145";
        IRegistro primeraEntrega = null;
        IRegistro primerPago = null;
        IRegistro ultimaEntrega = null;
        if (contextoAmortizacion != null) {
            final IRegistro[] aRegPagos = contextoAmortizacion.getRegistro(strCtxtoRegMatrizPago);
            if (0 != aRegPagos.length) {
                for (int i = aRegPagos.length - 1; i >= 0 && ultimaEntrega == null; i--) {
                    if (BigDecimal.ZERO.compareTo(aRegPagos[i].getBigDecimal(strCtxtoCmpoRegPagoImpCapital)) != 0) {
                        ultimaEntrega = aRegPagos[i];
                    }
                }
                for (IRegistro registroActual : aRegPagos) {
                    if (BigDecimal.ZERO.compareTo(registroActual.getBigDecimal(strCtxtoCmpoRegPagoImpCapital)) != 0) {
                        primeraEntrega = registroActual;
                        break;
                    }
                }
                for (IRegistro registroActual : aRegPagos) {
                    if (BigDecimal.ZERO.compareTo(registroActual.getBigDecimal(strCtxtoCmpoRegPagoImpInteres)) != 0) {
                        primerPago = registroActual;
                        break;
                    }
                }
                if (null != ultimaEntrega) {
                    // 23-07-2012. Incorporación del importe de la última entrega para mostrarlo en la póliza.
                    /*ctxtImpresion.put(ID_PROP_CUOTA_INICIAL, 
							UtilidadesTramitacion.bigDecimalToString(
									ultimaEntrega.getBigDecimal(strCtxtoCmpoRegPagoImpCapital), 13, 2, Boolean.FALSE));
					*/
                    // cuotaInicial = ultimaEntrega.getBigDecimal(strCtxtoCmpoRegPagoImpCapital);
                    fechaUltimaEntregaStr = ultimaEntrega.getString(strCtxtoCmpoRegPagoFchPago);
                    fechaUltimaEntrega = DateHelper.stringASqlDate(fechaUltimaEntregaStr, DateHelper.FORMATO_DD_MM_YYYY_GUION);
                    ultimaCuota = ultimaEntrega.getBigDecimal(strCtxtoCmpoRegPagoImpTotal);
                }
                if (null != primeraEntrega) {
                    // 23-07-2012. Incorporación del importe de la última entrega para mostrarlo en la póliza.
                    /*ctxtImpresion.put(ID_PROP_CUOTA_INICIAL, 
							UtilidadesTramitacion.bigDecimalToString(
									ultimaEntrega.getBigDecimal(strCtxtoCmpoRegPagoImpCapital), 13, 2, Boolean.FALSE));
					*/
                    // cuotaInicial = ultimaEntrega.getBigDecimal(strCtxtoCmpoRegPagoImpCapital);
                    fechaPrimeraEntregaStr = primeraEntrega.getString(strCtxtoCmpoRegPagoFchPago);
                    fechaPrimeraEntrega = DateHelper.stringASqlDate(fechaPrimeraEntregaStr, DateHelper.FORMATO_DD_MM_YYYY_GUION);
                }
                if (null != primerPago) {
                    // 23-07-2012. Incorporación del importe de la última entrega para mostrarlo en la póliza.
                    /*ctxtImpresion.put(ID_PROP_CUOTA_INICIAL, 
							UtilidadesTramitacion.bigDecimalToString(
									ultimaEntrega.getBigDecimal(strCtxtoCmpoRegPagoImpCapital), 13, 2, Boolean.FALSE));
					*/
                    // cuotaInicial = ultimaEntrega.getBigDecimal(strCtxtoCmpoRegPagoImpCapital);
                    fechaPrimerPagoStr = primerPago.getString(strCtxtoCmpoRegPagoFchPago);
                    fechaPrimerPago = DateHelper.stringASqlDate(fechaPrimerPagoStr, DateHelper.FORMATO_DD_MM_YYYY_GUION);
                }
            }
        }
    }

    /*
	
	private static String obtenerNombreFichero(BigDecimal nuc)
	{
		String nombreFichero = StringUtils.EMPTY;
		StringBuilder stb = new StringBuilder(1);
		
		Timestamp timestamp = DateHelper.getInstance().askTimestampFromDB2();
		
		stb = stb.append(nuc.toString());
		stb = stb.append("-");
		stb = stb.append(DateHelper.timestampToString(timestamp, DateHelper.FORMATO_DB2_TIMESTAMP));
		
		nombreFichero = stb.toString();
		return nombreFichero;
	}
	*/
    private IContexto[] consultarGastosAdicionales(IContexto contextosSolicitud, String tipoExpediente, String fechaInicioExpediente, IContexto[] aCtxtoIntereses, int tipoImpresion) {
        IContexto[] resultadoGastosAdic = new IContexto[0];
        GastosAdicionalesEng gastosAdicionalesDao = new GastosAdicionalesEng();
        List<GastosAdicionalesC> listaGastosAdic = null;
        GastosAdicionalesC gastosAdicionalesC = null;
        GastosAdicionalesKey gastosAdicionalesKey = null;
        final Date fechaMinima = new Date(DateUtils.dateLowest().getTime());
        List<BigDecimal> listaIdGastos = new ArrayList<BigDecimal>(1);
        BigDecimal idConcepto = null;
        String descrConcepto = null;
        BigDecimal oficina = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_OFICINA);
        BigDecimal numeroSol = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUMERO);
        BigDecimal version = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION);
        BigDecimal nuc = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUC);
        BigDecimal importeSolicTotal = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_IMP_TOTAL);
        String divImporteSolic = contextosSolicitud.getString(CAMPO_CTXTO_SOL_DIV_IMP_SOL);
        BigDecimal plazoSolic = contextosSolicitud.getBigDecimal(CMPO_CTXTO_SOL_PLAZO);
        String unidadPlazoSolic = contextosSolicitud.getString(CAMPO_CTXTO_SOL_UNIDAD_PLAZO);
        BigDecimal codProducto = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_IDPRODUCTO);
        BigDecimal codSubproducto = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_SUBPRODUCTO);
        BigDecimal versionGeneral = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION_GENERAL);
        /*20150929 Obtenemos el id tarifa del contexto de solicitud*/
        BigDecimal idTarifa = contextosSolicitud.getBigDecimal(CTE_DAT_SOL_ID_TARIFA);
        // 2016-12-01 - Obtener el colectivo del contexto de solicitud
        BigDecimal idColectivo = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_COD_COLECTIVO);
        // boolean esValidoCargoTarjeta = UtilidadesTramitacion.compruebaValidezCargoTarjeta(nuc);
        boolean esValidoCargoTarjeta = UtilidadesTramitacion.compruebaValidezCargoTarjeta(fechaInicioExpediente);
        BigDecimal periodosARestar = BigDecimal.ZERO;
        final List<ParametroC> listaParamPeriodosRestar = GestionParametro.obtenerParametros(null, "GASTOSADIC");
        // 2016-05-18 - Solo se llama al CPSI_001 si pasa el control de operatoria
        if (UtilidadesTramitacion.comprobarControlOperatoria(nuc, new BigDecimal(150014), true) && !esPreconcedido) {
            IDatosEntradaTx datosEntradaGastosAdic = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), CTE_SN_CC_GASTOS_ADIC, CTE_SN_CO_GASTOS_ADIC);
            // 2016-12-22- Si el prestamo es en divisa y es hipotecario, en necesario contravalorar
            // el importe antes de llamar al CPSI_001.
            boolean esDivisa = UtilidadesTramitacion.esDivisaPorEspecialidad(contextosSolicitud.getString(CAMPO_CTXTO_SOL_ESPECIALIDAD));
            boolean esHipotecario = Constantes.CTE_STR_H.equals(tipoExpediente);
            if (esDivisa && esHipotecario) {
                importeSolicTotal = UtilidadesTramitacion.calcularContravalor(divImporteSolic, importeSolicTotal, Constantes.CTE_DIVISA_EURO.toUpperCase());
            }
            datosEntradaGastosAdic.addCampo("IMPORTE_SOLICITADO", importeSolicTotal);
            datosEntradaGastosAdic.addCampo("PLAZO", plazoSolic);
            datosEntradaGastosAdic.addCampo("UNIDAD_PLAZO", unidadPlazoSolic);
            if (Constantes.CTE_STR_P.equals(tipoExpediente)) {
                // H: Hipotecario, P: Personal.
                datosEntradaGastosAdic.addCampo("TIPO_PRESTAMO", tipoExpediente);
            }
            datosEntradaGastosAdic.addCampo("ID_PRODUCTO", codProducto);
            datosEntradaGastosAdic.addCampo("ID_SUBPRODUCTO", codSubproducto);
            datosEntradaGastosAdic.addCampo("APLICAN_TAE", Constantes.NO);
            datosEntradaGastosAdic.addCampo("NUC", nuc);
            if (null != idTarifa) {
                datosEntradaGastosAdic.addCampo("ID_TARIFA", idTarifa);
            }
            // Si es hipotecario se comprueba si es consumidor a través del ANPM_481
            if (esHipotecario) {
                // Llamada al ANPM_481
                IDatosEntradaTx entrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 507, 481);
                entrada.addCampo("NUC", nuc);
                IContexto[] salida = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
                if (null != salida && 0 < salida.length) {
                    BigDecimal consumidor = salida[0].getBigDecimal("ANPMN481010");
                    if (null != consumidor) {
                        datosEntradaGastosAdic.addCampo("INDICADOR_CONSUMIDOR", consumidor);
                    }
                }
            }
            // Llamada al CPSI_001
            resultadoGastosAdic = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaGastosAdic);
            /*Guardamos los gastos adicionales en la tabla AN44TB01, mapeada en la
			 * clase persistente GastosAdicionalesC */
            /*Comprobamos si ya existen*/
            listaGastosAdic = gastosAdicionalesDao.obtenerGastosAdic(oficina, numeroSol, version, nuc);
            /*20150929 Obtenemos los indicadores de aplica TAE para el gasto adicional en el que aplique la relación con máxima prioridad, AN87TB01*/
            AplicaTaeC aplicaTaeRelacionMaxPrioridad = GestionTae.obtenerAplicaTaePorRelacionMaxPrioridad(codProducto, codSubproducto, idTarifa);
            /* 2016-06-06 - INI - Para operaciones con parrilla distinta de nueva (tipo parrilla <> 2),
			   el indicador de TAE bonificada debe ponerse a cero, para los gastos con id concepto 16 o 17 */
            // Obtener plazo tramo inicial
            BigDecimal plazoTramoInicial = null;
            if ((null != aCtxtoIntereses) && (0 < aCtxtoIntereses.length)) {
                for (IContexto ctxInteres : aCtxtoIntereses) {
                    if (0 == ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_INTERES_ORDEN).compareTo(BigDecimal.ONE) && 0 == ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_TIPO_CONDICION).compareTo(BigDecimal.ZERO)) {
                        // Plazo del tramo inicial
                        plazoTramoInicial = ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_INTERES_PLAZO);
                        break;
                    }
                }
            }
            // Consulta AN19TB01 por producto, subproducto, tarifa, version general, plazo tramo inicial
            // para obtener el tipo de parrilla de la operacion (AN190150).
            CampanhaEng campanhaEng = new CampanhaEng();
            CampanhaC campanha = campanhaEng.obtenerCampanha(codProducto, codSubproducto, idTarifa, versionGeneral, plazoTramoInicial);
            String tipoParrilla = "";
            if (null != campanha) {
                tipoParrilla = campanha.getParrillaInd();
            }
            /*20151030 Vamos a recuperar todos los ids de gasto adicional que nos envíe simulación*/
            for (IContexto ctxGastosAdic : resultadoGastosAdic) {
                idConcepto = new BigDecimal(ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_ID_CONCEPTO));
                listaIdGastos.add(idConcepto);
            }
            if (UtilidadesTramitacion.isBlankOrNull(listaGastosAdic)) {
                /*Insertamos los datos del array de contextos CPSIN001 en la tabla AN44TB01*/
                for (IContexto ctxGastosAdic : resultadoGastosAdic) {
                    gastosAdicionalesC = gastosAdicionalesDao.createNewObject();
                    gastosAdicionalesKey = new GastosAdicionalesKey();
                    gastosAdicionalesKey.setOficinaSolicitud(oficina);
                    gastosAdicionalesKey.setNumeroSolicitud(numeroSol);
                    gastosAdicionalesKey.setVersionSolicitud(version);
                    gastosAdicionalesKey.setNucExpediente(nuc);
                    /*Recuperamos datos del contexto de gastos adicionales*/
                    idConcepto = new BigDecimal(ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_ID_CONCEPTO));
                    descrConcepto = ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_DESCR_CONCEPTO).trim();
                    if (0 == Constantes.CTE_BID_6.compareTo(idConcepto) && null != ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTINENTE) && null != ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTENIDO)) {
                        solicitud.setContinente(ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTINENTE));
                        solicitud.setContenido(ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTENIDO));
                        contextosSolicitud.put(CTE_CONTINENTE, solicitud.getContinente());
                        contextosSolicitud.put(CTE_CONTENIDO, solicitud.getContenido());
                    }
                    if (0 == Constantes.CTE_BID_7.compareTo(idConcepto)) {
                        if (!esValidoCargoTarjeta) {
                            // Si no podemos persistir el concepto numero siete pasamos a la siguiente iteracion
                            continue;
                        }
                    }
                    BigDecimal importeTotalSimulacion = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                    // a la divisa del prestamo. En la AN44TB01 se guardara el importe contravalorado.
                    if (esDivisa && esHipotecario) {
                        importeTotalSimulacion = UtilidadesTramitacion.calcularContravalor(Constantes.CTE_DIVISA_EURO.toUpperCase(), importeTotalSimulacion, divImporteSolic);
                    }
                    BigDecimal numPeriodosGasto = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_NUM_PERIODOS);
                    if (0 == BigDecimal.ZERO.compareTo(numPeriodosGasto)) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_GASTO_ADICIONAL_NUM_PER_CERO, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_GASTO_ADICIONAL_NUM_PER_CERO, null, new String[] { nuc.toString() }, null);
                    }
                    BigDecimal porcentAct = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_FACTOR_ACT);
                    /*Simulación nos manda siempre el importe total del gasto adicional que paga el cliente durante la vida del préstamo.*/
                    /*Si la periodicidad es un mes guardamos el importe total de simulación*/
                    /*Buscamos el número de períodos a restar de este gasto adicional*/
                    periodosARestar = UtilidadesTramitacion.consultaNumeroPeriodosRestar(listaParamPeriodosRestar, idConcepto);
                    BigDecimal importeGuardar = UtilidadesTramitacion.calcularImporteGastoAdicional(importeTotalSimulacion, idConcepto, plazoSolic, numPeriodosGasto, periodosARestar);
                    gastosAdicionalesKey.setIdConcepto(idConcepto);
                    gastosAdicionalesC.setId(gastosAdicionalesKey);
                    gastosAdicionalesC.setDescripcionConcepto(descrConcepto);
                    gastosAdicionalesC.setImporte(importeGuardar);
                    gastosAdicionalesC.setMoneda(divImporteSolic);
                    gastosAdicionalesC.setNumPeriodicidad(numPeriodosGasto);
                    gastosAdicionalesC.setUnidadPeriodicidad(Constantes.CTE_UNIDAD_PERIODO_MES);
                    gastosAdicionalesC.setPorcentajeActualizacion(porcentAct);
                    gastosAdicionalesC.setUsuario(ServicioNegocio.getContexto().getUsuario());
                    gastosAdicionalesC.setTimestamp(DateHelper.getInstance().askTimestampFromDB2());
                    gastosAdicionalesC.setImporteRecibido(importeGuardar);
                    gastosAdicionalesC.setEsEstimado(Constantes.CTE_STRING_BLANK);
                    gastosAdicionalesC.setPeriodosRestar(periodosARestar);
                    gastosAdicionalesC.setFecha1(DateUtils.toSQLDate(fechaMinima));
                    gastosAdicionalesC.setString1(Constantes.CTE_STRING_BLANK);
                    gastosAdicionalesC.setString2(Constantes.CTE_STRING_BLANK);
                    /*20150928 Para saber si aplica la TAE normal y la TAE bonificada consultamos en la AN87TB01*/
                    // en esta tabla guardaremos los indicadores para saber si, el concepto de gasto adicional de este subproducto
                    // se va a utilizar para calcular la TAE normal y la TAE bonificada, cada una en indicadores diferentes.
                    AplicaTaeC aplicaTaeC = GestionTae.obtenerAplicaTaePorId(codProducto, codSubproducto, idTarifa, idConcepto);
                    // Para este concepto tiene que estar en la tabla, sino  lanzamos un rollback.
                    if (null == aplicaTaeC) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_GASTO_ADIC_TABLA_TAE, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_GASTO_ADIC_TABLA_TAE, null, new String[] { idConcepto.toString(), idTarifa.toString(), codProducto.toString() + ":" + codSubproducto.toString() }, null);
                    }
                    /*Si aplica relación*/
                    if (0 == BigDecimal.ONE.compareTo(aplicaTaeC.getRelacion())) {
                        // si el que obtenemos tiene la misma prioridad que el de máxima prioridad entonces es el mismo: criterios TAEs iguales.
                        if (0 == aplicaTaeRelacionMaxPrioridad.getPrioridad().compareTo(aplicaTaeC.getPrioridad())) {
                            gastosAdicionalesC.setAplicaTAENormal(aplicaTaeRelacionMaxPrioridad.getTaeNormal().toString());
                            gastosAdicionalesC.setAplicaTAEBonificada(aplicaTaeRelacionMaxPrioridad.getTaeBonificada());
                        } else {
                            gastosAdicionalesC.setAplicaTAENormal(Constantes.CTE_STR_0);
                            gastosAdicionalesC.setAplicaTAEBonificada(BigDecimal.ZERO);
                        }
                    } else {
                        gastosAdicionalesC.setAplicaTAENormal(aplicaTaeC.getTaeNormal().toString());
                        gastosAdicionalesC.setAplicaTAEBonificada(aplicaTaeC.getTaeBonificada());
                    }
                    // para que no se tenga en cuenta en el calculo de la TAE.
                    if (!Constantes.CTE_TIPO_PARRILLA_OP_NUEVAS.equals(tipoParrilla.trim())) {
                        if ((new BigDecimal(Constantes.ID_GASTO_PROTECCION_PAGOS_5).compareTo(gastosAdicionalesC.getId().getIdConcepto()) == 0) || (new BigDecimal(Constantes.ID_GASTO_PROTECCION_PAGOS_ANUAL).compareTo(gastosAdicionalesC.getId().getIdConcepto()) == 0)) {
                            gastosAdicionalesC.setAplicaTAEBonificada(BigDecimal.ZERO);
                        }
                    }
                    // 2018-03-05 - Quitar el gasto de tarjeta para colectivos solo si es personal
                    if ((new BigDecimal(Constantes.ID_GASTO_COM_TARJ_CRED).compareTo(gastosAdicionalesC.getId().getIdConcepto()) == 0) && (UtilidadesComun.esPersonal(contextosSolicitud))) {
                        // if ((null != solicitud) && (0 != solicitud.getIdColectivo().compareTo(BigDecimal.ZERO)))
                        if (libreDeTae(nuc, codProducto) || (null != idColectivo && 0 != idColectivo.compareTo(BigDecimal.ZERO))) {
                            gastosAdicionalesC.setAplicaTAENormal(Constantes.CTE_STR_0);
                        }
                    }
                    // Si es 5-GASTO AJD, se guarda el porcentaje responsabilidad hipotecaria
                    if ((0 == Constantes.CTE_BID_5.compareTo(idConcepto)) && null != ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_PORCENTAJE1)) {
                        if (null != ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_PORCENTAJE1)) {
                            gastosAdicionalesC.setPorcRespHipot(ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_PORCENTAJE1));
                        } else {
                            gastosAdicionalesC.setPorcRespHipot(BigDecimal.ZERO);
                        }
                    } else {
                        gastosAdicionalesC.setPorcRespHipot(BigDecimal.ZERO);
                    }
                    gastosAdicionalesDao.insert(gastosAdicionalesC);
                }
            } else {
                /*20151021 Actualizamos los gastos en la AN44TB01 sólo si está la operatoria activada para este expediente.*/
                if (UtilidadesTramitacion.comprobarControlOperatoria(nuc, new BigDecimal(150008), true)) {
                    actualizarGastosAdicionales(nuc, listaGastosAdic, resultadoGastosAdic, esValidoCargoTarjeta, divImporteSolic, codProducto, codSubproducto, plazoSolic, idTarifa, aplicaTaeRelacionMaxPrioridad, listaParamPeriodosRestar, tipoParrilla, contextosSolicitud, idColectivo, esDivisa, esHipotecario);
                }
            }
        }
        return resultadoGastosAdic;
    }

    /**
     * Método que comprueba si la solicitud tiene la comisión de apertura a cero, es decir,
     *  importe mínimo apertura: 0 y porcentaje apertura: 0 %
     *
     * @param solicitud
     * @return
     */
    private boolean comisionAperturaEstaAnulada(DatosSolicitudC solicitud) {
        List<ComisionC> comisiones = null;
        boolean estaAnulada = false;
        comisiones = solicitud.getComisiones();
        for (ComisionC comision : comisiones) {
            if (Constantes.TIPO_COMISION_APERTURA.equals(comision.getComisionesKey().getStrTipoComision())) {
                if ((0 == BigDecimal.ZERO.compareTo(comision.getBidImporteMinimo())) && (0 == BigDecimal.ZERO.compareTo(comision.getBidPorcentajeComision()))) {
                    estaAnulada = true;
                }
            }
        }
        return estaAnulada;
    }

    /**
     * Método que comprueba si se ha impreso la FIPER de la versión actual de la solicitud. Si no se ha impreso
     * se guarda un histórico de impresiones en la AN47TB01.
     *
     * @param tipoImpresion tipo de impresion
     * @param contextoDatosSolicitud contexto ANPMN050 con los datos de solicitud
     * @param contextoAmortizacion contexto ANPMN075 con datos del cuadro de amortización.
     *
     * @param solicitud, objeto persistente de la solicitud mapeado a la AN25TB01, antes de llamar a este método se le modificó el atributo de la fecha
     * impresión del documento correspondiente, la fecha nueva está persistida en tabla pero NO está aún en este objeto que es justo lo que neceistamos
     * que no esté aún, igual que hacemos con el array de contextos contextoDatosSolicitud, que se recuperó antes de actualizar, porque así cuando se imprime
     * por primera vez tenemos que la fecha está aún sin informar si lo recuperamos antes de actualizar.
     */
    private boolean actualizarHistoricoImpresion(GestionDatosSolicitud gds, int tipoImpresion, IContexto contextoDatosSolicitud, IContexto contextoAmortizacion, DatosSolicitudC solicitud, BigDecimal oficinaContable, IContexto[] aCtxtoIntereses, IContexto[] ctxDatosAdicionales) {
        String codOperatoria = null;
        boolean fiperImpresa = false;
        final String strCtxtoCmpoImpInteres = "ANPMN075390";
        BigDecimal interesInicial = BigDecimal.ZERO;
        final String strCtxoCmpoImpValorActualTipoRef = "ANPMN075520";
        BigDecimal valorTipoReferencia = BigDecimal.ZERO;
        Date fechaMaximaValidezDate = null;
        Date fechaHoy = new java.sql.Date(DateHelper.getInstance().askTime().getTime());
        BigDecimal oficina = contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_OFICINA);
        BigDecimal numero = contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUMERO);
        BigDecimal version = contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION);
        BigDecimal nuc = contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUC);
        // oficinaContable = contextoDatosSolicitud.getBigDecimal(CAMPO_CTXTO_OFICINA_CONTABLE);
        // 20150723 - Obtenemos la oficina contable del EEXP_272, hay casos en los que no vale
        // la oficina contable que tenemos en la AN250170.
        // oficinaContable = UtilidadesTramitacion.obtenerOficinaContableEEXP(nuc);
        // 20160205 - La oficina contable viene como parametro de entrada.
        BigDecimal difNoBonificado = null;
        BigDecimal interes = null;
        BigDecimal plazoTramoInicial = null;
        if ((null != aCtxtoIntereses) && (0 < aCtxtoIntereses.length)) {
            for (IContexto ctxInteres : aCtxtoIntereses) {
                if (0 == ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_INTERES_ORDEN).compareTo(BigDecimal.ONE) && 0 == ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_TIPO_CONDICION).compareTo(BigDecimal.ZERO)) {
                    plazoTramoInicial = ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_INTERES_PLAZO);
                    interes = ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_INTERES_INTERES);
                }
                if ((!UtilidadesComun.isTramoFijo(ctxInteres) && (null == difNoBonificado))) {
                    difNoBonificado = ctxInteres.getBigDecimal(ID_CTXTO_CONDICIONES_INTERES_DIF_NO_BONIFICADO);
                }
            }
        }
        BigDecimal taeNoBonificada = solicitud.getTAE();
        BigDecimal taeBonificada = solicitud.getTaeBonificada();
        BigDecimal plazo = solicitud.getPlazoTotal();
        BigDecimal bonificacionMaxima = UtilidadesTramitacion.obtenerBonificacionMaxima(solicitud.getProducto(), solicitud.getSubproducto(), solicitud.getIdTarifa(), nuc, plazoTramoInicial, solicitud.getVersionGeneral());
        BigDecimal difBonifMaxima = null;
        if (null != difNoBonificado) {
            difBonifMaxima = difNoBonificado.subtract(bonificacionMaxima);
        }
        BigDecimal impComisionApertura = BigDecimal.ZERO;
        BigDecimal impGastosEstudio = BigDecimal.ZERO;
        BigDecimal impSeguroHogar = BigDecimal.ZERO;
        BigDecimal tasacion = BigDecimal.ZERO;
        BigDecimal registro = BigDecimal.ZERO;
        BigDecimal notaSimple = BigDecimal.ZERO;
        BigDecimal gestoria = BigDecimal.ZERO;
        BigDecimal importeIAJD = BigDecimal.ZERO;
        BigDecimal tarjeta = BigDecimal.ZERO;
        BigDecimal importeSeguroVida = BigDecimal.ZERO;
        BigDecimal impProtPagos5Anhos = BigDecimal.ZERO;
        BigDecimal impProtPagosAnual = BigDecimal.ZERO;
        BigDecimal notaria = BigDecimal.ZERO;
        for (IContexto ctxGastosAdic : ctxDatosAdicionales) {
            BigDecimal idConcepto = new BigDecimal(ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_ID_CONCEPTO));
            switch(idConcepto.intValue()) {
                case Constantes.ID_GASTO_TASACION:
                    {
                        tasacion = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_REGISTRO:
                    {
                        registro = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_NOTA_SIMPLE:
                    {
                        notaSimple = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_GESTORIA:
                    {
                        gestoria = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_IAJD_HIP:
                    {
                        importeIAJD = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_SEG_HOGAR:
                    {
                        impSeguroHogar = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_SEG_VIDA:
                    {
                        importeSeguroVida = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_PROTECCION_PAGOS_5:
                    {
                        impProtPagos5Anhos = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_PROTECCION_PAGOS_ANUAL:
                    {
                        impProtPagosAnual = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_COM_TARJ_CRED:
                    {
                        tarjeta = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                case Constantes.ID_GASTO_NOTARIA:
                    {
                        notaria = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                        break;
                    }
                default:
                    {
                    }
            }
        }
        switch(tipoImpresion) {
            case FIPER:
                {
                    /*20151021 Vamos a guardar el plazo máximo de validez en el histórico de impresión de la FIPER*/
                    String fechaMaximaValidez = ContextoImpresionFiper_OVHipotecarios.obtenerFechaMaximaValidez(1, contextoDatosSolicitud);
                    if (StringUtils.isBlank(fechaMaximaValidez)) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_IMPRESION_FIPER_FECHA_MAX_VALIDEZ_NO_INFORMADA, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMPRESION_FIPER_FECHA_MAX_VALIDEZ_NO_INFORMADA, null, null, null);
                    }
                    fechaMaximaValidezDate = DateHelper.stringASqlDate(fechaMaximaValidez, DateHelper.FORMATO_DD_MM_YYYY_GUION);
                    /*Si la fecha de impresión de la fiper está informada y no caducada.*/
                    if (!DateUtils.CTE_DATELOWEST_FORMATO_CORTO.equals(contextoDatosSolicitud.getString(CTE_DAT_SOL_FECH_IMPR_FIPPER))) {
                        // fechaHoy < fechaMaximaValidezDate
                        if (0 > fechaHoy.compareTo(fechaMaximaValidezDate)) {
                            // si NO está caducada.
                            fiperImpresa = true;
                            break;
                        }
                    }
                    /*Guardamos el interes inicial en el historico de impresion. */
                    if (null != contextoAmortizacion.getBigDecimal(strCtxtoCmpoImpInteres)) {
                        interesInicial = contextoAmortizacion.getBigDecimal(strCtxtoCmpoImpInteres);
                    }
                    if (null != contextoAmortizacion.getBigDecimal(strCtxoCmpoImpValorActualTipoRef)) {
                        valorTipoReferencia = contextoAmortizacion.getBigDecimal(strCtxoCmpoImpValorActualTipoRef);
                    }
                    codOperatoria = Constantes.CTE_TIPO_DOCUMENTO_FIPER;
                    GestionHistoricoImpresion.guardarHistoricoImpresion(oficina, numero, version, nuc, codOperatoria, interesInicial, valorTipoReferencia, oficinaContable, fechaMaximaValidezDate, taeNoBonificada, taeBonificada, plazo, difNoBonificado, difBonifMaxima, impComisionApertura, impGastosEstudio, impSeguroHogar, tasacion, registro, notaSimple, gestoria, importeIAJD, tarjeta, importeSeguroVida, impProtPagos5Anhos, impProtPagosAnual, notaria, interes);
                    /*2015081 Actualizamos la fecha de fijación de tipo referencia en la solicitud, AN251200*/
                    if (esEntornoAbanca) {
                        solicitud.setDateFechaScoringDefinitivo(fechaHoy);
                        gds.updateSolicitud(solicitud);
                    }
                    break;
                }
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                {
                    /*Si la fecha de impresión de la OVH no está informada.*/
                    if (DateUtils.CTE_DATELOWEST_FORMATO_CORTO.equals(DateHelper.dateToString(solicitud.getDateFecha2(), DateUtils.FORMATO_FECHA_CORTO))) {
                        /*Guardamos el interes inicial en el historico de impresion. */
                        if (null != contextoAmortizacion.getBigDecimal(strCtxtoCmpoImpInteres)) {
                            interesInicial = contextoAmortizacion.getBigDecimal(strCtxtoCmpoImpInteres);
                        }
                        if (null != contextoAmortizacion.getBigDecimal(strCtxoCmpoImpValorActualTipoRef)) {
                            valorTipoReferencia = contextoAmortizacion.getBigDecimal(strCtxoCmpoImpValorActualTipoRef);
                        }
                        codOperatoria = Constantes.CTE_TIPO_DOCUMENTO_OFERTA_VINCULANTE;
                        GestionHistoricoImpresion.guardarHistoricoImpresion(oficina, numero, version, nuc, codOperatoria, interesInicial, valorTipoReferencia, oficinaContable, null, taeNoBonificada, taeBonificada, plazo, difNoBonificado, difBonifMaxima, impComisionApertura, impGastosEstudio, impSeguroHogar, tasacion, registro, notaSimple, gestoria, importeIAJD, tarjeta, importeSeguroVida, impProtPagos5Anhos, impProtPagosAnual, notaria, interes);
                    }
                    break;
                }
            default:
                {
                }
        }
        return fiperImpresa;
    }

    private void actualizarGastosAdicionales(BigDecimal nuc, List<GastosAdicionalesC> listaGastosAdic, IContexto[] resultadoGastosAdic, boolean esValidoCargoTarjeta, String divImporteSolic, BigDecimal codProducto, BigDecimal codSubproducto, BigDecimal plazoSolic, BigDecimal idTarifa, AplicaTaeC aplicaTaeRelacionMaxPrioridad, List<ParametroC> listaParamPeriodosRestar, String tipoParrilla, IContexto contextosSolicitud, BigDecimal idColectivo, boolean esDivisa, boolean esHipotecario) {
        BigDecimal idConcepto = null;
        BigDecimal periodosARestar = null;
        String descrConcepto = null;
        BigDecimal importeTotalSimulacion = null;
        BigDecimal numPeriodosGasto = null;
        BigDecimal porcentAct = null;
        /*String aplicaTAE = null;*/
        GastosAdicionalesEng gastosAdicionalesDao = new GastosAdicionalesEng();
        BigDecimal importeGuardar = null;
        for (GastosAdicionalesC gastosAdicC : listaGastosAdic) {
            for (IContexto ctxGastosAdic : resultadoGastosAdic) {
                idConcepto = new BigDecimal(ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_ID_CONCEPTO));
                if (0 == Constantes.CTE_BID_6.compareTo(idConcepto) && null != ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTINENTE) && null != ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTENIDO)) {
                    solicitud.setContinente(ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTINENTE));
                    solicitud.setContenido(ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_CONTENIDO));
                    solicitud.update();
                    contextosSolicitud.put(CTE_CONTINENTE, solicitud.getContinente());
                    contextosSolicitud.put(CTE_CONTENIDO, solicitud.getContenido());
                }
                if (0 == Constantes.CTE_BID_7.compareTo(idConcepto)) {
                    if (!esValidoCargoTarjeta) {
                        /**
                         * Si no podemos persistir el concepto numero siete pasamos a la siguiente iteracion
                         */
                        continue;
                    }
                }
                if (0 == gastosAdicC.getId().getIdConcepto().compareTo(idConcepto)) {
                    /*Recuperamos datos del contexto de gastos adicionales*/
                    // if(ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_DESCR_CONCEPTO).trim().length() > 49) {
                    // descrConcepto = ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_DESCR_CONCEPTO).trim().substring(0,49);
                    // }else {
                    descrConcepto = ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_DESCR_CONCEPTO).trim();
                    // }
                    // importePorDefecto = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_POR_DEFECTO);
                    importeTotalSimulacion = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                    numPeriodosGasto = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_NUM_PERIODOS);
                    // a la divisa del prestamo. En la AN44TB01 se guardara el importe contravalorado.
                    if (esDivisa && esHipotecario) {
                        importeTotalSimulacion = UtilidadesTramitacion.calcularContravalor(Constantes.CTE_DIVISA_EURO.toUpperCase(), importeTotalSimulacion, divImporteSolic);
                    }
                    if (0 == BigDecimal.ZERO.compareTo(numPeriodosGasto)) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_GASTO_ADICIONAL_NUM_PER_CERO, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_GASTO_ADICIONAL_NUM_PER_CERO, null, new String[] { nuc.toString() }, null);
                    }
                    porcentAct = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_FACTOR_ACT);
                    /*aplicaTAE = ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_APLICA_TAE);*/
                    /*Buscamos el número de períodos a restar de este gasto adicional*/
                    periodosARestar = UtilidadesTramitacion.consultaNumeroPeriodosRestar(listaParamPeriodosRestar, idConcepto);
                    importeGuardar = UtilidadesTramitacion.calcularImporteGastoAdicional(importeTotalSimulacion, idConcepto, plazoSolic, numPeriodosGasto, periodosARestar);
                    gastosAdicC.setDescripcionConcepto(descrConcepto);
                    // gastosAdicC.setImporte(importeTotalSimulacion);
                    gastosAdicC.setImporte(importeGuardar);
                    gastosAdicC.setMoneda(divImporteSolic);
                    gastosAdicC.setNumPeriodicidad(numPeriodosGasto);
                    gastosAdicC.setUnidadPeriodicidad(Constantes.CTE_UNIDAD_PERIODO_MES);
                    gastosAdicC.setPorcentajeActualizacion(porcentAct);
                    gastosAdicC.setUsuario(ServicioNegocio.getContexto().getUsuario());
                    gastosAdicC.setTimestamp(DateHelper.getInstance().askTimestampFromDB2());
                    gastosAdicC.setImporteRecibido(importeGuardar);
                    gastosAdicC.setPeriodosRestar(periodosARestar);
                    // en esta tabla guardaremos los indicadores para saber si, el concepto de gasto adicional de este subproducto
                    // se va a utilizar para calcular la TAE normal y la TAE bonificada, cada una en indicadores diferentes.
                    AplicaTaeC aplicaTaeC = GestionTae.obtenerAplicaTaePorId(codProducto, codSubproducto, idTarifa, idConcepto);
                    // Para este concepto tiene que estar en la tabla, si no cascamos.
                    if (null == aplicaTaeC) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_GASTO_ADIC_TABLA_TAE, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_GASTO_ADIC_TABLA_TAE, null, new String[] { idConcepto.toString(), idTarifa.toString(), codProducto.toString() + ":" + codSubproducto.toString() }, null);
                    }
                    /*Si aplica relación*/
                    if (0 == BigDecimal.ONE.compareTo(aplicaTaeC.getRelacion())) {
                        // si el que obtenemos tiene la misma prioridad que el de máxima prioridad entonces es el mismo: criterios TAEs iguales.
                        if (0 == aplicaTaeRelacionMaxPrioridad.getPrioridad().compareTo(aplicaTaeC.getPrioridad())) {
                            gastosAdicC.setAplicaTAENormal(aplicaTaeRelacionMaxPrioridad.getTaeNormal().toString());
                            gastosAdicC.setAplicaTAEBonificada(aplicaTaeRelacionMaxPrioridad.getTaeBonificada());
                        } else {
                            gastosAdicC.setAplicaTAENormal(Constantes.CTE_STR_0);
                            gastosAdicC.setAplicaTAEBonificada(BigDecimal.ZERO);
                        }
                    } else {
                        gastosAdicC.setAplicaTAENormal(aplicaTaeC.getTaeNormal().toString());
                        gastosAdicC.setAplicaTAEBonificada(aplicaTaeC.getTaeBonificada());
                    }
                    // para que no se tenga en cuenta en el calculo de la TAE.
                    if (!Constantes.CTE_TIPO_PARRILLA_OP_NUEVAS.equals(tipoParrilla.trim())) {
                        if ((new BigDecimal(Constantes.ID_GASTO_PROTECCION_PAGOS_5).compareTo(gastosAdicC.getId().getIdConcepto()) == 0) || (new BigDecimal(Constantes.ID_GASTO_PROTECCION_PAGOS_ANUAL).compareTo(gastosAdicC.getId().getIdConcepto()) == 0)) {
                            gastosAdicC.setAplicaTAEBonificada(BigDecimal.ZERO);
                        }
                    }
                    // tabla AN87TB01, para que no se tenga en cuenta en el calculo de la TAE.
                    if (new BigDecimal(Constantes.ID_GASTO_COM_TARJ_CRED).compareTo(gastosAdicC.getId().getIdConcepto()) == 0) {
                        // if ((null != solicitud) && (0 != solicitud.getIdColectivo().compareTo(BigDecimal.ZERO)))
                        if (libreDeTae(nuc, codProducto) || (null != idColectivo && 0 != idColectivo.compareTo(BigDecimal.ZERO))) {
                            gastosAdicC.setAplicaTAENormal(Constantes.CTE_STR_0);
                        }
                    }
                    gastosAdicionalesDao.update(gastosAdicC);
                // gastosAdicionalesDao.persist(gastosAdicionalesC);
                // break; /*para la fila actual de la AN44 ya encontró el contexto asociado, no
                // necesita seguir buscando en el bucle secundario. */
                }
            }
        }
        comprobarGastoNotaria(resultadoGastosAdic, contextosSolicitud, esDivisa, esHipotecario, tipoParrilla, aplicaTaeRelacionMaxPrioridad, listaParamPeriodosRestar);
    }

    private void comprobarGastoNotaria(IContexto[] resultadoGastosAdic, IContexto contextosSolicitud, boolean esDivisa, boolean esHipotecario, String tipoParrilla, AplicaTaeC aplicaTaeRelacionMaxPrioridad, List<ParametroC> listaParamPeriodosRestar) {
        GastosAdicionalesEng gastosAdicionalesDao = new GastosAdicionalesEng();
        BigDecimal oficina = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_OFICINA);
        BigDecimal numeroSol = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUMERO);
        BigDecimal version = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION);
        BigDecimal nuc = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUC);
        String divImporteSolic = contextosSolicitud.getString(CAMPO_CTXTO_SOL_DIV_IMP_SOL);
        BigDecimal plazoSolic = contextosSolicitud.getBigDecimal(CMPO_CTXTO_SOL_PLAZO);
        BigDecimal codProducto = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_IDPRODUCTO);
        BigDecimal codSubproducto = contextosSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_SUBPRODUCTO);
        BigDecimal idTarifa = contextosSolicitud.getBigDecimal(CTE_DAT_SOL_ID_TARIFA);
        final Date fechaMinima = new Date(DateUtils.dateLowest().getTime());
        for (IContexto ctxGastosAdic : resultadoGastosAdic) {
            BigDecimal idConcepto = new BigDecimal(ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_ID_CONCEPTO));
            if (new BigDecimal(Constantes.ID_GASTO_NOTARIA).compareTo(idConcepto) == 0) {
                GastosAdicionalesC gastoNotaria = gastosAdicionalesDao.obtenerGastoAdicional(nuc, idConcepto);
                if (null == gastoNotaria) {
                    GastosAdicionalesC gastosAdicionalesC = gastosAdicionalesDao.createNewObject();
                    GastosAdicionalesKey gastosAdicionalesKey = new GastosAdicionalesKey();
                    gastosAdicionalesKey.setOficinaSolicitud(oficina);
                    gastosAdicionalesKey.setNumeroSolicitud(numeroSol);
                    gastosAdicionalesKey.setVersionSolicitud(version);
                    gastosAdicionalesKey.setNucExpediente(nuc);
                    String descrConcepto = ctxGastosAdic.getString(ID_CTX_GASTOS_ADIC_DESCR_CONCEPTO).trim();
                    BigDecimal importeTotalSimulacion = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_IMPORTE_CALC);
                    // a la divisa del prestamo. En la AN44TB01 se guardara el importe contravalorado.
                    if (esDivisa && esHipotecario) {
                        importeTotalSimulacion = UtilidadesTramitacion.calcularContravalor(Constantes.CTE_DIVISA_EURO.toUpperCase(), importeTotalSimulacion, divImporteSolic);
                    }
                    BigDecimal numPeriodosGasto = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_NUM_PERIODOS);
                    if (0 == BigDecimal.ZERO.compareTo(numPeriodosGasto)) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_GASTO_ADICIONAL_NUM_PER_CERO, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_GASTO_ADICIONAL_NUM_PER_CERO, null, new String[] { nuc.toString() }, null);
                    }
                    BigDecimal porcentAct = ctxGastosAdic.getBigDecimal(ID_CTX_GASTOS_ADIC_FACTOR_ACT);
                    BigDecimal periodosARestar = UtilidadesTramitacion.consultaNumeroPeriodosRestar(listaParamPeriodosRestar, idConcepto);
                    BigDecimal importeGuardar = UtilidadesTramitacion.calcularImporteGastoAdicional(importeTotalSimulacion, idConcepto, plazoSolic, numPeriodosGasto, periodosARestar);
                    gastosAdicionalesKey.setIdConcepto(idConcepto);
                    gastosAdicionalesC.setId(gastosAdicionalesKey);
                    gastosAdicionalesC.setDescripcionConcepto(descrConcepto);
                    gastosAdicionalesC.setImporte(importeGuardar);
                    gastosAdicionalesC.setMoneda(divImporteSolic);
                    gastosAdicionalesC.setNumPeriodicidad(numPeriodosGasto);
                    gastosAdicionalesC.setUnidadPeriodicidad(Constantes.CTE_UNIDAD_PERIODO_MES);
                    gastosAdicionalesC.setPorcentajeActualizacion(porcentAct);
                    gastosAdicionalesC.setUsuario(ServicioNegocio.getContexto().getUsuario());
                    gastosAdicionalesC.setTimestamp(DateHelper.getInstance().askTimestampFromDB2());
                    gastosAdicionalesC.setImporteRecibido(importeGuardar);
                    gastosAdicionalesC.setEsEstimado(Constantes.CTE_STRING_BLANK);
                    // 20151109 No necesitamos volver a consultar el número de períodos a restar del gasto adicional.
                    // gastosAdicionalesC.setPeriodosRestar(UtilidadesTramitacion.consultaNumeroPeriodosRestar(idConcepto));
                    gastosAdicionalesC.setPeriodosRestar(periodosARestar);
                    gastosAdicionalesC.setFecha1(DateUtils.toSQLDate(fechaMinima));
                    gastosAdicionalesC.setString1(Constantes.CTE_STRING_BLANK);
                    gastosAdicionalesC.setString2(Constantes.CTE_STRING_BLANK);
                    /*20150928 Para saber si aplica la TAE normal y la TAE bonificada consultamos en la AN87TB01*/
                    // en esta tabla guardaremos los indicadores para saber si, el concepto de gasto adicional de este subproducto
                    // se va a utilizar para calcular la TAE normal y la TAE bonificada, cada una en indicadores diferentes.
                    AplicaTaeC aplicaTaeC = GestionTae.obtenerAplicaTaePorId(codProducto, codSubproducto, idTarifa, idConcepto);
                    // Para este concepto tiene que estar en la tabla, sino  lanzamos un rollback.
                    if (null == aplicaTaeC) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_GASTO_ADIC_TABLA_TAE, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_GASTO_ADIC_TABLA_TAE, null, new String[] { idConcepto.toString(), idTarifa.toString(), codProducto.toString() + ":" + codSubproducto.toString() }, null);
                    }
                    /*Si aplica relación*/
                    if (0 == BigDecimal.ONE.compareTo(aplicaTaeC.getRelacion())) {
                        // si el que obtenemos tiene la misma prioridad que el de máxima prioridad entonces es el mismo: criterios TAEs iguales.
                        if (0 == aplicaTaeRelacionMaxPrioridad.getPrioridad().compareTo(aplicaTaeC.getPrioridad())) {
                            gastosAdicionalesC.setAplicaTAENormal(aplicaTaeRelacionMaxPrioridad.getTaeNormal().toString());
                            gastosAdicionalesC.setAplicaTAEBonificada(aplicaTaeRelacionMaxPrioridad.getTaeBonificada());
                        } else {
                            gastosAdicionalesC.setAplicaTAENormal(Constantes.CTE_STR_0);
                            gastosAdicionalesC.setAplicaTAEBonificada(BigDecimal.ZERO);
                        }
                    } else {
                        gastosAdicionalesC.setAplicaTAENormal(aplicaTaeC.getTaeNormal().toString());
                        gastosAdicionalesC.setAplicaTAEBonificada(aplicaTaeC.getTaeBonificada());
                    }
                    // para que no se tenga en cuenta en el calculo de la TAE.
                    if (!Constantes.CTE_TIPO_PARRILLA_OP_NUEVAS.equals(tipoParrilla.trim())) {
                        if ((new BigDecimal(Constantes.ID_GASTO_PROTECCION_PAGOS_5).compareTo(gastosAdicionalesC.getId().getIdConcepto()) == 0) || (new BigDecimal(Constantes.ID_GASTO_PROTECCION_PAGOS_ANUAL).compareTo(gastosAdicionalesC.getId().getIdConcepto()) == 0)) {
                            gastosAdicionalesC.setAplicaTAEBonificada(BigDecimal.ZERO);
                        }
                    }
                    gastosAdicionalesDao.insert(gastosAdicionalesC);
                }
            }
        }
    }

    // Método que dados los datos de entrada, los setea si no son nulos en el VO ImprimirDocumentosVO
    public ImprimirDocumentosVO rellenarVOImprimirDoc(IDatosEntradaTx datosEntrada, Enumerados.Met_impresion_doc opcion, DatosSolicitudC datosSolicitud) {
        ImprimirDocumentosVO imprimirDocVo = new ImprimirDocumentosVO();
        // Si es la FIPER se cogen los datos del datosSolicitud, porque se pudo haber generado una version nueva(si es novacion o ampliacion)
        if (opcion.equals(Met_impresion_doc.IMPR_FIPER)) {
            imprimirDocVo.setBidOficinaSolicitud(datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud());
            imprimirDocVo.setBidNumeroSolicitud(datosSolicitud.getDatosSolicitudKey().getNumSolicitud());
            imprimirDocVo.setBidVersionSolicitud(datosSolicitud.getDatosSolicitudKey().getVersionSolicitud());
            imprimirDocVo.setBidNucExpediente(datosSolicitud.getDatosSolicitudKey().getNucExpediente());
        } else {
            imprimirDocVo.setBidOficinaSolicitud(datosEntrada.getDecimal("OFICINA_SOLICITUD"));
            imprimirDocVo.setBidNumeroSolicitud(datosEntrada.getDecimal("NUMERO_SOLICITUD"));
            imprimirDocVo.setBidVersionSolicitud(datosEntrada.getDecimal("VERSION_SOLICITUD"));
            imprimirDocVo.setBidNucExpediente(datosEntrada.getDecimal("NUC_EXPEDIENTE"));
        }
        imprimirDocVo.setSolicitudTemporal(datosEntrada.getDecimal("SOLICITUD_TEMPORAL"));
        switch(opcion) {
            case // ImprimirContratoCrediventasSrv --> ANPM_248
            IMPR_CON_CREDIVEN:
                // 1 Preformalizacion, y 2 Formalizacion
                imprimirDocVo.setStrPantallaOrigen(datosEntrada.getString("PANTALLA_ORIGEN"));
                String indicadorSolGenerar = UtilidadesTramitacion.comprobarDatoNull(datosEntrada.getString("IND_SOLO_GENERAR"));
                // Si indSoloGenerar viene vacío, se pasa un "0"
                if (!"0".equals(indicadorSolGenerar) && !"1".equals(indicadorSolGenerar) && !"2".equals(indicadorSolGenerar)) {
                    indicadorSolGenerar = "0";
                }
                imprimirDocVo.setIndSoloGenerar(indicadorSolGenerar);
                imprimirDocVo.setTipoImpresion(UtilidadesImpresion.CONTRATO_CREDIVENTAS);
                if (null != imprimirDocVo.getBidNucExpediente()) {
                    IDatosEntradaTx entrada = null;
                    IContexto[] salida = null;
                    // Llamada al PESC_202
                    entrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 800, 202);
                    entrada.addCampo("NUC", imprimirDocVo.getBidNucExpediente());
                    salida = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
                    if (null != salida && 0 < salida.length && null != salida[0]) {
                        // Número de contrato aplazos
                        if (null != salida[0].getBigDecimal("PESCN003010")) {
                            imprimirDocVo.setBidNumeroContratoAplazos(salida[0].getBigDecimal("PESCN003010"));
                        }
                        // Número de vendedor aplazos
                        if (null != salida[0].getBigDecimal("PESCN003020")) {
                            imprimirDocVo.setBidNumeroVendedorAplazos(salida[0].getBigDecimal("PESCN003020"));
                        }
                        // Nif del primer titular
                        if (null != salida[0].getString("PESCN003030")) {
                            imprimirDocVo.setStrNifPrimerTitularAplazos(salida[0].getString("PESCN003030").trim());
                        }
                        // Nombre del titular contrato aplazos
                        if (null != salida[0].getString("PESCN003040")) {
                            imprimirDocVo.setStrNombrePrimerTitularAplazos(salida[0].getString("PESCN003040").trim());
                        }
                        // Nombre del articulo de aplazos
                        if (null != salida[0].getString("PESCN003050")) {
                            imprimirDocVo.setStrNombreArticuloAplazos(salida[0].getString("PESCN003050").trim());
                        }
                        // Dirección del titular contrato aplazos
                        if (null != salida[0].getString("PESCN003060")) {
                            imprimirDocVo.setStrDireccionAplazos(salida[0].getString("PESCN003060").trim());
                        }
                    }
                }
                /*
				//Numero de contrato aplazos
				if(null !=datosEntrada.getDecimal("NUM_CONTRATO")){
					imprimirDocVo.setBidNumeroContratoAplazos(datosEntrada.getDecimal("NUM_CONTRATO"));
				}
				
				//Numero de vendedor aplazos
				if(null != datosEntrada.getDecimal("NUM_VENDEDOR")){
					imprimirDocVo.setBidNumeroVendedorAplazos(datosEntrada.getDecimal("NUM_VENDEDOR"));
				}
				
				//Nif del primer titular
				if (null != datosEntrada.getString("NIF_TITULAR")) {
					imprimirDocVo.setStrNifPrimerTitularAplazos( datosEntrada.getString("NIF_TITULAR"));
				}
				
				//Nombre del titular contrato aplazos
				if (null != datosEntrada.getString("NOMBRE_TITULAR")) {
					imprimirDocVo.setStrNombrePrimerTitularAplazos(datosEntrada.getString("NOMBRE_TITULAR"));
				}
				
				//Nombre del articulo de aplazos
				if (null != datosEntrada.getString("NOMBRE_ARTICULO")) {
					imprimirDocVo.setStrNombreArticuloAplazos(datosEntrada.getString("NOMBRE_ARTICULO"));
				}
				
				//Direccion del titular contrato aplazos
				if (null != datosEntrada.getString("DIRECCION_TITULAR")) {
					imprimirDocVo.setStrDireccionAplazos(datosEntrada.getString("DIRECCION_TITULAR"));
				}
*/
                break;
            case // ImprimirInformacionPreviaSrv  --> ANPM_256
            IMPR_INFO_PREVIA:
                imprimirDocVo.setStrGuardarImpresion(datosEntrada.getString("GUARDAR_IMPRESION"));
                imprimirDocVo.setStrGuardarComo(datosEntrada.getString("GUARDAR_COMO"));
                /*Añadimos campo para saber si queremos generar e imprimir el documento o sólo generar.*/
                String indSoloGenerar = UtilidadesTramitacion.comprobarDatoNull(datosEntrada.getString("IND_SOLO_GENERAR"));
                // Si el indicador es nulo, vacio, o distinto de 0, 1, 2 --> se pone a 0
                if (!"0".equals(indSoloGenerar) && !"1".equals(indSoloGenerar) && !"2".equals(indSoloGenerar)) {
                    indSoloGenerar = "0";
                }
                imprimirDocVo.setIndSoloGenerar(indSoloGenerar);
                imprimirDocVo.setTipoImpresion(UtilidadesImpresion.INFO_PREVIA);
                break;
            case // ImprimirOfertaVinculanteHipotecariosSrv --> ANPM_264
            IMPR_OFER_VINCU_HIP:
                // 1 Boton Imprimir(->imprimir) 2 Boton Aceptar(->Guardar en Gestion Documental)
                imprimirDocVo.setStrPantallaOrigen(datosEntrada.getString("BOTON_ORIGEN"));
                imprimirDocVo.setTipoImpresion(UtilidadesImpresion.OFERTA_VINCULANTE_HIPOTECARIOS);
                break;
            case // ImprimirPolizaSrv  --> ANPM_249
            IMPR_POLIZA:
                // 1 Preformalizacion, y 2 Formalizacion
                imprimirDocVo.setStrPantallaOrigen(datosEntrada.getString("PANTALLA_ORIGEN"));
                String indSolGenerar = UtilidadesTramitacion.comprobarDatoNull(datosEntrada.getString("IND_SOLO_GENERAR"));
                // Si indSoloGenerar viene vacío, se pasa un "0"
                if ("".equals(indSolGenerar)) {
                    indSolGenerar = "0";
                }
                imprimirDocVo.setIndSoloGenerar(indSolGenerar);
                imprimirDocVo.setTipoImpresion(UtilidadesImpresion.POLIZA);
                break;
            case // ImprimirFiperSrv --> ANPM_261
            IMPR_FIPER:
                imprimirDocVo.setStrPantallaOrigen(datosEntrada.getString("OPCION"));
                imprimirDocVo.setRegenerarVersion(datosEntrada.getString("REGENERAR_VERSION"));
                imprimirDocVo.setTipoImpresion(UtilidadesImpresion.FIPER);
                break;
            case // DocInternoMinutaSrv --> ANPM_260
            IMPR_DOC_INT_MINUTA:
                imprimirDocVo.setTipoImpresion(UtilidadesImpresion.DOC_INTERNO_MINUTA);
                break;
            case // ImprimirOfertaVinculanteSrv --> ANPM_259
            IMPR_OFER_VINCU:
                imprimirDocVo.setTipoImpresion(UtilidadesImpresion.OFERTA_VINCULANTE);
                imprimirDocVo.setEnviarCorreo(datosEntrada.getString("ENVIAR_CORREO"));
                IContexto registrosCorreos = datosEntrada.getContexto("ANPMN260");
                imprimirDocVo.setCtxDireccionesCorreo(registrosCorreos);
                break;
            default:
                break;
        }
        return imprimirDocVo;
    }

    /**
     * Obtiene el valor de la medida Solchaga a partir de los datos de la solicitud.
     *
     * @param contextoSolicitud contexto ANPMN050 con los datos de la solicitud.
     * @return valor medida Solchaga.
     */
    public static String obtenerMedidaSolchaga(final IContexto contextoSolicitud) {
        String medidaSolchaga = "0";
        String tipoCalculo = UtilidadesTramitacion.comprobarDatoNull(contextoSolicitud.getString(CAMPO_CTXTO_SOL_TIPO_CALCULO));
        if (tipoCalculo.equals("90")) {
            medidaSolchaga = "1";
        }
        return medidaSolchaga;
    }

    /**
     * Obtiene el indicador de capital negativo a partir de los datos de la solicitud.
     *
     * @param contextoSolicitud contexto ANPMN050 con los datos de la solicitud.
     * @return valor indicador de capital negativo.
     */
    public static String obtenerIndCapitalNegativo(final IContexto contextoSolicitud) {
        // Se obtiene el indicador de capital negativo del contexto de la solicitud
        String indCapitalNegativo = UtilidadesTramitacion.comprobarDatoNull(contextoSolicitud.getString(CAMPO_CTXTO_SOL_IND_CAPITAL_NEGATIVO));
        // Si viene vacío se le pasa un cero. Para el resto de casos se pasa lo que venga en la solicitud
        if (indCapitalNegativo.equals("")) {
            indCapitalNegativo = "0";
        }
        // Devolver indicador
        return indCapitalNegativo;
    }

    /**
     * Método que guarda el documento en la ruta del servidor
     *
     * @param nuc
     * @param descripcion
     * @param codigoImpreso
     * @param codDocumento
     * @param obdetalle
     * @return respuesta
     */
    private RespuestaImpresion guardarDocumentoEnServidor(BigDecimal nuc, String descripcion, String codigoImpreso, String codDocumento, IContexto[] obdetalle, int tipoImpresion, final IContexto contextoSolicitud) {
        RespuestaImpresion respuesta = Documento.generarPDF(codigoImpreso, obdetalle);
        String nombreFichero = StringUtils.EMPTY;
        String entidadStr = null;
        String oficinaStr = null;
        String numSolicStr = null;
        String digitoStr = null;
        String nucStr = null;
        String versionStr = null;
        Date fechaHoy = null;
        String tipoDocumento = null;
        /*EDIT V360144 20140627*/
        /*Rosa: "Otra cosa que tenemos que hacer es que cuando llamamos 
		 * al stream para generar los documentos, estos documentos además 
		 * de guardarlos en la gestión documental, tenemos que almacenarlos 
		 * en la misma ruta donde se guarda el fichero que generamos en el batch anpm_300."

		//20140703 comentado mientras no se dé de salida el item ANPMCFG_FICHEROS_RUTA_SALIDA
		 */
        /*En rutaSalidaFichero tenemos que concatenarle /CARPETA_DOC/ donde CARPETA_DOC puede ser:
		 * 
		INFOPREVIA
		POLIZA
		OVPERSONAL
		FIPER
		DOCINTERNOMINUTA
		OVHIPOTECARIOS
		RECIBO

		 */
        String rutaSalidaFichero = Configuracion.getInstance().getValor(CTE_RUTA_SALIDA_FICHEROS_APLICACION, CTE_RUTA_SALIDA_FICHEROS_GRUPO_CONF, CTE_RUTA_SALIDA_FICHEROS_PARAM_CONF).trim();
        switch(tipoImpresion) {
            case INFO_PREVIA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM001D_INFOPREVIA");
                    break;
                }
            case INFORMACION_NORMALIZADA_EUROPEA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM001D_INFOPREVIA");
                    break;
                }
            case POLIZA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM002D_POLIZA");
                    break;
                }
            case CONTRATO_CREDIVENTAS:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM002D_POLIZA");
                    break;
                }
            case OFERTA_VINCULANTE:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM003D_OVPERSONAL");
                    break;
                }
            case FIPER:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM004D_FIPER");
                    break;
                }
            case DOC_INTERNO_MINUTA:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM005D_DOCINTERNOMINUTA");
                    break;
                }
            case OFERTA_VINCULANTE_HIPOTECARIOS:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM006D_OVHIPOTECARIOS");
                    break;
                }
            case RECIBO_FORMALIZACION:
                {
                    rutaSalidaFichero = rutaSalidaFichero.concat("ANPM007D_RECIBO");
                    break;
                }
            default:
                {
                    break;
                }
        }
        if (esEntornoAbanca) {
            String nombreCodigoEntidad = "";
            if (comprobacionASF(contextoSolicitud)) {
                nombreCodigoEntidad = IConstantesSolicitud.CTE_PARAMETRO_NOMBRE_CODIGO_ENTIDAD_ASF;
            } else {
                nombreCodigoEntidad = IConstantesSolicitud.CTE_PARAMETRO_NOMBRE_CODIGO_ENTIDAD_ABANCA;
            }
            // entidadStr = nombreFichero.concat(Constantes.CTE_COD_ENTIDAD_ABANCA);
            entidadStr = nombreFichero.concat(UtilidadesTramitacion.obtenerValorParametroUnico(IConstantesSolicitud.CTE_PARAMETRO_AGRUPACION_GENERAL, nombreCodigoEntidad));
        }
        // Obtenemos oficina
        oficinaStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_OFICINA).toString();
        // Obtenemos número solicitud
        numSolicStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUMERO).toString();
        // Obtenemos digito solicitud
        digitoStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_DIGITO).toString();
        fechaHoy = new Date(DateHelper.getInstance().askTime().getTime());
        // nuc
        nucStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_NUC).toString();
        versionStr = contextoSolicitud.getBigDecimal(CAMPO_CTXTO_SOL_VERSION).toString();
        nombreFichero = nombreFichero.concat(entidadStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(oficinaStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(numSolicStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(digitoStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(DateHelper.sqlDateToString(fechaHoy, DateHelper.FORMATO_YYYYMMDD));
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(nucStr);
        nombreFichero = nombreFichero.concat("_");
        nombreFichero = nombreFichero.concat(versionStr);
        if ((null == respuesta) || (null == respuesta.getvaloresSOW())) {
            switch(tipoImpresion) {
                case INFO_PREVIA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), INFO_PREVIA_1986072003).toString();
                        break;
                    }
                case INFORMACION_NORMALIZADA_EUROPEA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), INFO_PREVIA_1986072003).toString();
                        break;
                    }
                case POLIZA:
                    {
                        tipoDocumento = "POLIZA";
                        break;
                    }
                case CONTRATO_CREDIVENTAS:
                    {
                        tipoDocumento = "POLIZA";
                        break;
                    }
                case OFERTA_VINCULANTE:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), OV_PERSONAL_872698791).toString();
                        break;
                    }
                case FIPER:
                    {
                        tipoDocumento = "FIPER";
                        break;
                    }
                case DOC_INTERNO_MINUTA:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), DOC_INTERNO_MINUTA_945634467).toString();
                        break;
                    }
                case OFERTA_VINCULANTE_HIPOTECARIOS:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), OV_HIPOTECARIA_397170850).toString();
                        break;
                    }
                case RECIBO_FORMALIZACION:
                    {
                        tipoDocumento = new Mensaje(ServicioNegocio.getContexto(), RECIBO_FORMALIZ_1990707436).toString();
                        break;
                    }
                default:
                    {
                        tipoDocumento = StringUtils.EMPTY;
                        break;
                    }
            }
            if (RECIBO_FORMALIZACION != tipoImpresion) {
                if (null == respuesta) {
                    UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF, solicitud);
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF, new String[] { tipoDocumento }, new String[] { nucStr }, null);
                } else {
                    if ((null == respuesta.getvaloresSOW()) && (!StringUtils.isBlank(respuesta.getDescripcionerror()))) {
                        UtilidadesTramitacion.enviarCorreo(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF_DESCR, solicitud);
                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_GENERA_PDF_DESCR, new String[] { tipoDocumento }, new String[] { nucStr }, new String[] { respuesta.getDescripcionerror() });
                    }
                }
            }
        }
        // *  la nomenclatura de los ficheros.
        if ((null != respuesta.getvaloresSOW()) && Constantes.CTE_STR_0.equals(respuesta.getCodigoError())) {
            SOW.obtener(respuesta.getvaloresSOW().getAplicacion(), respuesta.getvaloresSOW().getColeccion(), new BigDecimal(respuesta.getvaloresSOW().getAgrupacion()), new BigDecimal(respuesta.getvaloresSOW().getSecuencia()), respuesta.getvaloresSOW().getObjeto(), rutaSalidaFichero, nombreFichero);
        // "C:\\java\\batch\\out\\ANPM\\ANPM001D\\"
        }
        return respuesta;
    }

    /**
     * Pequeño método que define el tipo de documento para la oferta vinculante como OV si
     * el indicador temporal viene a false y como PO si viene a true.
     *
     * @param indicadorTemporal
     * @return
     */
    private String tipoDocumento(boolean indicadorTemporal) {
        String tipoDocumento = "OV";
        if (indicadorTemporal) {
            tipoDocumento = "PO";
        }
        return tipoDocumento;
    }

    /**
     * Método que comprueba por producto e importe de la solicitud si tiene gastos tarjeta
     * y si no debe actualizar gastos adicionales
     *
     * @param nuc
     * @param producto
     * @return
     */
    private static boolean libreDeTae(BigDecimal nuc, BigDecimal producto) {
        boolean libre = false;
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        DatosSolicitudC solicitud = gds.getUltimaVersion(nuc);
        if (null != solicitud) {
            BigDecimal importe = null;
            /*solicitud.getImporteSolicitado();*/
            List<String> productos = new ArrayList<>();
            ParametroEng dao = new ParametroEng();
            List<ParametroC> parametros = dao.obtenerParametrosPorAgrupacion("GASTOSTARJ");
            for (ParametroC parametro : parametros) {
                if ("IMPORTE".equals(parametro.getStrParametro().trim())) {
                    importe = new BigDecimal(parametro.getStrValor().trim());
                }
                if ("PRODUCTO".equals(parametro.getStrParametro().trim())) {
                    productos.add(parametro.getStrValor().trim());
                }
            }
            if (null != importe && null != solicitud.getImporteSolicitado() && null != producto && null != productos && 0 < productos.size() && null != productos.get(0)) {
                for (String codigo : productos) {
                    if ("5005".equals(codigo)) {
                        if (codigo.equals(producto.toString()) && "496".equals(solicitud.getSubproducto().toString()) && 0 <= importe.compareTo(solicitud.getImporteSolicitado())) {
                            libre = true;
                            break;
                        }
                        if (codigo.equals(producto.toString()) && !"496".equals(solicitud.getSubproducto().toString())) {
                            libre = true;
                            break;
                        }
                    } else {
                        if (codigo.equals(producto.toString()) && 0 <= importe.compareTo(solicitud.getImporteSolicitado())) {
                            libre = true;
                            break;
                        }
                    }
                }
            } else {
                libre = true;
            }
        }
        return libre;
    }

    /**
     * Se rellenan el plazo desde y el plazo hasta para el segundo tramo
     *
     * @param contextoImpresion
     * @param aCtxtoIntereses
     */
    public static void rellenarPlazosSegundoTramo(IContexto contextoImpresion, IContexto[] aCtxtoIntereses, final String ID_PLAZO_DESDE_2DO_TRAMO, final String ID_PLAZO_HASTA_2DO_TRAMO) {
        BigDecimal plazo1 = BigDecimal.ZERO;
        BigDecimal plazo2 = BigDecimal.ZERO;
        for (// contexto 52 - > tabla 27
        IContexto interes : // contexto 52 - > tabla 27
        aCtxtoIntereses) {
            if (1 == interes.getBigDecimal("ANPMN052040").intValue()) {
                plazo1 = interes.getBigDecimal("ANPMN052110");
            }
            if (2 == interes.getBigDecimal("ANPMN052040").intValue()) {
                plazo2 = interes.getBigDecimal("ANPMN052110");
            }
        }
        // Campos nuevos para el segundo tramo
        contextoImpresion.put(ID_PLAZO_DESDE_2DO_TRAMO, plazo1.add(BigDecimal.ONE));
        contextoImpresion.put(ID_PLAZO_HASTA_2DO_TRAMO, plazo2.add(plazo1));
    }

    public static BigDecimal obtenerImporteRegistral(IContexto contextoDatosSolicitud, IContexto contextoDatosSolicitud2) {
        BigDecimal tipoExpediente = contextoDatosSolicitud.getBigDecimal("ANPMN050270");
        BigDecimal importeTotal = contextoDatosSolicitud.getBigDecimal("ANPMN050630");
        BigDecimal importeAmpliado = contextoDatosSolicitud2.getBigDecimal("ANPMN049050");
        BigDecimal importeRiesgoOrigen = contextoDatosSolicitud2.getBigDecimal("ANPMN049010");
        BigDecimal deuda = BigDecimal.ZERO;
        if (0 == ConstantesComun.EXPEDIENTE_NOVACION.compareTo(tipoExpediente) || 0 == ConstantesComun.EXPEDIENTE_AMPLIACION.compareTo(tipoExpediente)) {
            deuda = importeRiesgoOrigen.add(importeAmpliado);
        } else {
            deuda = importeTotal;
        }
        return deuda;
    }

    private static final String INFO_PREVIA_1986072003 = "INFO_PREVIA_1986072003";

    private static final String RECIBO_FORMALIZ_1990707436 = "RECIBO_FORMALIZ_1990707436";

    private static final String OV_PERSONAL_872698791 = "OV_PERSONAL_872698791";

    private static final String DOC_INTERNO_MINUTA_945634467 = "DOC_INTERNO_MINUTA_945634467";

    private static final String OV_HIPOTECARIA_397170850 = "OV_HIPOTECARIA_397170850";

    private static final String CLIENTE_860587514 = "CLIENTE_860587514";

    private static final String OFICINA_1546109685 = "OFICINA_1546109685";

    private static final String FIPER_EST_IMPRESA_1144425086 = "FIPER_EST_IMPRESA_1144425086";

    private static final String QUIERE_SACAR_COPIA_TAREA_GESTI_N_DOCUMENTACI_N_134346366 = "QUIERE_SACAR_COPIA_TAREA_GESTI_N_DOCUMENTACI_N_134346366";
}
