package es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion;

import java.math.BigDecimal;

import org.apache.commons.lang.StringUtils;

import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.SubProductoC;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.producto.SubProductoEng;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.CodigosError;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.destinos.DestinosC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.ResultadoDatosSolicitudVO;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.ServicioNegocio;

/**
 * Clase que contiene métodos para el cálculo de la cuota y comprobaciones Triad para 
 * la solicitud de préstamos personales
 * 
 * @author V362374
 */
public class ControlTriad {

	/**
	 * Método que realiza la llamada al ANPM_403 para el cálculo de la cuota scoring
	 * 
	 * @param solicitud
	 * @return
	 */
	public BigDecimal calculoCuotaScoring(DatosSolicitudC solicitud,BigDecimal producto,BigDecimal subproducto,BigDecimal interesInicial)
	{
		final String CUOTA = "ANPMN305010";
		
		IContextoEjecucion contexto = ServicioNegocio.getContexto();
		IDatosEntradaTx entrada = ServicioNegocio.getPrograma(
													contexto, 
													IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_CC, 
													IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_CO);

		// La selección de parámetros de entrada se ha realizado a partir de la existente en
		// AbstractObtencionDatosSolicitudPrestamo:1771
		entrada.addCampo(
				IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_IMPORTE, 
				solicitud.getImporteSolicitado());
		entrada.addCampo(
				IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_PLAZO, 
				solicitud.getPlazoTotal());
		
		if(null != solicitud.getCondicionesInteres() && solicitud.getCondicionesInteres().size() > 0){
			entrada.addCampo(
					IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_NUC_EXPEDIENTE, 
					solicitud.getDatosSolicitudKey().getNucExpediente());
			
			BigDecimal interesSolicitud = solicitud.getCondicionesInteres().get(0).getIntInteres();	
			
			if(null != interesSolicitud && 0 != interesSolicitud.compareTo(BigDecimal.ZERO)){
				entrada.addCampo(
						IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_INTERES_INICIAL, 
						interesSolicitud);
			}			
		}else{
			entrada.addCampo(
					IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_COD_PROD, 
					producto);
			entrada.addCampo(
					IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_COD_SUBPROD, 
					subproducto);
			
			if(null != interesInicial && 0 != interesInicial.compareTo(BigDecimal.ZERO)){
				entrada.addCampo(
						IConstantesSolicitud.CTE_SN_CALC_CUOTA_SCO_ENT_INTERES_INICIAL, 
						interesInicial);
			}
		}
		
		
		
		return ServicioNegocio.invocarServicio(
										ServicioNegocio.getContexto(),
										entrada
										)
										[0].getBigDecimal(CUOTA);
	}
	
	/**
	 * Sobrecarga del metodo que calcula la cota cuando no pasamos el interés inicial
	 * @param solicitud
	 * @param producto
	 * @param subproducto
	 * @return la cuota scoring
	 */
	public BigDecimal calculoCuotaScoring(DatosSolicitudC solicitud,BigDecimal producto,BigDecimal subproducto){
		return calculoCuotaScoring(solicitud, producto, subproducto,null);
	}
	
	
	
	
	
	
	/**
	 * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
	 * desde el alta de solicitud ANPM_151
	 * 
	 * @param resultado
	 */
	public IContexto[] calculoPreScoringProactivo(
											String operacion,
											BigDecimal nuc,
											BigDecimal cuota,
											BigDecimal importe,
											String canal,
											String tarea,
											String subTipoTarea,
											BigDecimal producto,
											BigDecimal subproducto,
											String clave)
	{
		final int PRESCORING_CC = 506;
		final int PRESCORING_CO = 23;
		
		// Campos de entrada del servicio de negocio 506-023
		final String PRESCORING_OPERACION = "OPERACION";
		final String PRESCORING_NUC	= "NUC";
		final String PRESCORING_CUOTA = "CUOTA";
		final String PRESCORING_IMPORTE = "IMPORTE";
		final String PRESCORING_CANAL = "CANAL";
		final String PRESCORING_TAREA = "TAREA";
		final String PRESCORING_SUBTIPO_TAREA = "SUBTIPO_TAREA";
		final String PRESCORING_PRODUCTO = "PRODUCTO";
		final String PRESCORING_SUBPRODUCTO	= "SUBPRODUCTO";
		final String PRESCORING_CLAVE_PRODUCTO= "CLAVE_PRODUCTO";
		
		// Llamada al servicio 506-023
		IContextoEjecucion contexto = ServicioNegocio.getContexto();
		IDatosEntradaTx entrada = ServicioNegocio.getPrograma(
													contexto, 
													PRESCORING_CC, 
													PRESCORING_CO);
		entrada.addCampo(
				PRESCORING_OPERACION, 
				operacion);
		entrada.addCampo(
				PRESCORING_NUC, 
				nuc);
		if(null != cuota){
			entrada.addCampo(
					PRESCORING_CUOTA, 
					cuota);
		}
		entrada.addCampo(
				PRESCORING_IMPORTE, 
				importe);
		entrada.addCampo(
				PRESCORING_CANAL, 
				canal);
		entrada.addCampo(
				PRESCORING_TAREA, 
				tarea);
		entrada.addCampo(
				PRESCORING_SUBTIPO_TAREA, 
				subTipoTarea);
		entrada.addCampo(
				PRESCORING_PRODUCTO, 
				producto);
		entrada.addCampo(
				PRESCORING_SUBPRODUCTO, 
				subproducto);
		entrada.addCampo(
				PRESCORING_CLAVE_PRODUCTO, 
				clave);
		
		return ServicioNegocio.invocarServicio(
										ServicioNegocio.getContexto(),
										entrada);
	}
	
	/**
	 * Método que comprueba si por el destino principal de la solicitud ésta 
	 * siempre debe ir por el circuito largo independientemente de cualquier 
	 * otro factor o si tiene opción de ir por el corto.
	 * 
	 * @param solicitud
	 * @return
	 */
	public char circuitoSegunDestino(DestinosC destino)
	{
		final String AGRUPACION = "NO_TRIAD";
		char circuito = 'S';
		
		if(null != destino)
		{
			// Se busca en la tabla 82, si se encuentra irá por el circuito largo.
			IContextoEjecucion contextoEjecucion = ServicioNegocio.getContexto();
			IDatosEntradaTx entrada = ServicioNegocio.getPrograma(
														contextoEjecucion,
														Constantes.CTE_SN_BUSQ_PARAM_CC,
														Constantes.CTE_SN_BUSQ_PARAM_CO);
			
			entrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_AGRUP, AGRUPACION);
			entrada.addCampo(Constantes.CTE_SN_BUSQ_PARAM_ENT_NOMBRE, destino.getDestino());
			
			IContexto[] salida = ServicioNegocio.invocarServicio(
														contextoEjecucion,
														entrada);
			
			if(null != salida
			&& BigDecimal.ZERO.intValue() < salida.length)
			{
				for(IContexto contexto:salida)
				{
					if(contexto.getString("ANPMN031050").trim().equals(destino.getDestino()))
					{
						circuito = 'N';
						break;
					}
				}
			}
		}
		
		return circuito;
	}
		
	/**
	 * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
	 * desde el alta de solicitud ANPM_151
	 * 
	 * @param resultado
	 */
	public IContexto[] calculoPreScoringProactivo(
											ResultadoDatosSolicitudVO resultado, 
											int indOperacion)
	{
		// Parámetros constantes de la llamada
		final String OPERACION = "SCO";
		final String CANAL = "O2K";
		final String SOLICITUD = "SOL";
		final BigDecimal PRESTAMO = new BigDecimal("100");
		
		// Diferenciación entre alta y modificación
		String subTipoTarea;
		
		if(0 == indOperacion)
		{
			subTipoTarea = "ALT";
		}
		else
		{
			subTipoTarea = "MOD";
		}
		
		BigDecimal servicio = obtieneServicio(
											resultado.getDatos().getProducto(), 
											resultado.getDatos().getSubproducto());
		
		// Llamada al servicio 506-023
		return calculoPreScoringProactivo(
									OPERACION, 
									resultado.getDatos().getDatosSolicitudKey().getNucExpediente(), 
									calculoCuotaScoring(resultado.getDatos(),null,null), 
									resultado.getDatos().getImporteSolicitado(),
									CANAL, 
									SOLICITUD, 
									subTipoTarea, 
									PRESTAMO, 
									BigDecimal.ZERO, 
									"ANPM;"
										+ StringUtils.leftPad(resultado.getDatos().getProducto().toString(), 7, '0') 
										+ ";" 
										+ StringUtils.leftPad(resultado.getDatos().getSubproducto().toString(), 7, '0')
										+ ";" 
										+ (null != servicio ? servicio : "")
									);
	}
	
	/**
	 * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
	 * desde el alta de autorización ANPM_210
	 * 
	 * @param resultado
	 */
	public IContexto[] calculoPreScoringProactivo(
											DatosSolicitudC solicitud, 
											int indOperacion)
	{
		// Parámetros constantes de la llamada
		final String OPERACION = "SCO";
		final String CANAL = "O2K";
		final String SOLICITUD = "SOL";
		final BigDecimal PRESTAMO = new BigDecimal("100");
		
		// Diferenciación entre alta y modificación
		String subTipoTarea;
		
		if(0 == indOperacion)
		{
			subTipoTarea = "ALT";
		}
		else
		{
			subTipoTarea = "MOD";
		}
		
		// Llamada al servicio 506-023
		return calculoPreScoringProactivo(
									OPERACION, 
									solicitud.getDatosSolicitudKey().getNucExpediente(), 
									calculoCuotaScoring(solicitud,null,null), 
									solicitud.getImporteSolicitado(),
									CANAL, 
									SOLICITUD, 
									subTipoTarea, 
									PRESTAMO, 
									BigDecimal.ZERO, 
									"ANPM;"
										+ StringUtils.leftPad(solicitud.getProducto().toString(), 7, '0') 
										+ ";" 
										+ StringUtils.leftPad(solicitud.getSubproducto().toString(), 7, '0')
									);
	}
	
	/**
	 * Método que realiza la llamada al XPRE_023 para el cálculo del prescoring proactivo
	 * desde el servicio de alta de formalización, ANPM_255, y devuelve un booleano según 
	 * se satisfagan o no las condiciones Triad
	 * 
	 * @param solicitud
	 * @return
	 */
	public boolean condicionesTriad(DatosSolicitudC solicitud)
	{
		// Parámetros constantes de la llamada
		final String OPERACION = "CFO";
		final String CANAL = "O2K";
		final String SOLICITUD = "SOL";
		final BigDecimal PRESTAMO = new BigDecimal("100");
		final String SUBTIPO_TAREA = "ALT";
		final String CONTINUAR_EXPEDIENTE = "XPREN019170";
		
		return 'S' == calculoPreScoringProactivo(
											OPERACION, 
											solicitud.getDatosSolicitudKey().getNucExpediente(), 
											calculoCuotaScoring(solicitud,null,null), 
											solicitud.getImporteSolicitado(), 
											CANAL, 
											SOLICITUD, 
											SUBTIPO_TAREA, 
											PRESTAMO, 
											BigDecimal.ZERO, 
											"ANPM;"
												+ StringUtils.leftPad(solicitud.getProducto().toString(), 7, '0') 
												+ ";" 
												+ StringUtils.leftPad(solicitud.getSubproducto().toString(), 7, '0') 
											)
											[0].getString(CONTINUAR_EXPEDIENTE).charAt(0);
	}
	
	/**
	 * Método que devuelve un mensaje u otro dependiendo del circuito que recorrerá la
	 * solicitud basado en las condiciones Triad asociadas. Usado en el ANPM_454
	 * 
	 * @param nuc
	 * @param indOperacion
	 * @return
	 */
	public String advertenciaCircuito(
								BigDecimal nuc,
								int indOperacion)
	{
		String advertencia = StringUtils.EMPTY;

		// Parámetros constantes de la llamada
		final String OPERACION = "SCO";
		final String CANAL = "O2K";
		final String SOLICITUD = "SOL";
		final BigDecimal PRESTAMO = new BigDecimal("100");
		
		final String CUOTA = "XPREN019140";
		final String CIRCUITO = "XPREN019160";
		final String ERROR = "XPREN019120";
	
		// Se recupera la última solicitud incompleta con el nuc para el ANPM_454
		DatosSolicitudC solicitud = new GestionDatosSolicitud().getUltimaVersionIncompleta(nuc); // .getUltimaVersionCompleta(nuc);
		
		if(null != solicitud)
		{
			// Se comprueba si el destino principal es apto para el circuito corto
			char destinoValido = circuitoSegunDestino(solicitud.getDestinoPrincipal());
			
			// Diferenciación entre alta y modificación
			String subTipoTarea;
			
			if(0 == indOperacion)
			{
				subTipoTarea = "ALT";
			}
			else
			{
				subTipoTarea = "MOD";
			}
			
			// Se calcula la cuotaScoring
			BigDecimal cuotaScoring = calculoCuotaScoring(solicitud,null,null);
			
			// Se consulta XPRE_023
			IContexto[] resultado = calculoPreScoringProactivo(
												OPERACION, 
												solicitud.getDatosSolicitudKey().getNucExpediente(), 
												cuotaScoring, 
												solicitud.getImporteSolicitado(), 
												CANAL, 
												SOLICITUD, 
												subTipoTarea, 
												PRESTAMO, 
												BigDecimal.ZERO, 
												"ANPM;"
													+ StringUtils.leftPad(solicitud.getProducto().toString(), 7, '0') 
													+ ";" 
													+ StringUtils.leftPad(solicitud.getSubproducto().toString(), 7, '0')
													+ ";" 
													+ destinoValido
												);
			if(null != resultado
			&& BigDecimal.ZERO.intValue() < resultado.length)
			{	
				// Se construye un mensaje u otro dependiendo del tipo de circuito.
				// Si el caracter es 'N' no procede y se ignora.
				switch(resultado[0].getString(CIRCUITO).charAt(0))
				{
					case 'L':
						//Comprobacion sobre el producto el circuito y la tarifa
						if(null != solicitud && 0 == solicitud.getProducto().compareTo(new BigDecimal(5005)) &&
								0 == solicitud.getSubproducto().compareTo(new BigDecimal(496))){
								if(solicitud.getIdTarifa().equals(Constantes.CTE_TARIFA_PREAUTORIZADO_OFICINA) 
										|| solicitud.getIdTarifa().equals(Constantes.CTE_TARIFA_ESPANA_PREAUTORIZADO_OFICINA)
										|| solicitud.getIdTarifa().equals(Constantes.CTE_TARIFA_PREAUTORIZADO_CALL_CENTER)){
									 // rollback
									  ServicioNegocio.rollback(
											  CodigosError.CTE_ERROR_TARIFA_CON_VALOR_INCORRECTO_CIRCUITO, 
											  null,
											  new String [] {}, 
											  null);
								}
							
						}
						//Advertencias sobre el circutio
						if(806 == resultado[0].getBigDecimal(ERROR).intValue())
						{
							advertencia = "Operación expediente estándar. Se supera el importe "
										+ "máximo de 15.000 euros establecido para un cliente sin "
										+ "ingresos regulares en tramitación no oficina.";
						}
						else
						{
							advertencia = "Operación expediente estándar. No cumple los requisitos o la cuota de la operación "
										+ "solicitada (" + cuotaScoring + " euros), calculada con el "
										+ "tipo de interés del tramo más caro, es superior a la "
										+ "pre-autorizada (" + resultado[0].getBigDecimal(CUOTA)
										+ " euros)";  										
						}
						break;
						
					case 'C':
						advertencia = "Operación apta para tramitar por expediente reducido. Si desea tramitarla "
									+ "a través de un expediente estándar, puede realizarlo a través del botón "
									+ "Modificar";
						break;
						
					default:
						break;
				}
			}
		}
		
		return advertencia;
	}
	
	/**
	 * Método auxiliar que obtiene el servicio de la AN02
	 * 
	 * @param producto
	 * @param subproducto
	 * @return
	 */
	private BigDecimal obtieneServicio(BigDecimal producto, BigDecimal subproducto)
	{
		BigDecimal servicio = null;
		
		if(null != producto
		&& null != subproducto)
		{
			// Consulta AN02 para obtener el servicio
			SubProductoEng dao = new SubProductoEng();
			SubProductoC subProducto = dao.obtenerSubProductoUtimaVersion(
																	producto.intValue(), 
																	subproducto.intValue(), 
																	false, 
																	true);
			
			if(null != subProducto)
			{
				servicio = subProducto.getServicio();
			}
		}
		
		return servicio;
	}
}
