package es.caixagalicia.anpm.prestamos.comprobaciones.servicios.fachada;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;

import es.caixagalicia.anpm.prestamos.catalogo.persistencia.parametro.ParametroC;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionParametro;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Utilidades;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.CodigosError;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.ComprobacionConstantes;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.GestionComprobaciones;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.enotario.persistencia.datosgenerales.DatosgeneralesC;
import es.caixagalicia.anpm.prestamos.enotario.servicios.aplicacion.GestionDatosGeneralesEnotario;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.destinos.DestinosC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionCapitalC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionesInteresC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.ControlTriad;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionCondicionesInteres;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionConsultaDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDestinosPrestamo;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionPreformalizacionFormalizacionComunes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.contextos.ContextoFactory;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.IRegistro;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.fechas.DateHelper;

/**
 *  Servicio de comprobación dependiendo del paso de ejecución
 *  
 *  Transacción: ANVW
 *  Contexto: ANPMN454
 *  Cod_operación: ANPM_454
 *  
 *  @author V361749
 *  
 */

public class CompPorPasoSrv extends ServicioNegocio {
	
	
	private final static String CTE_MATRIZ_VALORES_PRECIOS_TARIFA 	= "ANPMN443030";
	private final static String CTE_MATRIZ_ID_TARIFA 				= "ANPMN443036";
	
	@Override
	public IContexto[] ejecutar(IContextoEjecucion contextoEjecucion, IDatosEntradaTx datosEntrada){
		// Set diario Electrónico
		contextoEjecucion.setDiarioElectronico(new DiarioElectronico(DiarioElectronico.TIPO_CONSULTA));
		
		// Datos de entrada
		String destinoParam = ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS;                               
		BigDecimal numeroPaso = datosEntrada.getDecimal(ComprobacionConstantes.CTE_PASO);
		int cuentaContable = ComprobacionConstantes.CTE_LOCAL_CC; 
		int codigoOperacion = ComprobacionConstantes.CTE_LOCAL_CO;
		int numeroPas = Integer.valueOf(numeroPaso.intValue());		                                        
		BigDecimal nuc = datosEntrada.getDecimal(ComprobacionConstantes.CTE_NUC); 			   
		BigDecimal topePorcentaje = ComprobacionConstantes.CTE_LOCAL_PORCEN; 
		String rehabilita = ConstantesComun.CTE_LOCAL_DESTINO5023;
		String prod5021 = ConstantesComun.CTE_LOCAL_DESTINO5021;
		String prod5022 = ConstantesComun.CTE_LOCAL_DESTINO5022;
		BigDecimal garan1001 = ComprobacionConstantes.CTE_LOCAL_GARANTIA1001;
		BigDecimal garan1002 = ComprobacionConstantes.CTE_LOCAL_GARANTIA1002;
		String obrasMejoras = ConstantesComun.CTE_LOCAL_DESTINO5025;
		BigDecimal pDestinoCompleto = new BigDecimal(100);
		//GestionComprobaciones gc = new GestionComprobaciones();
		
		// Se inicializa el indicador de operación en el caso en que venga informado 
		int indOperacion = BigDecimal.ZERO.intValue();
		if(null != datosEntrada.getDecimal("IND_OPERACION")){
			indOperacion = datosEntrada.getDecimal("IND_OPERACION").intValue();
		}
		
		BigDecimal plazo15 = ComprobacionConstantes.CTE_LOCAL_PLAZO15;
		BigDecimal plazo20 = ComprobacionConstantes.CTE_LOCAL_PLAZO20; 
		BigDecimal plazo25 = ComprobacionConstantes.CTE_LOCAL_PLAZO25; 
		BigDecimal plazo30 = ComprobacionConstantes.CTE_LOCAL_PLAZO30;
		BigDecimal tarifaGrupoInmovi = ComprobacionConstantes.CTE_TARIFA_GRUPO_INMOBILI;
		BigDecimal grupoInmovi = ComprobacionConstantes.CTE_GRUPO_INMOBILIARIO;
		String resultado  = "0";
		String mensajeError = "Ejecución correcta";
		String mensajeError2 = "Ejecución correcta";
		String mensajeAdvertencia = "";
		String mensajeAdvertencia2 = "";
		String destinoErroneo  = "";
		int numDestinosPrincipales = 0;
		List <BigDecimal> valoresAgrupacion = new ArrayList<BigDecimal>(1);
		BigDecimal importeFijo = new BigDecimal(40000);
		BigDecimal periodoCarencia = new BigDecimal(18);
		
		List<DestinosC> destinos = new ArrayList<DestinosC>();
		String destinoPrincipal = null;
		Integer idDestinoPrincipal = null;
		BigDecimal porcDestinoPrinc = null;
		DatosSolicitudC datosSolicitud = null;
		BigDecimal tarifaGi = null;
		String paramHFBString = null;
		boolean controlOperatoria = false;
		BigDecimal paramHFB = null;
		BigDecimal grupoInmo = null;		
		String especialidad = "";
		IContexto[] resultado48 = new IContexto[] {};
		String tarifa = null;
		
		String paramMargenFVctoStr = Constantes.CADENA_VACIA;
		
		//20151006 Si es EVO no hacemos nada.
		
		if (UtilidadesTramitacion.esEntornoAbanca()){
			GestionDestinosPrestamo gde = new GestionDestinosPrestamo();

			//GestionDatosSolicitud gds = new GestionDatosSolicitud();
			//DatosSolicitudC datosSolicitud = gds.getUltimaVersionIncompleta(nuc);
			int error = 0;
			
			if (numeroPas != 9){	
				datosSolicitud = getDatosSolicitud(nuc, numeroPas, error);
				
				if (null == datosSolicitud){
					// No se ha encontrado la solicitud en la AN25TB01
					 ServicioNegocio.rollback(
								CodigosError.CTE_ERROR_SOLIC_NO_EXISTE_PARA_NUC,
								null,
								new String[] {nuc.toString()},
								new String[] {nuc.toString()}
							  );
				}
				
				// Tiene que ser versión incompleta
				// 2016-04-04 - Se elimina la comprobacion de version incompleta, ya que para los pasos 6, 7 y 8 
				// (preformalizacion, formalizacion y solicitud contrato) la version sera completa.
				/*
				if (0 != BigDecimal.ZERO.compareTo(datosSolicitud.getDatosSolicitudKey().getNumSolicitud()))
				{
					 ServicioNegocio.rollback(
												CodigosError.CTE_ERROR_SOLIC_INCOMPLETA,
												null,
												new String[] {nuc.toString()},
												null
											  );
				}
				*/
								
				destinos = gde.obtenerDestinos(
						 datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud(),
						 datosSolicitud.getDatosSolicitudKey().getNumSolicitud(),
						 datosSolicitud.getDatosSolicitudKey().getVersionSolicitud(),
						 datosSolicitud.getDatosSolicitudKey().getNucExpediente()); 
				 
				grupoInmo = datosSolicitud.getIndGrupoInmobiliario();
				tarifaGi = datosSolicitud.getIdTarifa();
				
				// Recuperamos la agrupación COMPROBACI
				List<ParametroC> listaParametros = GestionParametro.obtenerParametros(null, "COMPROBACI");
	
				for (ParametroC parametro : listaParametros) // recorremos la agrupación
				{
	    		
					if ("COMPRPLHFB".equals(parametro.getStrParametro().trim())){
						paramHFBString = parametro.getStrValor().trim();//5804
					}
					else if("COMPRDESTN".equals(parametro.getStrParametro().trim())) {
						valoresAgrupacion.add(new BigDecimal(parametro.getStrValor().trim())); // 5804 o 5806
					}
					else if ("MARGENFVCT".equals(parametro.getStrParametro().trim()))
					{
						paramMargenFVctoStr = parametro.getStrValor().trim();
					}					
			    }
				
				if (! StringUtils.isEmpty(paramHFBString)){
					paramHFB = new BigDecimal(paramHFBString); // 5804
				} 
				else {
					 ServicioNegocio.rollback(CodigosError.CTE_ERROR_PARAMETRO_ANPM_NO_EXISTE,
												null,
												new String []  {"COMPROBACI", "COMPRPLHFB"},
												null
											 );
				}
				
				/******FUNCIONALIDAD*****/ 
				
				 //20151006 Se comprueba que la especialidad sea distinta de divisa (euros)
				especialidad = datosSolicitud.getEspecialidad().trim();
			}
			
			if (! ComprobacionConstantes.CTE_STR_D.equals(especialidad)){
				switch (numeroPas)
			    { // dependiendo del paso que reciba, ejecutará el código correspondiente
						  
					  case 0: // paso 0
						  
						  	if ((null != destinos)&&(!destinos.isEmpty())) // si la lista es nula
							{
								for (DestinosC obj1 : destinos)  // bucle que recorre la lista "destinos"
								{
									//recuperamos el porcentaje del destino principal
									if (ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal()))
									{
										/*20151026 Aquí se puede dar el caso de que tengamos dos destinos con el mismo código destino y principales,
										 * en ese caso vamos a poner como secundario el de menor porcentaje.*/
										/*En este recorrido de los destinos nos quedaremos con:
										 *  - El código de destino principal.
										 *  - El porcentaje mayor de destino principal.*/
										/*Es decir, recuperamos el porcentaje actual si es mayor que el que ya tenemos*/
										destinoPrincipal = obj1.getDestino().trim();
										/*Vamos a recuperar tambien el id de destino principal con % máximo, en principio va a ser el primero
										 * que encontremos*/
										/*Vamos a recuperar el porcentaje MÁXIMO del destino principal*/
										if (null == idDestinoPrincipal)
										{
											idDestinoPrincipal = obj1.getDestinosKey().getIntCodigoDestino();
										}
										
										if (null == porcDestinoPrinc)
										{
											porcDestinoPrinc = obj1.getPorcentaje();
										}
										else
										{
											if (0 <= obj1.getPorcentaje().compareTo(porcDestinoPrinc))
											{
												//puede ser igual, si el segundo principal que recorremos tiene el 50% = 50% del primero, 
												//o si tiene el 40%, = 40% del primero más un 20% de un secundario...
												porcDestinoPrinc = obj1.getPorcentaje();
												//si encontramos algún otro destino principal con el porcentaje mayor actualizamos el id destino.
												idDestinoPrincipal = obj1.getDestinosKey().getIntCodigoDestino();
											}
										}
									}
								}
								
								for (DestinosC obj1 : destinos)  // foreach que recorre la lista "destinos"
								{
									/* Vamos a recuperar el destino secundario con el mismo código que el destino principal, y haremos que,
									 * si existe, lo guardaremos con indicador principal = 'N', porque nos va a venir con indicador = 'S'
									 * pero no podemos guardarlo así, porque el principal va a ser el del mismo código con porcentaje mayor.*/
									if (ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal()))
									{
										if (0 != idDestinoPrincipal.compareTo(obj1.getDestinosKey().getIntCodigoDestino()))
										{
											obj1.setEsPrincipal(ComprobacionConstantes.CTE_STR_N);
										}
										else
										{
											numDestinosPrincipales++;
										}
									}
								}
						  		
								/*20151026 Si hay más de un destino principal lanzamos el rollback*/
								if (1 != numDestinosPrincipales)
								{
									ServicioNegocio.rollback(
										CodigosError.CTE_ERROR_NUM_DESTINOS_PRINCIPALES,
										null,
										null,
										null);
								}
								
						  		
								/* Comprobamos que no se intentan guardar destinos secundarios como principales*/
								for (DestinosC obj1 : destinos)  // bucle que recorre la lista "destinos"
								{
									//20151019 Si es un destino secundario, no puede tener porcentaje mayor que el destino principal.
									//20151026 De esta forma permitimos que un mismo destino conste como principal y como secundario,
									//siempre y cuando el porcentaje destinado al secundario sea menor que el destinado al principal.
									if (! ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal()))
									{
										//si el porcentaje principal es menor que el secundario lanzamos el rollback.
										if ((null != porcDestinoPrinc) &&(0 > porcDestinoPrinc.compareTo(obj1.getPorcentaje())))
										{
											//SIEMPRE Y CUANDO el secundario este no sea igual al principal
											if (! destinoPrincipal.equals(obj1.getDestino().trim())) {
												ServicioNegocio.rollback(
													CodigosError.CTE_ERROR_DESTINO_SECUNDARIO_MAYOR_PORC_PRINCIPAL,
													null,
													new String[] {obj1.getDestino(), destinoPrincipal},
													null);
											}
										}
									}

									
									if ((obj1.getDestino().trim().equals(destinoParam)) ||
										(obj1.getDestino().trim().equals(obrasMejoras)))
									{
										/*Si es el destino 5202 o el 5025*/
										/*20151019 Si intentan guardar el destino compo principal lanzamos el rollback porque es secundario */
										if (ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal()))
										{
										  ServicioNegocio.rollback(
											CodigosError.CTE_ERROR_DESTINO_SECUNDARIO_NO_PRINCIPAL,
											null,
											new String[] {obj1.getDestino()},
											null);
										}
									}
									
									// El destino 5202 no puede superar el 10%
									
									// 2016-05-04 - Si el destino es el 5202, comprobar % de subdestinos:
									// . Si subdestino = 0108: 50% máximo
									// . Si subdestino = 0109: 10% maximo 
									if (obj1.getDestino().trim().equals(destinoParam))
									{ 
										// Si es destino 5202: obtener subdestino y comprobar %
										String subdestino = obj1.getSubdestino().trim(); 

										// Subdestino 0108
										if (subdestino.equals(ConstantesComun.CTE_LOCAL_SUBDESTINO_5202_0108))
										{
											// Si el % supera el 50%
											if (ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_50.compareTo(
													obj1.getPorcentaje()) == -1) 
											{ 
												//ServicioNegocio.rollback(
												//CodigosError.CTE_ERROR_PORCENTAJE_NO_VALIDO,
												//null,
												//new String []  {obj1.getDestino().toString() + " - " + obj1.getSubdestino().toString(), 
												//	ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_50.toString()}, 
												//null);

												resultado = "9";
												mensajeError = "Error en la comprobacion del porcentaje";
												mensajeAdvertencia = "El porcentaje del destino " + obj1.getDestino().toString().trim() + " - Cancelación de otros préstamos, supera el " + ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_50.toString().trim()+"%" + " , por lo tanto la operación se elevará a CAR. " ;
												destinoErroneo = "5202";
											}	
										}

										// Subdestino 0109
										if (subdestino.equals(ConstantesComun.CTE_LOCAL_SUBDESTINO_5202_0109))
										{
											// Si el % supera el 10%
											if (ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_10.compareTo(
													obj1.getPorcentaje()) == -1) 
											{ 
												//ServicioNegocio.rollback(
												//	CodigosError.CTE_ERROR_PORCENTAJE_NO_VALIDO,
												//	null,
												//	new String []  {obj1.getDestino().toString() +  " - " + obj1.getSubdestino().toString(), 
												//		ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_10.toString()}, 
												//	null);

												resultado = "9";
												mensajeError = "Error en la comprobacion del porcentaje";
												mensajeAdvertencia = "El porcentaje del destino " + obj1.getDestino().toString().trim() + " - Cancelación de otros préstamos, supera el " + ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_10.toString().trim()+ "%" + " , por lo tanto la operación se elevará a CAR. " ;
												destinoErroneo = "5202";
											}
										}										
									}
								}
							}//fin if
						  
					  break;
					  
					  case 1: // paso 1
						  
						  if (perteneceAgrupacion(valoresAgrupacion, datosSolicitud.getProducto()) &&  // producto 5804 o 5806
								  0 ==  new BigDecimal(2).compareTo(datosSolicitud.getSubproducto())) // 20151218: filtrado por subproducto 2
						  {
							  for (DestinosC obj2 : destinos) // recorremos destinos
							  {
								   String destino = obj2.getDestino().trim(); // recuperamos el destino
								   BigDecimal porcentaje = obj2.getPorcentaje(); // será el porcentaje que tenga el destino y debe ser obligatoriamente del 100%
								   //20151221 : se comprueba que el destino es el 5021 ó 5022
								   if((0 == porcentaje.compareTo(pDestinoCompleto))&&((destino.equals(prod5021)) || (destino.equals(prod5022)))) 
								   {
									   
									   if ((0 == datosSolicitud.getGarantiaOficina().compareTo(garan1001) ||  // comprobamos que la garantía es 1 ó 2
											  0 ==  datosSolicitud.getGarantiaOficina().compareTo(garan1002)) 
											  //Que no sea además cancelacion de prestamos 03/05/2017
											  && (0 == datosSolicitud.getSubrogacionOtraEntidad().compareTo(BigDecimal.ZERO)))
									   {
										   resultado = "6";
										   mensajeError = "";
										   mensajeAdvertencia = "Las características de la operación cumplen para ir por el subproducto 1.";
									   }
								   }
							  }
						  } 
						  
						  if(UtilidadesComun.esProductoComunidadPropietarios(datosSolicitud.getProducto().toString(), 
								  datosSolicitud.getSubproducto().toString()))
						  {
							  boolean esComunidadPropietarios = UtilidadesComun.esComunidadPropietarios(nuc);

							  if (!esComunidadPropietarios)
							  {
								  // no pertenece a comunidad de propietarios, por lo que devolvemos un error
								  ServicioNegocio.rollback(
										  CodigosError.CTE_ERROR_NO_PERTENECE_COMUNIDAD_PROPIETARIOS,
										  null,
										  null, 
										  null);
							  } 
						  }
						  
						  /**
						   * Comprueba si tiene robo de hipoteca si va por el subproducto correcto.
						   */
						  GestionComprobaciones.roboHipotecaPorSubproductoDos(datosSolicitud);
										  
						break;
						  
					  case 2: // paso 2

 						  if (null != destinos) // comprobación de la lista
						  {
							  // Sólo en el paso 2, se retira la comprobación por subproducto y se realiza la agrupación por los productos
							  // incluidos en la agrupación. 2016-07-11
							  if (perteneceAgrupacion(valoresAgrupacion, datosSolicitud.getProducto())) 
							  {
								  for (DestinosC obj2 : destinos) // foreach que crea un objeto y recorre la lista "destinos"
								  {
									  if ( obj2.getNucExpediente().equals(nuc)) 
									  {// compara el nuc de la lista con el nuc pasado por parámetro

										  String destino = obj2.getDestino().trim();
										  BigDecimal parteDelTotal = (datosSolicitud.getImporteTotal().multiply(obj2.getPorcentaje())).divide(topePorcentaje); // parteDelTotal = (ImporteTotal x %recuperado)/100

										  if(destino.equals(rehabilita)) // 5023
										  {// comparamos el destino con 5023

											  if ((importeFijo.compareTo(parteDelTotal) >= 0))
											  { // 20151109 parte del total tiene que ser obligatoriamente superior a importeFijo

												  ServicioNegocio.rollback( 
														  CodigosError.CTE_ERROR_IMPORTE_NO_VALIDO, 
														  null,
														  new String [] {obj2.getDestino().toString(),importeFijo.toString()}, 
														  null
														  );
											  }						  
										  }
										  // 20151110 El destino 5025 ahora es admisible para 5806 y 5804
										  else if (perteneceAgrupacion(valoresAgrupacion, datosSolicitud.getProducto())&& 
												  destino.equals(obrasMejoras)){ // para comprobar producto y destino
											  {
												  if (importeFijo.compareTo(parteDelTotal) <= 0) 	
												  { // parteDelTotal no puede superar importeFijo

													  //ServicioNegocio.rollback( 
													//		  CodigosError.CTE_ERROR_IMPORTE_POR_PORCENTAJE_NO_VALIDO, 
													//		  null,
													//		  new String [] {obj2.getDestino().toString(),importeFijo.toString()}, 
													//		  null
													//		  );
													  
													   resultado = "9";
													   mensajeError = "Comprobación de destinos";
													   mensajeAdvertencia = "El porcentaje del destino " + obj2.getDestino().toString() + " - Obras y mejoras,  sobre el importe solicitado supera los " + importeFijo.toString() + " , por lo tanto la operación se elevará a CAR. " ;
													   destinoErroneo = "5025";
												  }			
											  }
										  }
									  }// fin FOR
								  }
							  }

							  if (paramHFB.compareTo(datosSolicitud.getProducto()) == 0) //si el parámetro es COMPRPLHFB -> modificación 18-09-2015 -> 5804 
							  {	
								  if ((datosSolicitud.getPlazoTotal().compareTo(plazo20) != 0 ) && ((datosSolicitud.getPlazoTotal().compareTo(plazo25) !=0 )) &&
										  ((datosSolicitud.getPlazoTotal().compareTo(plazo30) !=0 )) && ((datosSolicitud.getPlazoTotal().compareTo(plazo15) !=0 ))) 
								  {// validación de plazo -> el plazo solo puede ser 20(240meses), 25(300 meses), 30 (360 meses)
									  // 20160425: se añade el plazo de 15 (180)
									  //modificamos el mensaje: "El plazo introducido no es válido para el producto {0}. Los plazos válidos son: {1}, {2}, {3} meses."
									  ServicioNegocio.rollback(CodigosError.CTE_ERROR_PLAZO_NO_VALIDO, 
											  null,
											  new String [] {datosSolicitud.getProducto().toString(), 
											  plazo20.toString(), plazo25.toString(), 
											  plazo30.toString(), plazo15.toString()},
											  null
											  );
								  }
							  }

							  /* llamada al método de comprobación de edad -> ANPM_271	*/	
							  // 20151127 Provisionalmente se comprueba por control de operatoria la edad del cliente
							  // por si tiene más de 75 años se pueda saltar la validación de edad.

							  controlOperatoria = UtilidadesTramitacion.comprobarControlOperatoria(
									  nuc, 
									  ConstantesComun.CTE_CONTROL_OPERATORIA_COMP_EDAD, 
									  true);



							  if ((controlOperatoria) && (StringUtils.isNotBlank(datosSolicitud.getIndControlEdad())))
							  { 
								  BigDecimal indicadorEdad = new BigDecimal (datosSolicitud.getIndControlEdad());

								  IDatosEntradaTx datosComprobacionEdad= getPrograma(contextoEjecucion, cuentaContable, codigoOperacion);
								  datosComprobacionEdad.addCampo ("NUC", nuc);
								  datosComprobacionEdad.addCampo ("PLAZO", datosSolicitud.getPlazoTotal());
								  datosComprobacionEdad.addCampo ("INDICADOR_TITULAR", indicadorEdad); 

								  IContexto [] llamadaServicio = invocarServicio(contextoEjecucion, datosComprobacionEdad);

								  for (IContexto edadMaximaRecuperada : llamadaServicio)
								  {
									  if (null != edadMaximaRecuperada)
									  {// si la llamada finaliza con éxito devolverá un literal
										  resultado = "6";
										  mensajeError = "";
										  mensajeAdvertencia = "Conforme al plazo solicitado, la fecha de vencimiento del préstamo superará los 75 años de edad del cliente.";
									  }
								  }
							  }
							  
							  //La comprobacion para la comunidad de propietarios solo se hace si no es BackOffice
							  if(UtilidadesComun.esProductoComunidadPropietarios(datosSolicitud.getProducto().toString(), 
									  datosSolicitud.getSubproducto().toString()) && (!datosSolicitud.getMarcaBO().equals(Constantes.SI)))
							  {
								  if (0 >= datosSolicitud.getImporteTotal().compareTo(importeFijo))
								  {
									  // Si importe total <= 40000
									  
									  // Comprobacion deposito: no se permite deposito
									  // Deposito = N: OK / deposito = S: NOK
									  if (!datosSolicitud.getDeposito().equals("0"))
									  {
										  ServicioNegocio.rollback(
												  CodigosError.CTE_ERROR_DEPOSITO_NO_PERMITIDO,
												  null,
												  null, 
												  null
												  );
									  }
									  
									  // Comprobacion carencia: no se permite carencia 
									  // Carencia = 0: OK / carencia > 0: NOK
									  if (0 < datosSolicitud.getPlazoCarencia().compareTo(BigDecimal.ZERO))
									  {
										  ServicioNegocio.rollback(
												  CodigosError.CTE_ERROR_CARENCIA_NO_PERMITIDA,
												  null,
												  null, 
												  null
												  );
									  }
								  }
								  else 
								  {
									  // Si importe total > 40000
									  
									  // Comprobacion deposito: obligatorio deposito
									  // Deposito = S: OK / deposito = N: NOK
									  if (!datosSolicitud.getDeposito().equals("1"))
									  {
										  ServicioNegocio.rollback(
												  CodigosError.CTE_ERROR_DEPOSITO_OBLIGATORIO,
												  null,
												  null, 
												  null
												  );
									  }
									  
									  // Comprobacion carencia: permitida carencia hasta 18 meses
									  // Carencia <= 18 meses: OK / Carencia > 18 meses: NOK 
									  if(0 > periodoCarencia.compareTo(datosSolicitud.getPlazoCarencia()))
									  {
										  ServicioNegocio.rollback(
												  CodigosError.CTE_ERROR_VALOR_CARENCIA_INCORRECTO,
												  null,
												  null, 
												  null
												  );								  
									  }
								  }
							  }
							  
							  // 2016-10-13 - El plazo de amortizacion debe ser > que el plazo de carencia
							  if (0 >= datosSolicitud.getPlazoTotal().compareTo(datosSolicitud.getPlazoCarencia()))
							  {
								  // Si el plazo de la solicitud es <= que el plazo de carencia: NOK
								  ServicioNegocio.rollback(
										  CodigosError.CTE_ERROR_PLAZO_SOL_MENOR_IGUAL_PLAZO_CARENCIA,
										  null,
										  null, 
										  null
										  );
							  }
							  
							  // 2016-11-24 - El importe debe ser > que el plazo
							  if (0 >= datosSolicitud.getImporteTotal().compareTo(datosSolicitud.getPlazoTotal()))
							  {
								  // Si importe total <= plazo: NOK
								  ServicioNegocio.rollback(
										  CodigosError.CTE_ERROR_IMPORTE_MENOR_IGUAL_PLAZO, 
										  null, 
										  null,
										  null
										  );
							  }
						  } 
 						  
 						  UtilidadesComun.esImporteValido(datosSolicitud.getTipoExpediente(),datosSolicitud.getImporteTotal(),true,false);
 						  
 						  // Si es subrogacion otra entidad, si el plazo de la operación + fecha de hoy es superior a la fecha de vencimiento + un margen (en dias) que tengamos parametrizado en la AN82TB01
 						  // actualizar indicador en solicitud
 						 if (0 == datosSolicitud.getSubrogacionOtraEntidad().compareTo(new BigDecimal(3)))
 						 {
	 						  if (StringUtils.isNotBlank(paramMargenFVctoStr))
	 						  {
	 							  final Date dateNow = new Date(DateUtils.dateNow().getTime()); 							
								  
	 							  Calendar calendar = Calendar.getInstance();
								  calendar.setTime(dateNow); 

								  final BigDecimal bidPlazoTotal = datosSolicitud.getPlazoTotal(); 							  
	 							  final String unidadPlazoTotal = datosSolicitud.getUnidadPlazo();
	 							  
	 							  if (IConstantesSolicitud.CTE_UNIDAD_ANOS.equals(unidadPlazoTotal))
	 							  {
	 									calendar.add(Calendar.YEAR, bidPlazoTotal.intValue());								  
	 							  }
	 							  else if (IConstantesSolicitud.CTE_UNIDAD_MESES.equals(unidadPlazoTotal))
	 							  {
	 								 calendar.add(Calendar.MONTH, bidPlazoTotal.intValue());
	 							  }
	 							  else
	 							  {
	 								 calendar.add(Calendar.DATE, bidPlazoTotal.intValue());
	 							  }
	 							  
	 							  final Date dateFecOper = new Date(calendar.getTime().getTime());
	 							  	 							  
	 							  if (null != datosSolicitud.getFechaVencimientoFinal())
	 							  {
		 							  final Date fecVctoFin = datosSolicitud.getFechaVencimientoFinal();
		 							  
		 							  if (0 != fecVctoFin.compareTo(DateUtils.parseDate(DateUtils.CTE_DATELOWESTONLYDAY, DateUtils.FORMATO_FECHA_AMERICANO)))
		 							  {
			 							  calendar.setTime(fecVctoFin);
			 							  calendar.add(Calendar.DATE, Integer.valueOf(paramMargenFVctoStr));		 							
			 							  
			 							  final Date dateFecVctoMargen = new Date(calendar.getTime().getTime());
			 							  			 							  
			 							  if (0 < dateFecOper.compareTo(dateFecVctoMargen))
			 							  {
			 								 datosSolicitud.setBidIndFecVctoMayorFecOpe(BigDecimal.ONE);
			 							  }		 								  
		 							  }		 							  
	 							  }
	 						  }
 						 }
 						 						 
 						 if (0 >= datosSolicitud.getImporteTotal().compareTo(datosSolicitud.getPlazoTotal()))
						 {
 							 // Si importe total <= plazo: NOK
 							 ServicioNegocio.rollback(
									  CodigosError.CTE_ERROR_IMPORTE_MENOR_IGUAL_PLAZO, 
									  null, 
									  null,
									  null
									  );
						 }
						
 						 // Si expediente ampliacion comprobar importe deposito ampliado
 						 if (null != datosSolicitud.getTipoExpediente()
 								 && 0 == ConstantesComun.EXPEDIENTE_AMPLIACION.compareTo(datosSolicitud.getTipoExpediente()))
 							 
 						 {
	  						 // Para introducir importe deposito ampliado hay que seleccionar SI en el combo de deposito
	 						 if (StringUtils.equals(datosSolicitud.getDeposito(), "0") && 0 < datosSolicitud.getImporteDepositoAmpliado().compareTo(BigDecimal.ZERO))
							 {							 
	 							 ServicioNegocio.rollback(
										  CodigosError.CTE_ERROR_IMP_DEPOSITO_AMPLI_SIN_DEPOSITO, 
										  null, 
										  null,
										  null
										  );							 
							 } 
							 
	 						 // 2018-02-21 - Si tiene deposito origen, el importe deposito de la parte ampliada debe ser igual que el importe ampliado
							 if (0 != datosSolicitud.getImporteDepositoOrigen().compareTo(BigDecimal.ZERO))
							 {
								 if (0 != datosSolicitud.getImporteDepositoAmpliado().compareTo(datosSolicitud.getImporteAmpliado()))
								 {
									 // Si importe deposito parte ampliada <> importe ampliado: NOK
		 							 ServicioNegocio.rollback(
											  CodigosError.CTE_ERROR_IMP_DEPOSITO_AMPLI_DISTINTO_IMP_AMPLI, 
											  null, 
											  null,
											  null
											  ); 
								 }
							 }						 
							 // Si no tiene deposito origen, el importe deposito ampliado tiene que ser menor o igual que el importe ampliado
							 else if (0 < datosSolicitud.getImporteDepositoAmpliado().compareTo(datosSolicitud.getImporteAmpliado()))
							 {
		 							 ServicioNegocio.rollback(
											  CodigosError.CTE_ERROR_IMP_DEPOSITO_AMPLI_MAYOR_IMP_AMPLI, 
											  null, 
											  null,
											  null
											  );
							 }							 
 						 }

						 break;
					  
					  case 3 : // paso 3
						  //INICIO: COMPROBACION DE QUE EL TIPO TECLEADO MENOS LA BONIFICACION MAXIMA ES MAYOR QUE 0
						  List<CondicionesInteresC> lstCondicionesInteres = GestionCondicionesInteres.buscarCondicionesInteres(datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud().intValue(),  
									datosSolicitud.getDatosSolicitudKey().getVersionSolicitud().intValue(), nuc.intValue());
						  Integer plazoTramoInicial = null;
						  if ((null != lstCondicionesInteres) && (0 < lstCondicionesInteres.size())){
							  //Comprobamos si alguno de los tipos de intereses es bonificable
							  if(UtilidadesTramitacion.esBonificable(lstCondicionesInteres)){									
								for (CondicionesInteresC condicionInteres : lstCondicionesInteres){
									Integer ordenInteres = condicionInteres.getCondicionesInteresKey().getIntOrdenDelTramo();										
									if (0 == BigDecimal.ONE.compareTo(new BigDecimal(ordenInteres))){
										plazoTramoInicial = condicionInteres.getIntPlazo();
										break;
									} //del if
								} //del for

								if (plazoTramoInicial!=null){
									//Si alguno es bonificable, obtenemos la bonificacion maxima
									BigDecimal bonificacionMaxima = UtilidadesTramitacion.obtenerBonificacionMaxima(
											  datosSolicitud.getProducto(), datosSolicitud.getSubproducto(), datosSolicitud.getIdTarifa(), nuc, new BigDecimal(plazoTramoInicial),  datosSolicitud.getVersionGeneral());	
									for (CondicionesInteresC condicionInteres : lstCondicionesInteres){
										if(condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_BONIFICABLE) || 
												condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_CON_DIFER_BONIF) ||
												condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_PENALIZABLE)) {
											
											BigDecimal interesTramo = null;		
											Integer tipoRefStrTramo = condicionInteres.getIntTipoReferencia();
											//Comprobamos si es referenciado
											//Si es referenciado, techo - bonificacion
											//Si no es referenciado, (diferencial + tipo referencia) - bonificacion
											if (GestionConsultaDatosSolicitud.esTipoReferenciaNoReferenciado(tipoRefStrTramo.toString())){
												interesTramo = condicionInteres.getIntTecho();
											}
											else{
												BigDecimal interesTipoRefTramo = GestionConsultaDatosSolicitud.obtenerInteresTipoReferencia(tipoRefStrTramo.toString()); // Llamada al PTMO_130
												//interesTipoReferencia <= 0
												if ((null == interesTipoRefTramo) ||(0 <= BigDecimal.ZERO.compareTo(interesTipoRefTramo))) {
														interesTipoRefTramo = BigDecimal.ZERO;
												}
												BigDecimal diferencialTramo = condicionInteres.getIntDif();
												MathContext mathContextPrecision17 = new MathContext(17, RoundingMode.HALF_UP);
												interesTramo = interesTipoRefTramo.add(diferencialTramo, mathContextPrecision17);
											}
											
											BigDecimal calculoInteres = interesTramo.subtract(bonificacionMaxima);
											if (calculoInteres.compareTo(BigDecimal.ZERO) == -1){
												ServicioNegocio.rollback(
														   		CodigosError.CTE_ERROR_TIPO_TECLEADO_BONIFICACION_MAYOR_0, 
														   		null,
														   		new String [] {condicionInteres.getCondicionesInteresKey().getIntOrdenDelTramo().toString(),interesTramo.toString(),bonificacionMaxima.toString()}, 														 
														   		null
													  	);
											}
													
										} //comprobacion si el tipo de interes es 3,4 o 5
									} //del for
								} //plazoTramoinicial != null 
							  } // si es bonificable
						  } // del if
						  //FIN: COMPROBACION DE QUE EL TIPO TECLEADO MENOS LA BONIFICACION MAXIMA ES MAYOR QUE 0
						  
						  //COMPROBACION: SI ES 5005,SUBPRODUCTO 496 Y TARIFA 7, EL DESTINO SOLO PUEDE SER 5202
						  if ((0 == datosSolicitud.getProducto().compareTo(new BigDecimal(5005))) &&
								  0 == datosSolicitud.getSubproducto().compareTo(new BigDecimal(496)) &&
								  0 == datosSolicitud.getIdTarifa().compareTo(new BigDecimal(7))){
							  
							  List<DestinosC> lstDestinos = datosSolicitud.getDestinos();							  
							  if (null != lstDestinos){
								  int i = 0;
								  int size= lstDestinos.size();
								  boolean destinoValido = true;
								  while (i<size){
									  DestinosC destinoC = lstDestinos.get(i);
									  if (destinoC.getDestino().compareTo(ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS)!=0){
										  destinoValido = false;
										  i = size;
									  }
									  else{
										  i++;
									  }
								  }
								  if (!destinoValido){
									  ServicioNegocio.rollback(
											  CodigosError.CTE_ERROR_TARIFA_CAPTACION_DESTINO_5202, null,  null,null);
								  }
							  }
						  }						  
						  //FIN COMPROBACION
						  
						  if(!UtilidadesComun.esPersonal(datosSolicitud)){
							  if ((tarifaGi.equals(tarifaGrupoInmovi)) && !(grupoInmo.equals(grupoInmovi))) 
							  {// si la tarifa no es 4 y el grupo no es 1								  
								ServicioNegocio.rollback(
												   		  CodigosError.CTE_ERROR_GRUPO_INMOBI_NO_VALIDO, 
												   		  null,
												   		  new String [] {}, 
												   		  null
											  			);
							  }
						  }
						  
						  //Si es ASF, se comprueba que la tarifa sea valida para ese plazo
						  if (UtilidadesComun.esASF(datosSolicitud.getEntidad())){	
							  //Obtenemos el id de tarifa que tiene asociado
							  BigDecimal idTarifa = datosSolicitud.getIdTarifa();
							  
							  if ((!Utilidades.isBlankOrNull(idTarifa)) && (idTarifa.compareTo(BigDecimal.ZERO)!=0)){
								  //Llamamos al ANPM_443 para obtener las tarifas validas para ese plazo
								  IContexto[] datosTarifas = UtilidadesComun.obtencionDatosTarifa(datosSolicitud.getProducto(),  
										  datosSolicitud.getSubproducto(),datosSolicitud.getVersionGeneral(), 
										  datosSolicitud.getPlazoTotal().toString(), datosSolicitud.getIdTarifa(), 
										  Constantes.CTE_ORIGEN_CONSULTA_TARIFA_SOLICITUD, datosSolicitud.getImporteSolicitado(), 
										  nuc,null,datosSolicitud.getEntidad());
								  
									// Recorrer contextos de salida del ANPM_443, comprobando si la tarifa asignada
								    // esta entre las válidas para ese plazo
									for (IContexto datosTarifa : datosTarifas){
										IRegistro[] matrizPlazosTarifa = datosTarifa.getRegistro(CTE_MATRIZ_VALORES_PRECIOS_TARIFA);
										int size = matrizPlazosTarifa.length;
										int i=0;
										boolean encontrado = false;
										while ((i<size) && (!encontrado)){
											IRegistro registro = matrizPlazosTarifa[i];
											if (registro.getBigDecimal(CTE_MATRIZ_ID_TARIFA).compareTo(idTarifa)==0){
												encontrado = true;
											}
											else{
												i++;
											}
										}
										//Si la tarifa que tiene asignada no esta entre las disponibles para ese plazo, le damos error
										if (!encontrado){
											ServicioNegocio.rollback(
											   		  CodigosError.CTE_ERROR_TARIFA_NO_CORRESPONDE_PLAZO, 
											   		  null,new String [] {}, null);
										}
									}
							  }
							  

						  }
						  
						  break;
						  
					  case 5 : //Paso numero 5 de solicitud, COMISIONES
						  
						  //LLAMAR A EXPEDIENTE PARA SABER SI EL CLIENTE TIENE CUOTA PREAUTORIZADA SEGUN EL BOTE
						  //SE LLAMA SOLO PARA LOS EXPEDIENTES 291-PRECONCEDIDO ABANCA o 407 - PRECONCEDIDO ASF
						  if (UtilidadesComun.esPreconcedido(datosSolicitud.getTipoExpediente())) {
							  IContexto[] ctxPreautorizado = 
									  UtilidadesComun.comprobarClienteTieneCuotaPreautorizada(nuc, datosSolicitud.getTipoExpediente());
							  BigDecimal cuotaTotal = ctxPreautorizado[0].getBigDecimal(ConstantesComun.CTX_XPREN028_CUOTA_TOTAL);
							  BigDecimal limiteTotal = ctxPreautorizado[0].getBigDecimal(ConstantesComun.CTX_XPREN028_LIMITE_TOTAL);
							  							  
							  if (limiteTotal.compareTo(datosSolicitud.getImporteTotal())<0){
								  ServicioNegocio.rollback(
											CodigosError.CTE_ERROR_IMPORTE_MAX_EXCEDIDO, 
											null,
										   	new String [] {limiteTotal.toString()}, 
										   	null);
							  }
							  // Se calcula la cuotaScoring
							  BigDecimal cuotaScoring = new ControlTriad().calculoCuotaScoring(datosSolicitud,null,null);
							  if (cuotaTotal.compareTo(cuotaScoring)<0){
								  ServicioNegocio.rollback(
											CodigosError.CTE_ERROR_CUOTA_MAX_EXCEDIDO, 
											null,
										   	new String [] {cuotaTotal.toString(),cuotaScoring.toString()}, 
										   	null);
							  }
						  }
						  						  
						  //COMPROBACION: SI ES 5005,SUBPRODUCTO 496 Y TARIFA 7, EL DESTINO SOLO PUEDE SER 5202
						  if ((0 == datosSolicitud.getProducto().compareTo(new BigDecimal(5005))) &&
								  0 == datosSolicitud.getSubproducto().compareTo(new BigDecimal(496)) &&
								  0 == datosSolicitud.getIdTarifa().compareTo(new BigDecimal(7))){
							  
							  List<DestinosC> lstDestinos = datosSolicitud.getDestinos();							  
							  if (null != lstDestinos){
								  int i = 0;
								  int size= lstDestinos.size();
								  boolean destinoValido = true;
								  while (i<size){
									  DestinosC destinoC = lstDestinos.get(i);
									  if (destinoC.getDestino().compareTo(ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS)!=0){
										  destinoValido = false;
										  i = size;
									  }
									  else{
										  i++;
									  }
								  }
								  if (!destinoValido){
									  ServicioNegocio.rollback(
											  CodigosError.CTE_ERROR_TARIFA_CAPTACION_DESTINO_5202, null,  null,null);
								  }
							  }
						  }						  
						  //FIN COMPROBACION
						  						  
						  // 2016-06-07 - Si la ultima version completa de la solicitud esta
						  // en estado 6 (formalizada) no se permite modificar la solicitud.
						  GestionDatosSolicitud gds = new GestionDatosSolicitud();
						  DatosSolicitudC datosSolicitudUltimaVsCompleta = gds.getUltimaVersionCompleta(nuc);
						  DatosSolicitudC datosSolicitudUltimaIncompleta = gds.getUltimaVersionIncompleta(nuc);
						  
						  // 2017-12-14 - La solicitud no puede tener mda = 2 y pago único 
						  // a vencimiento final (campos AN260090 = 2 y AN260180=1)
						  List<CondicionCapitalC> condicionesCapital = datosSolicitud.getCondicionesCapital();
						  
						  if ((null != condicionesCapital) && (0 < condicionesCapital.size()))
						  {
							  for (CondicionCapitalC condicionCapital : condicionesCapital)
							  {
								  	if ((condicionCapital.getIntModalidadDeAmortizacion().equals(Constantes.CTE_DOS)) &&
								  		(condicionCapital.getStrPagoUnicoVencimientoFinal().equals(Constantes.CTE_UNO)))
								  	{
								  		ServicioNegocio.rollback(
								  			CodigosError.CTE_ERROR_MDA_INCOMPATIBLE_PAGO_UNICO_VENC_FINAL,		// Codigo error  
								  			null, 		// Titulo
								  			new String[]{}, 	// Descripcion
								  			null);	// Solucion
								  	}
								  	
							  }
						  }
						  
						  
						  /**
						   * Comprobar si los tramos de comision están correctamente introducidos.
						   * sólo si el expediente es hipotecario (08-11-2017)
						   */
						  boolean esHipotecario = false;  
						  esHipotecario = UtilidadesTramitacion.esHipotecario2(datosSolicitud.getTipoExpediente());
						  if (esHipotecario)
						  {
							  GestionComprobaciones.comprobarTramosComision(datosSolicitud);
						  }
						  
						  										  						  
						  if ((null != datosSolicitudUltimaVsCompleta) && 
								(0 == datosSolicitudUltimaVsCompleta.getEstadoSolicitud().compareTo(Constantes.CTE_BID_6))){
							  // Enviar correo para notificar que se ha producido un intento 
							  // de modificacion de solicitud ya formalizada.
							  enviarCorreoModificacionSolicitudFormalizada(nuc);
							  
							  // Rollback
								ServicioNegocio.rollback(
									CodigosError.CTE_ERROR_GRUPO_INMOBI_NO_VALIDO, 
									null,
								   	new String [] {}, 
								   	null);
						  }

						  // 25-01-2015: Si la tarifa del producto es uno la tarifa de la tarifa debe ser distinto de cero
						  
						  if (null != datosSolicitud) {							 							  
							  // Se invoca al método ANPM_048 con el paso 9 para que devuelva sólo los contexto 1 y 2 y poder recuperar la tarifa
							  resultado48 = invocacionMetodo048((Integer.parseInt(datosSolicitud.getProducto().toString())),
									  (Integer.parseInt(datosSolicitud.getSubproducto().toString())),
									  (Integer.parseInt(datosSolicitud.getVersionGeneral().toString())), 
									  (ComprobacionConstantes.CTE_LOCAL_PASO_9));

							  for (IContexto tarifaRecuperada : resultado48)
							  {
								  tarifa = tarifaRecuperada.getString(ComprobacionConstantes.CTE_LOCAL_CAMPO_TARIFA);
							  }

							  
							  /**
							   * Fecha: 10/05/2017
							   * Motivo: Incidencia en explotación
							   * 
							   * Se cambia la comprobacion del colectivo que se estaba haciendo sobre la ultima version
							   * completa por la ultima version incompleta. Si venia de una solicitud que previamente no
							   * tenia un colectivo fallaba la comprobación. 
							   *
							   */
							  if (null != datosSolicitudUltimaIncompleta &&
									  0 == BigDecimal.ZERO.compareTo(datosSolicitudUltimaIncompleta.getIdColectivo()))
							  {
								  // La comprobacion solo se hace si el colectivo es 0
								  if ((ComprobacionConstantes.CTE_LOCAL_UNO.equals(tarifa)) &&  // si la tarifa tiene valor 1
								  	 (0 == ComprobacionConstantes.CTE_LOCAL_CERO.compareTo(datosSolicitudUltimaIncompleta.getIdTarifa()))) // la tarifa de la solicitud es 0
								  {
									  // rollback
									  ServicioNegocio.rollback(
											  CodigosError.CTE_ERROR_TARIFA_CON_VALOR_INCORRECTO, 
											  null,
											  new String [] {}, 
											  null);
								  }
							  }
						  }
						  // Comprobaciones prescriptores
						  if (estadoPrescriptor(nuc))
						  {
							  // Llamada al servicio ANPM_471 de comprobacion de prescriptores
							  UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_1);
						  }
						  
						  // Se muestra mensaje según la solicitud vaya por circuito corto o largo.
						  // Devuelve vacío si no es ninguno de los dos casos.
						  mensajeAdvertencia = new ControlTriad().advertenciaCircuito(
								  													nuc,
								  													indOperacion);
						  if(StringUtils.isNotEmpty(mensajeAdvertencia))
						  {
							  mensajeError = StringUtils.EMPTY;
						  }
						  
						  gds = new GestionDatosSolicitud();
						  DatosSolicitudC solicitud = gds.getUltimaVersionIncompleta(nuc);
						  
						  mensajeAdvertencia2 = compruebaOperacionTarjetizable(solicitud, false);
						  
						  if(StringUtils.isNotEmpty(mensajeAdvertencia2))
						  {
							  mensajeError2 = StringUtils.EMPTY;
						  }
						
						  //SE AÑADE LA COMPROBACION DE LA VIGENCIA DEL PRODUCTO. 
						  //NOS LA PODEMOS SALTAR CON EL COD_OPERACION 150021
						  //Se excluye el expediente correspondiente con 150021 de la comprobacion de la vigencia del producto
						  if( UtilidadesTramitacion.comprobarControlOperatoria(nuc,new BigDecimal(150021),true)){
							  Date fechaHoy = new Date(DateHelper.getInstance().askTime().getTime());
							  String fechaHoyStr = DateHelper.sqlDateToString(fechaHoy, DateHelper.FORMATO_DD_MM_YYYY_GUION);
							  //Comprobamos la vigencia del producto a la fecha actual
							  GestionPreformalizacionFormalizacionComunes gpfc = new GestionPreformalizacionFormalizacionComunes();
							  gpfc.comprobarVigenciaProducto(datosSolicitud, fechaHoyStr);
						  }
						  						  
						  GestionComprobaciones.comprobarPlazos(datosSolicitudUltimaIncompleta);
						  
						  //Comprobaciones que solo se hacen en el caso de que sea ASF
						  if (UtilidadesComun.esASF(datosSolicitud.getEntidad())){		
							  
							  GestionComprobaciones.comprobarPrescriptoresASF(datosSolicitud);

							  GestionComprobaciones.comprobarComisionesASF(datosSolicitud);
							  
							  GestionComprobaciones.comprobarPeriodoLiquidacion(datosSolicitud);
							 							  	
						  } 
						  
						  break;
					
					  case 6 : // paso de preformalización de una solicitud.
						  
						  if (estadoPrescriptor(nuc))
						  {
							  // Llamada al servicio ANPM_471 de comprobacion de prescriptores
							  UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_2);
						  }
						  
						  //Comprobacion de la CER y la TAE: solo se hace en el caso de subrogacion otra entidad (3)
						  if(0 == datosSolicitud.getSubrogacionOtraEntidad().compareTo(new BigDecimal(3))){
							  if ((datosSolicitud.getTAE().compareTo(datosSolicitud.getCosteEfectivoRemanente()))>0){
								  resultado = "8";
								  mensajeError = "";
								  mensajeAdvertencia = "La TAE es mayor que el CER";
							  }
							 
						  }
						  
						  break; 
						  
					  case 7 : // paso de formalización de una solicitud.
						  
						  if (estadoPrescriptor(nuc))
						  {
							  // Llamada al servicio ANPM_471 de comprobacion de prescriptores
							  UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_3);
						  }
						  
						  // 2016-04-19 - Comprobacion caducidad precios
						  // Si los precios estan caducados no se permite formalizar
						  if (comprobarCaducidadPrecios(nuc))
						  {
							  boolean preciosCaducados = UtilidadesTramitacion.comprobarPreciosCaducados(datosSolicitud);
							  
							  if (preciosCaducados)
							  {
									ServicioNegocio.rollback(
									   		  CodigosError.CTE_ERROR_PRECIO_CADUCADO, 
									   		  null,
									   		  new String [] {}, 
									   		  null
								  			);
							  }
						  }						  
						  
						  break;
						  
					  case 8: // impresion de la solicitud-contrato
						  
						  if (estadoPrescriptor(nuc))
						  {
							  // Llamada al servicio ANPM_471 de comprobacion de prescriptores
							  UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_4);
						  }
						  
						  // 2016-04-14 - Comprobacion caducidad precios
						  // Si los precios estan caducados no se permite imprimir
						  if (comprobarCaducidadPrecios(nuc))
						  {
							  boolean preciosCaducados = UtilidadesTramitacion.comprobarPreciosCaducados(datosSolicitud);
							  
							  if (preciosCaducados)
							  {
									ServicioNegocio.rollback(
									   		  CodigosError.CTE_ERROR_PRECIO_CADUCADO, 
									   		  null,
									   		  new String [] {}, 
									   		  null
								  			);
							  }
						  }
						  
						  break;
						  
					  case 9: // comprobacion cambio de producto permitido
						  
						  // Se comprueba si se permite cambiar el producto de la solicitud o no.
						  // Se permite siempre que en la AN40TB01 no haya ninguna version de la 
						  // solicitud enviada a e-notario (estado 01).
						  boolean puedeCambiarProducto = puedeCambiarProducto(nuc);
						  
						  if (!puedeCambiarProducto)
						  {
								//ServicioNegocio.rollback(
								//  		  CodigosError.CTE_ERROR_CAMBIO_PRODUCTO_NO_PERMITIDO, 
								//   		  null,
								//   		  new String [] {nuc.toString()}, 
								//   		  null
							  	//		);
								resultado = ComprobacionConstantes.CTE_COD_ERROR_CAMBIO_PRODUCTO_NO_PERMITIDO;
								mensajeError = ComprobacionConstantes.CTE_TXT_ERROR_CAMBIO_PRODUCTO_NO_PERMITIDO;
						  }
						  
						  break;
						  
				  }// fin switch
			}
		}
		
		IContexto[] salida = new IContexto[2];
		salida[0] = ContextoFactory.getInstance().getContexto("ANPMN454");
		salida[0].put("ANPMN454010", resultado);
		salida[0].put("ANPMN454020", mensajeError);
		salida[0].put("ANPMN454030", mensajeAdvertencia); //20151223:  se añade campo para mostar advertencia
		salida[0].put("ANPMN454040", destinoErroneo);
		
		salida[1] = ContextoFactory.getInstance().getContexto("ANPMN454");
		salida[1].put("ANPMN454010", resultado);
		salida[1].put("ANPMN454020", mensajeError2);
		salida[1].put("ANPMN454030", mensajeAdvertencia2); //20151223:  se añade campo para mostar advertencia
		salida[1].put("ANPMN454040", destinoErroneo);
		
		return salida;

	}// fin ejecutar
	
	private boolean perteneceAgrupacion(List <BigDecimal> valoresAgrupacion, BigDecimal producto) 
	{		boolean resultado = false;
		
		for(BigDecimal param : valoresAgrupacion) 
		{
			if (param.compareTo(producto) == 0 ) // si es el producto 5804 o 5806 
			{ 
				resultado = true;
			}
		}

		return resultado;
	}
	
	
	/**
	 * Metodo que comprueba si es necesario realizar las comprobaciones de prescriptores
	 * para el nuc recibido como entrada, segun lo indicado por el control de operatoria
	 * para ese nuc.
	 * 
	 * @param nuc nuc para el que se llamara a control de operatoria.
	 * @return true si es necesario comprobar la caducidad de los precios, false en 
	 *         caso contrario.
	 */
	private boolean estadoPrescriptor(BigDecimal nuc) // control de operatoria para prescriptores
	{
		
		boolean salida= false;
		
		salida = UtilidadesTramitacion.comprobarControlOperatoria(
													nuc, 
													ConstantesComun.CTE_CONTROL_OPERATORIA_COMP_PRESCRIP, 
													true);
		return salida;
	}
	
	
	/**
	 * Metodo que comprueba si es necesario comprobar la caducidad de los precios para
	 * el nuc recibido como entrada, segun lo indicado por el control de operatoria 
	 * para ese nuc.
	 * 
	 * @param nuc nuc para el que se llamara a control de operatoria.
	 * @return true si es necesario comprobar la caducidad de los precios, false en 
	 *         caso contrario.
	 */
	private boolean comprobarCaducidadPrecios(BigDecimal nuc)
	{
		boolean comprobarCaducidadPrecios = false;
		
		comprobarCaducidadPrecios = UtilidadesTramitacion.comprobarControlOperatoria(
				nuc,
				ConstantesComun.CTE_CONTROL_OPERATORIA_COMP_CADUCIDAD_PRECIOS,
				true);
		
		return comprobarCaducidadPrecios;
	}
	
	
	/**
	 * Obtiene los datos de la solicitud en funcion del paso:
	 * Para pasos del 1 al 5: se obtiene la ultima version incompleta.
	 * Para el paso 9: no es necesaria la solicitud, no se incluye.
	 * Para resto de pasos: se obtiene la ultima version completa.
	 * 
	 * @param nuc NUC de la solicitud
	 * @param paso paso con el que se llama al servicio
	 * @param error indica si se produce error al obtener la solicitud de la tabla
	 *              AN25TB01 (0: no hay error, 1: ultima version incompleta 
	 *              no encontrada, 2: ultima version completa no encontrada)
	 * @return objeto DatosSolicitudC
	 */
	private DatosSolicitudC getDatosSolicitud(BigDecimal nuc, int paso, int error)
	{
		// Inicializaciones
		GestionDatosSolicitud gds = new GestionDatosSolicitud();
		DatosSolicitudC datosSolicitud = null;
		error = 0;
		
		// En funcion del paso, se obtiene la ultima version completa o la ultima version incompleta
		switch (paso)
		{
			case 0: case 1: case 2: case 3: case 4: case 5:
			{
				datosSolicitud = gds.getUltimaVersionIncompleta(nuc);
			
				if (null == datosSolicitud)
				{
					error = 1;
				}
				
				break;
			}
			case 6: case 7: case 8:
			{
				datosSolicitud = gds.getUltimaVersionCompleta(nuc);
				
				if (null == datosSolicitud)
				{
					error = 2;
				}
				
				break;
			}
		}
		
		// Devolver datos solicitud
		return datosSolicitud;
	}
	
	
	/**
	 * Metodo que envia un correo de notificacion para el caso de que se haya tratado
	 * de modificar una solicitud que ya estaba formalizada.
	 * 
	 * @param nuc NUC de la solicitud que se ha tratado de modificar.
	 */
	private void enviarCorreoModificacionSolicitudFormalizada(BigDecimal nuc)
	{
		
		// Inicializaciones
		List<String> destinatarios = new ArrayList<String>();
		String asunto = null;		
		String remitenteNombre = null;
		String autor = null;
		
		
		// Establecer autor, destinatarios y asunto
		autor = UtilidadesTramitacion.obtenerValorParametroUnico(
			ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, 
			ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_AUTOR);

		destinatarios = UtilidadesTramitacion.obtenerListaValoresParametro(
			ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, 
			ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_DESTINATARIOS);
		
		asunto = UtilidadesTramitacion.obtenerValorParametroUnico(
			ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, 
			ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_ASUNTO);
				
		if (UtilidadesTramitacion.isBlankOrNull(destinatarios))
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO,
				null,
				new String[] {ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA,
							  ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_DESTINATARIOS},
				null);
		}
		else if (StringUtils.isBlank(asunto)) 
		{
			ServicioNegocio.rollback(
				CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO,
				null,
				new String[] {ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA,
							  ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_ASUNTO},
				null);
		}
		
		
		// Incluir NUC en la plantilla
		Map<String, Object> model = new HashMap<String, Object>(1);
		model.put("PARAM_1", nuc);
		
		// Enviar correo
		UtilidadesTramitacion.enviarCorreo(
			destinatarios.toArray(new String[destinatarios.size()]),
			asunto,
			autor,
			remitenteNombre,
			ComprobacionConstantes.CTE_PLANTILLA_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA,
			model);
	}
	
	
	/**
	 * Metodo que determina si se puede cambiar el producto de la solicitud, en
	 * funcion de si la solicitud ha sido enviada alguna vez a enotario o no.
	 * 
	 * @param nuc NUC de la solicitud
	 * @return true si se permite cambiar el producto de la solicitud, false en 
	 *         caso contrario.
	 */
	private boolean puedeCambiarProducto(BigDecimal nuc)
	{
		// Inicializaciones
		boolean puedeCambiarProducto = true;
		GestionDatosGeneralesEnotario gdge = new GestionDatosGeneralesEnotario();
		
		// Obtener datos generales enotario por nuc y estado enviado (01).
		List<DatosgeneralesC> listaDatosGenerales = gdge.obtenerDatosGeneralesPorNucEstado(
				nuc, ComprobacionConstantes.CTE_ENOTARIO_ESTADO_ENVIADO);
		
		// Comprobar si se permite cambiar el producto
		if ((null != listaDatosGenerales) && (0 < listaDatosGenerales.size()))
		{
			// Si hay alguna version de la solicitud en la tabla AN40TB01 con estado 
			// enviado a enotario, no se permite cambiar el producto.
			puedeCambiarProducto = false;
		}

		// Devolver resultado
		return puedeCambiarProducto;
	}
	
	/**
	 * Llamada a método ANPM_048 
	 * 
	 * @param idProducto
	 * @param subProducto
	 * @param versionGeneral
	 * @param paso
	 * 
	 * @return IContexto
	 * 
	 */
	private IContexto[] invocacionMetodo048(Integer idProducto, Integer subProducto, Integer versionGeneral, BigDecimal paso)
	{				
		IContexto[] salida507048 = new IContexto[] {};
		
			IDatosEntradaTx datosEntradaTx507048 = ServicioNegocio.getPrograma(
				ServicioNegocio.getContexto(), Integer
					.valueOf(ComprobacionConstantes.CTE_LOCAL_CC), Integer
					.valueOf(ComprobacionConstantes.CTE_LOCAL_CO48));

			datosEntradaTx507048.addCampo("Codigo_producto",    new BigDecimal(idProducto));
			datosEntradaTx507048.addCampo("Codigo_subproducto", new BigDecimal(subProducto));
			datosEntradaTx507048.addCampo("Colectivo",          BigDecimal.ZERO);
			datosEntradaTx507048.addCampo("Version_general",    new BigDecimal(versionGeneral));
			datosEntradaTx507048.addCampo("Paso",               paso);
			
			salida507048 = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), 
					datosEntradaTx507048);
	
		return salida507048;		
	}
	
	/**
	 * Comprueba si una operación debe ser tarjetizable o no y avisa de ello. 
	 * Se le puede agregar la comprobación de que no tenga corretaje pasándole un true como segundo parámetro.
	 * 
	 * @param solicitud
	 * @return
	 */
	private String compruebaOperacionTarjetizable(DatosSolicitudC solicitud, boolean comprobacionCorretaje)
	{
		String advertencia = StringUtils.EMPTY;
		
		if(null != solicitud
		&& null != solicitud.getImporteSolicitado()
		&& null != solicitud.getDatosSolicitudKey()
		&& null != solicitud.getDatosSolicitudKey().getNucExpediente()
		&& UtilidadesComun.esPersonal(solicitud)
		&& !excepcionParametrizada(solicitud))
		{
			// Si el préstamo es de < 6000 euros (CGAL_373)
			boolean prestamoInferiorALimite = false;
			IDatosEntradaTx entrada = ServicioNegocio.getPrograma(
																ServicioNegocio.getContexto(),
																100,
																373);
			entrada.addCampo("OPCION_A_B_C_D_M_Y_O", "C");
			entrada.addCampo("CLAVE_DE_APLICACION", "PAR");
			entrada.addCampo("CLAVE_DE_PARAMETRO", "OTAR");
			
			IContexto[] salida = ServicioNegocio.invocarServicio(
																ServicioNegocio.getContexto(), 
																entrada);
			
			if(null != salida
			&& 0 < salida.length
			&& null != salida[0]
			&& null != salida[0].getBigDecimal("CG151C110") // Importe 1 de la CG32, límite para préstamo tarjetizable
			&& 0 > solicitud.getImporteSolicitado().compareTo(salida[0].getBigDecimal("CG151C110"))) // Importe inferior al límite parametrizado 
			{
				prestamoInferiorALimite = true;
			}
			
			// Y no hay más de un interviniente (titular o avalista) (UtilidadesTramitacion.consultarParticipantesPorNuc)
			boolean unicoParticipante = false;
			IContexto[] participantes = UtilidadesTramitacion.consultarParticipantesPorNuc(solicitud.getDatosSolicitudKey().getNucExpediente());
			
			if(null != participantes
			&& 1 == participantes.length)
			{
				unicoParticipante = true;
			}
			
			// No es de convenio con colectivo (¬ convenio eq. colectivo (an251630 = 0))
			boolean noTieneColectivo = false;
			if(0 == BigDecimal.ZERO.compareTo(solicitud.getIdColectivo()))
			{
				noTieneColectivo = true;
			}
			
			// Si se ha activado la comprobación adicional no debe tener corretaje, si no siempre será true
			if(comprobacionCorretaje)
			{
				comprobacionCorretaje = "N".equals(solicitud.getCorretaje());
			}
			else
			{
				comprobacionCorretaje = true;
			}
			
			// Si se cumplen las condiciones para ser tarjetizable se informa de ello.
			if(prestamoInferiorALimite
			&& unicoParticipante
			&& noTieneColectivo
			&& comprobacionCorretaje)
			{
				//-> Aviso Operación Tarjetizable. Consulta excepciones para poder continuar y se deja continuar
				advertencia = "Operación Tarjetizable. Consulta excepciones para poder continuar";
			}
		}
		
		return advertencia;
	}
	
	
	/**
	 * Método auxiliar que comprueba si una solicitud está marcada como excepción en la AN82. 
	 * Éstas se registran bajo la agrupación EX_TARIFA, con la clave TERNA_TARIFA y un valor 
	 * con el formato PRODUCTO;SUBPRODUCTO;TARIFA 
	 * 
	 * @param solicitud
	 * @return
	 */
	private boolean excepcionParametrizada(DatosSolicitudC solicitud)
	{
		boolean esExcepcion = false;
		
		List<String> parametros = UtilidadesTramitacion.obtenerParametrosANPM("EX_TARIFA","TARIFA");
		
		if(null != parametros)
		{
			for(String parametro : parametros)
			{
				String[] ternaTarifa = parametro.split(";");
				
				if(null != ternaTarifa
				&& 3 == ternaTarifa.length
				&& null != ternaTarifa[0]
				&& null != ternaTarifa[1]
				&& null != ternaTarifa[2])
				{
					if(null != solicitud
					&& null != solicitud.getProducto()
					&& null != solicitud.getSubproducto()
					&& null != solicitud.getIdTarifa()
					&& solicitud.getProducto().toString().equals(ternaTarifa[0].trim())
					&& solicitud.getSubproducto().toString().equals(ternaTarifa[1].trim())
					&& solicitud.getIdTarifa().toString().equals(ternaTarifa[2].trim()))
					{
						esExcepcion = true;
					}
				}
			}
		}
		
		return esExcepcion;
	}
}

