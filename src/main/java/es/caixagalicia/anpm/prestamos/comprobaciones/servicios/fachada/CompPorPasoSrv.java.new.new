package es.caixagalicia.anpm.prestamos.comprobaciones.servicios.fachada;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang.StringUtils;
import es.caixagalicia.anpm.prestamos.catalogo.persistencia.parametro.ParametroC;
import es.caixagalicia.anpm.prestamos.catalogo.servicios.aplicacion.GestionParametro;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.DateUtils;
import es.caixagalicia.anpm.prestamos.catalogo.utilidades.Utilidades;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.CodigosError;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.ComprobacionConstantes;
import es.caixagalicia.anpm.prestamos.comprobaciones.utilidades.GestionComprobaciones;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.enotario.persistencia.datosgenerales.DatosgeneralesC;
import es.caixagalicia.anpm.prestamos.enotario.servicios.aplicacion.GestionDatosGeneralesEnotario;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.destinos.DestinosC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionCapitalC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionesInteresC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.ControlTriad;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionCondicionesInteres;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionConsultaDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDatosSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionDestinosPrestamo;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionPreformalizacionFormalizacionComunes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.IConstantesSolicitud;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.UtilidadesTramitacion;
import es.caixagalicia.ifrt.contextos.ContextoFactory;
import es.caixagalicia.ifrt.core.DiarioElectronico;
import es.caixagalicia.ifrt.core.IContexto;
import es.caixagalicia.ifrt.core.IContextoEjecucion;
import es.caixagalicia.ifrt.core.IDatosEntradaTx;
import es.caixagalicia.ifrt.core.IRegistro;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.fechas.DateHelper;
import es.caixagalicia.ifrt.mensajes.Mensaje;

public class CompPorPasoSrv extends ServicioNegocio {

    private static final String CTE_MATRIZ_VALORES_PRECIOS_TARIFA = "ANPMN443030";

    private static final String CTE_MATRIZ_ID_TARIFA = "ANPMN443036";

    @Override
    public IContexto[] ejecutar(IContextoEjecucion contextoEjecucion, IDatosEntradaTx datosEntrada) {
        // Set diario Electrónico
        contextoEjecucion.setDiarioElectronico(new DiarioElectronico(DiarioElectronico.TIPO_CONSULTA));
        // Datos de entrada
        String destinoParam = ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS;
        BigDecimal numeroPaso = datosEntrada.getDecimal(ComprobacionConstantes.CTE_PASO);
        int cuentaContable = ComprobacionConstantes.CTE_LOCAL_CC;
        int codigoOperacion = ComprobacionConstantes.CTE_LOCAL_CO;
        int numeroPas = Integer.valueOf(numeroPaso.intValue());
        BigDecimal nuc = datosEntrada.getDecimal(ComprobacionConstantes.CTE_NUC);
        BigDecimal topePorcentaje = ComprobacionConstantes.CTE_LOCAL_PORCEN;
        String rehabilita = ConstantesComun.CTE_LOCAL_DESTINO5023;
        String prod5021 = ConstantesComun.CTE_LOCAL_DESTINO5021;
        String prod5022 = ConstantesComun.CTE_LOCAL_DESTINO5022;
        BigDecimal garan1001 = ComprobacionConstantes.CTE_LOCAL_GARANTIA1001;
        BigDecimal garan1002 = ComprobacionConstantes.CTE_LOCAL_GARANTIA1002;
        String obrasMejoras = ConstantesComun.CTE_LOCAL_DESTINO5025;
        BigDecimal pDestinoCompleto = new BigDecimal(100);
        // GestionComprobaciones gc = new GestionComprobaciones();
        // Se inicializa el indicador de operación en el caso en que venga informado
        int indOperacion = BigDecimal.ZERO.intValue();
        if (null != datosEntrada.getDecimal("IND_OPERACION")) {
            indOperacion = datosEntrada.getDecimal("IND_OPERACION").intValue();
        }
        BigDecimal plazo15 = ComprobacionConstantes.CTE_LOCAL_PLAZO15;
        BigDecimal plazo20 = ComprobacionConstantes.CTE_LOCAL_PLAZO20;
        BigDecimal plazo25 = ComprobacionConstantes.CTE_LOCAL_PLAZO25;
        BigDecimal plazo30 = ComprobacionConstantes.CTE_LOCAL_PLAZO30;
        BigDecimal tarifaGrupoInmovi = ComprobacionConstantes.CTE_TARIFA_GRUPO_INMOBILI;
        BigDecimal grupoInmovi = ComprobacionConstantes.CTE_GRUPO_INMOBILIARIO;
        String resultado = "0";
        String mensajeError = new Mensaje(ServicioNegocio.getContexto(), EJECUCI_N_CORRECTA_189320740).toString();
        String mensajeError2 = new Mensaje(ServicioNegocio.getContexto(), EJECUCI_N_CORRECTA_189320740).toString();
        String mensajeAdvertencia = "";
        String mensajeAdvertencia2 = "";
        String destinoErroneo = "";
        int numDestinosPrincipales = 0;
        List<BigDecimal> valoresAgrupacion = new ArrayList<BigDecimal>(1);
        BigDecimal importeFijo = new BigDecimal(40000);
        BigDecimal periodoCarencia = new BigDecimal(18);
        List<DestinosC> destinos = new ArrayList<DestinosC>();
        String destinoPrincipal = null;
        Integer idDestinoPrincipal = null;
        BigDecimal porcDestinoPrinc = null;
        DatosSolicitudC datosSolicitud = null;
        BigDecimal tarifaGi = null;
        String paramHFBString = null;
        boolean controlOperatoria = false;
        BigDecimal paramHFB = null;
        BigDecimal grupoInmo = null;
        String especialidad = "";
        IContexto[] resultado48 = new IContexto[] {};
        String tarifa = null;
        String paramMargenFVctoStr = Constantes.CADENA_VACIA;
        if (UtilidadesTramitacion.esEntornoAbanca()) {
            GestionDestinosPrestamo gde = new GestionDestinosPrestamo();
            // GestionDatosSolicitud gds = new GestionDatosSolicitud();
            // DatosSolicitudC datosSolicitud = gds.getUltimaVersionIncompleta(nuc);
            int error = 0;
            if (numeroPas != 9) {
                datosSolicitud = getDatosSolicitud(nuc, numeroPas, error);
                if (null == datosSolicitud) {
                    // No se ha encontrado la solicitud en la AN25TB01
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_SOLIC_NO_EXISTE_PARA_NUC, null, new String[] { nuc.toString() }, new String[] { nuc.toString() });
                }
                // Tiene que ser versión incompleta
                // 2016-04-04 - Se elimina la comprobacion de version incompleta, ya que para los pasos 6, 7 y 8
                // (preformalizacion, formalizacion y solicitud contrato) la version sera completa.
                /*
				if (0 != BigDecimal.ZERO.compareTo(datosSolicitud.getDatosSolicitudKey().getNumSolicitud()))
				{
					 ServicioNegocio.rollback(
												CodigosError.CTE_ERROR_SOLIC_INCOMPLETA,
												null,
												new String[] {nuc.toString()},
												null
											  );
				}
				*/
                destinos = gde.obtenerDestinos(datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud(), datosSolicitud.getDatosSolicitudKey().getNumSolicitud(), datosSolicitud.getDatosSolicitudKey().getVersionSolicitud(), datosSolicitud.getDatosSolicitudKey().getNucExpediente());
                grupoInmo = datosSolicitud.getIndGrupoInmobiliario();
                tarifaGi = datosSolicitud.getIdTarifa();
                // Recuperamos la agrupación COMPROBACI
                List<ParametroC> listaParametros = GestionParametro.obtenerParametros(null, "COMPROBACI");
                for (// recorremos la agrupación
                ParametroC parametro : // recorremos la agrupación
                listaParametros) {
                    if ("COMPRPLHFB".equals(parametro.getStrParametro().trim())) {
                        // 5804
                        paramHFBString = parametro.getStrValor().trim();
                    } else if ("COMPRDESTN".equals(parametro.getStrParametro().trim())) {
                        // 5804 o 5806
                        valoresAgrupacion.add(new BigDecimal(parametro.getStrValor().trim()));
                    } else if ("MARGENFVCT".equals(parametro.getStrParametro().trim())) {
                        paramMargenFVctoStr = parametro.getStrValor().trim();
                    }
                }
                if (!StringUtils.isEmpty(paramHFBString)) {
                    // 5804
                    paramHFB = new BigDecimal(paramHFBString);
                } else {
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_PARAMETRO_ANPM_NO_EXISTE, null, new String[] { new Mensaje(ServicioNegocio.getContexto(), COMPROBACI_360737679).toString(), new Mensaje(ServicioNegocio.getContexto(), COMPRPLHFB_359509435).toString() }, null);
                }
                /**
                 ****FUNCIONALIDAD****
                 */
                // 20151006 Se comprueba que la especialidad sea distinta de divisa (euros)
                especialidad = datosSolicitud.getEspecialidad().trim();
            }
            if (!ComprobacionConstantes.CTE_STR_D.equals(especialidad)) {
                switch(numeroPas) {
                    case // paso 0
                    0:
                        if (// si la lista es nula
                        (null != destinos) && (!destinos.isEmpty())) {
                            for (// bucle que recorre la lista "destinos"
                            DestinosC obj1 : // bucle que recorre la lista "destinos"
                            destinos) {
                                // recuperamos el porcentaje del destino principal
                                if (ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal())) {
                                    /*20151026 Aquí se puede dar el caso de que tengamos dos destinos con el mismo código destino y principales,
										 * en ese caso vamos a poner como secundario el de menor porcentaje.*/
                                    /*En este recorrido de los destinos nos quedaremos con:
										 *  - El código de destino principal.
										 *  - El porcentaje mayor de destino principal.*/
                                    /*Es decir, recuperamos el porcentaje actual si es mayor que el que ya tenemos*/
                                    destinoPrincipal = obj1.getDestino().trim();
                                    /*Vamos a recuperar el porcentaje MÁXIMO del destino principal*/
                                    if (null == idDestinoPrincipal) {
                                        idDestinoPrincipal = obj1.getDestinosKey().getIntCodigoDestino();
                                    }
                                    if (null == porcDestinoPrinc) {
                                        porcDestinoPrinc = obj1.getPorcentaje();
                                    } else {
                                        if (0 <= obj1.getPorcentaje().compareTo(porcDestinoPrinc)) {
                                            // puede ser igual, si el segundo principal que recorremos tiene el 50% = 50% del primero,
                                            // o si tiene el 40%, = 40% del primero más un 20% de un secundario...
                                            porcDestinoPrinc = obj1.getPorcentaje();
                                            // si encontramos algún otro destino principal con el porcentaje mayor actualizamos el id destino.
                                            idDestinoPrincipal = obj1.getDestinosKey().getIntCodigoDestino();
                                        }
                                    }
                                }
                            }
                            for (// foreach que recorre la lista "destinos"
                            DestinosC obj1 : // foreach que recorre la lista "destinos"
                            destinos) {
                                /* Vamos a recuperar el destino secundario con el mismo código que el destino principal, y haremos que,
									 * si existe, lo guardaremos con indicador principal = 'N', porque nos va a venir con indicador = 'S'
									 * pero no podemos guardarlo así, porque el principal va a ser el del mismo código con porcentaje mayor.*/
                                if (ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal())) {
                                    if (0 != idDestinoPrincipal.compareTo(obj1.getDestinosKey().getIntCodigoDestino())) {
                                        obj1.setEsPrincipal(ComprobacionConstantes.CTE_STR_N);
                                    } else {
                                        numDestinosPrincipales++;
                                    }
                                }
                            }
                            /*20151026 Si hay más de un destino principal lanzamos el rollback*/
                            if (1 != numDestinosPrincipales) {
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NUM_DESTINOS_PRINCIPALES, null, null, null);
                            }
                            /* Comprobamos que no se intentan guardar destinos secundarios como principales*/
                            for (// bucle que recorre la lista "destinos"
                            DestinosC obj1 : // bucle que recorre la lista "destinos"
                            destinos) {
                                // siempre y cuando el porcentaje destinado al secundario sea menor que el destinado al principal.
                                if (!ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal())) {
                                    // si el porcentaje principal es menor que el secundario lanzamos el rollback.
                                    if ((null != porcDestinoPrinc) && (0 > porcDestinoPrinc.compareTo(obj1.getPorcentaje()))) {
                                        // SIEMPRE Y CUANDO el secundario este no sea igual al principal
                                        if (!destinoPrincipal.equals(obj1.getDestino().trim())) {
                                            ServicioNegocio.rollback(CodigosError.CTE_ERROR_DESTINO_SECUNDARIO_MAYOR_PORC_PRINCIPAL, null, new String[] { obj1.getDestino(), destinoPrincipal }, null);
                                        }
                                    }
                                }
                                if ((obj1.getDestino().trim().equals(destinoParam)) || (obj1.getDestino().trim().equals(obrasMejoras))) {
                                    /*20151019 Si intentan guardar el destino compo principal lanzamos el rollback porque es secundario */
                                    if (ComprobacionConstantes.CTE_STR_S.equals(obj1.getEsPrincipal())) {
                                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_DESTINO_SECUNDARIO_NO_PRINCIPAL, null, new String[] { obj1.getDestino() }, null);
                                    }
                                }
                                // . Si subdestino = 0109: 10% maximo
                                if (obj1.getDestino().trim().equals(destinoParam)) {
                                    // Si es destino 5202: obtener subdestino y comprobar %
                                    String subdestino = obj1.getSubdestino().trim();
                                    // Subdestino 0108
                                    if (subdestino.equals(ConstantesComun.CTE_LOCAL_SUBDESTINO_5202_0108)) {
                                        // Si el % supera el 50%
                                        if (ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_50.compareTo(obj1.getPorcentaje()) == -1) {
                                            // ServicioNegocio.rollback(
                                            // CodigosError.CTE_ERROR_PORCENTAJE_NO_VALIDO,
                                            // null,
                                            // new String []  {obj1.getDestino().toString() + " - " + obj1.getSubdestino().toString(),
                                            // ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_50.toString()},
                                            // null);
                                            resultado = "9";
                                            mensajeError = new Mensaje(ServicioNegocio.getContexto(), ERROR_COMPROBACION_PORCENTAJE_1802470137).toString();
                                            // $OP-LBL-NL-2$ $OP-LBL-NL-3$
                                            mensajeAdvertencia = new Mensaje(ServicioNegocio.getContexto(), PORCENTAJE_DESTINO_1432432151).toString() + obj1.getDestino().toString().trim() + new Mensaje(ServicioNegocio.getContexto(), _CANCELACI_N_PR_STAMOS_SUPERA_287175975).toString() + ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_50.toString().trim() + "%" + new Mensaje(ServicioNegocio.getContexto(), _OPERACI_N_ELEVAR_CAR_1079402046).toString();
                                            destinoErroneo = "5202";
                                        }
                                    }
                                    // Subdestino 0109
                                    if (subdestino.equals(ConstantesComun.CTE_LOCAL_SUBDESTINO_5202_0109)) {
                                        // Si el % supera el 10%
                                        if (ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_10.compareTo(obj1.getPorcentaje()) == -1) {
                                            // ServicioNegocio.rollback(
                                            // CodigosError.CTE_ERROR_PORCENTAJE_NO_VALIDO,
                                            // null,
                                            // new String []  {obj1.getDestino().toString() +  " - " + obj1.getSubdestino().toString(),
                                            // ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_10.toString()},
                                            // null);
                                            resultado = "9";
                                            mensajeError = new Mensaje(ServicioNegocio.getContexto(), ERROR_COMPROBACION_PORCENTAJE_1802470137).toString();
                                            // $OP-LBL-NL-3$
                                            mensajeAdvertencia = new Mensaje(ServicioNegocio.getContexto(), PORCENTAJE_DESTINO_1432432151).toString() + obj1.getDestino().toString().trim() + new Mensaje(ServicioNegocio.getContexto(), _CANCELACI_N_PR_STAMOS_SUPERA_287175975).toString() + ComprobacionConstantes.CTE_LOCAL_PORCENTAJE_10.toString().trim() + "%" + new Mensaje(ServicioNegocio.getContexto(), _OPERACI_N_ELEVAR_CAR_1079402046).toString();
                                            destinoErroneo = "5202";
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case // paso 1
                    1:
                        if (// producto 5804 o 5806
                        perteneceAgrupacion(valoresAgrupacion, datosSolicitud.getProducto()) && // 20151218: filtrado por subproducto 2
                        0 == new BigDecimal(2).compareTo(datosSolicitud.getSubproducto())) {
                            for (// recorremos destinos
                            DestinosC obj2 : // recorremos destinos
                            destinos) {
                                // recuperamos el destino
                                String destino = obj2.getDestino().trim();
                                // será el porcentaje que tenga el destino y debe ser obligatoriamente del 100%
                                BigDecimal porcentaje = obj2.getPorcentaje();
                                // 20151221 : se comprueba que el destino es el 5021 ó 5022
                                if ((0 == porcentaje.compareTo(pDestinoCompleto)) && ((destino.equals(prod5021)) || (destino.equals(prod5022)))) {
                                    if ((// comprobamos que la garantía es 1 ó 2
                                    0 == datosSolicitud.getGarantiaOficina().compareTo(garan1001) || 0 == datosSolicitud.getGarantiaOficina().compareTo(garan1002)) && // Que no sea además cancelacion de prestamos 03/05/2017
                                    (0 == datosSolicitud.getSubrogacionOtraEntidad().compareTo(BigDecimal.ZERO))) {
                                        resultado = "6";
                                        mensajeError = "";
                                        mensajeAdvertencia = new Mensaje(ServicioNegocio.getContexto(), CARACTER_STICAS_OPERACI_N_CUMPLEN_SUBPRODUCTO_1_2107577050).toString();
                                    }
                                }
                            }
                        }
                        if (UtilidadesComun.esProductoComunidadPropietarios(datosSolicitud.getProducto().toString(), datosSolicitud.getSubproducto().toString())) {
                            boolean esComunidadPropietarios = UtilidadesComun.esComunidadPropietarios(nuc);
                            if (!esComunidadPropietarios) {
                                // no pertenece a comunidad de propietarios, por lo que devolvemos un error
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_PERTENECE_COMUNIDAD_PROPIETARIOS, null, null, null);
                            }
                        }
                        /**
                         * Comprueba si tiene robo de hipoteca si va por el subproducto correcto.
                         */
                        GestionComprobaciones.roboHipotecaPorSubproductoDos(datosSolicitud);
                        break;
                    case // paso 2
                    2:
                        if (// comprobación de la lista
                        null != destinos) {
                            // incluidos en la agrupación. 2016-07-11
                            if (perteneceAgrupacion(valoresAgrupacion, datosSolicitud.getProducto())) {
                                for (// foreach que crea un objeto y recorre la lista "destinos"
                                DestinosC obj2 : // foreach que crea un objeto y recorre la lista "destinos"
                                destinos) {
                                    if (obj2.getNucExpediente().equals(nuc)) {
                                        // compara el nuc de la lista con el nuc pasado por parámetro
                                        String destino = obj2.getDestino().trim();
                                        // parteDelTotal = (ImporteTotal x %recuperado)/100
                                        BigDecimal parteDelTotal = (datosSolicitud.getImporteTotal().multiply(obj2.getPorcentaje())).divide(topePorcentaje);
                                        if (// 5023
                                        destino.equals(rehabilita)) {
                                            if ((importeFijo.compareTo(parteDelTotal) >= 0)) {
                                                // 20151109 parte del total tiene que ser obligatoriamente superior a importeFijo
                                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMPORTE_NO_VALIDO, null, new String[] { obj2.getDestino().toString(), importeFijo.toString() }, null);
                                            }
                                        } else // 20151110 El destino 5025 ahora es admisible para 5806 y 5804
                                        if (perteneceAgrupacion(valoresAgrupacion, datosSolicitud.getProducto()) && destino.equals(obrasMejoras)) {
                                            // para comprobar producto y destino
                                            {
                                                if (importeFijo.compareTo(parteDelTotal) <= 0) {
                                                    // parteDelTotal no puede superar importeFijo
                                                    // ServicioNegocio.rollback(
                                                    // CodigosError.CTE_ERROR_IMPORTE_POR_PORCENTAJE_NO_VALIDO,
                                                    // null,
                                                    // new String [] {obj2.getDestino().toString(),importeFijo.toString()},
                                                    // null
                                                    // );
                                                    resultado = "9";
                                                    mensajeError = new Mensaje(ServicioNegocio.getContexto(), COMPROBACI_N_DESTINOS_200562431).toString();
                                                    // $OP-LBL-NL-2$
                                                    mensajeAdvertencia = new Mensaje(ServicioNegocio.getContexto(), PORCENTAJE_DESTINO_1432432151).toString() + obj2.getDestino().toString() + new Mensaje(ServicioNegocio.getContexto(), _OBRAS_MEJORAS_IMPORTE_SOLICITADO_SUPERA_991259466).toString() + importeFijo.toString() + new Mensaje(ServicioNegocio.getContexto(), _OPERACI_N_ELEVAR_CAR_1079402046).toString();
                                                    destinoErroneo = "5025";
                                                }
                                            }
                                        }
                                    }
                                // fin FOR
                                }
                            }
                            if (// si el parámetro es COMPRPLHFB -> modificación 18-09-2015 -> 5804
                            paramHFB.compareTo(datosSolicitud.getProducto()) == 0) {
                                if ((datosSolicitud.getPlazoTotal().compareTo(plazo20) != 0) && ((datosSolicitud.getPlazoTotal().compareTo(plazo25) != 0)) && ((datosSolicitud.getPlazoTotal().compareTo(plazo30) != 0)) && ((datosSolicitud.getPlazoTotal().compareTo(plazo15) != 0))) {
                                    // validación de plazo -> el plazo solo puede ser 20(240meses), 25(300 meses), 30 (360 meses)
                                    // 20160425: se añade el plazo de 15 (180)
                                    // modificamos el mensaje: "El plazo introducido no es válido para el producto {0}. Los plazos válidos son: {1}, {2}, {3} meses."
                                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_PLAZO_NO_VALIDO, null, new String[] { datosSolicitud.getProducto().toString(), plazo20.toString(), plazo25.toString(), plazo30.toString(), plazo15.toString() }, null);
                                }
                            }
                            /* llamada al método de comprobación de edad -> ANPM_271	*/
                            // 20151127 Provisionalmente se comprueba por control de operatoria la edad del cliente
                            // por si tiene más de 75 años se pueda saltar la validación de edad.
                            controlOperatoria = UtilidadesTramitacion.comprobarControlOperatoria(nuc, ConstantesComun.CTE_CONTROL_OPERATORIA_COMP_EDAD, true);
                            if ((controlOperatoria) && (StringUtils.isNotBlank(datosSolicitud.getIndControlEdad()))) {
                                BigDecimal indicadorEdad = new BigDecimal(datosSolicitud.getIndControlEdad());
                                IDatosEntradaTx datosComprobacionEdad = getPrograma(contextoEjecucion, cuentaContable, codigoOperacion);
                                datosComprobacionEdad.addCampo("NUC", nuc);
                                datosComprobacionEdad.addCampo("PLAZO", datosSolicitud.getPlazoTotal());
                                datosComprobacionEdad.addCampo("INDICADOR_TITULAR", indicadorEdad);
                                IContexto[] llamadaServicio = invocarServicio(contextoEjecucion, datosComprobacionEdad);
                                for (IContexto edadMaximaRecuperada : llamadaServicio) {
                                    if (null != edadMaximaRecuperada) {
                                        // si la llamada finaliza con éxito devolverá un literal
                                        resultado = "6";
                                        mensajeError = "";
                                        mensajeAdvertencia = new Mensaje(ServicioNegocio.getContexto(), CONFORME_PLAZO_SOLICITADO_FECHA_VENCIMIENTO_PR_ST_287752658).toString();
                                    }
                                }
                            }
                            // La comprobacion para la comunidad de propietarios solo se hace si no es BackOffice
                            if (UtilidadesComun.esProductoComunidadPropietarios(datosSolicitud.getProducto().toString(), datosSolicitud.getSubproducto().toString()) && (!datosSolicitud.getMarcaBO().equals(Constantes.SI))) {
                                if (0 >= datosSolicitud.getImporteTotal().compareTo(importeFijo)) {
                                    // Deposito = N: OK / deposito = S: NOK
                                    if (!datosSolicitud.getDeposito().equals("0")) {
                                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_DEPOSITO_NO_PERMITIDO, null, null, null);
                                    }
                                    // Carencia = 0: OK / carencia > 0: NOK
                                    if (0 < datosSolicitud.getPlazoCarencia().compareTo(BigDecimal.ZERO)) {
                                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_CARENCIA_NO_PERMITIDA, null, null, null);
                                    }
                                } else {
                                    // Deposito = S: OK / deposito = N: NOK
                                    if (!datosSolicitud.getDeposito().equals("1")) {
                                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_DEPOSITO_OBLIGATORIO, null, null, null);
                                    }
                                    // Carencia <= 18 meses: OK / Carencia > 18 meses: NOK
                                    if (0 > periodoCarencia.compareTo(datosSolicitud.getPlazoCarencia())) {
                                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_VALOR_CARENCIA_INCORRECTO, null, null, null);
                                    }
                                }
                            }
                            // 2016-10-13 - El plazo de amortizacion debe ser > que el plazo de carencia
                            if (0 >= datosSolicitud.getPlazoTotal().compareTo(datosSolicitud.getPlazoCarencia())) {
                                // Si el plazo de la solicitud es <= que el plazo de carencia: NOK
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_PLAZO_SOL_MENOR_IGUAL_PLAZO_CARENCIA, null, null, null);
                            }
                            // 2016-11-24 - El importe debe ser > que el plazo
                            if (0 >= datosSolicitud.getImporteTotal().compareTo(datosSolicitud.getPlazoTotal())) {
                                // Si importe total <= plazo: NOK
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMPORTE_MENOR_IGUAL_PLAZO, null, null, null);
                            }
                        }
                        UtilidadesComun.esImporteValido(datosSolicitud.getTipoExpediente(), datosSolicitud.getImporteTotal(), true, false);
                        // actualizar indicador en solicitud
                        if (0 == datosSolicitud.getSubrogacionOtraEntidad().compareTo(new BigDecimal(3))) {
                            if (StringUtils.isNotBlank(paramMargenFVctoStr)) {
                                final Date dateNow = new Date(DateUtils.dateNow().getTime());
                                Calendar calendar = Calendar.getInstance();
                                calendar.setTime(dateNow);
                                final BigDecimal bidPlazoTotal = datosSolicitud.getPlazoTotal();
                                final String unidadPlazoTotal = datosSolicitud.getUnidadPlazo();
                                if (IConstantesSolicitud.CTE_UNIDAD_ANOS.equals(unidadPlazoTotal)) {
                                    calendar.add(Calendar.YEAR, bidPlazoTotal.intValue());
                                } else if (IConstantesSolicitud.CTE_UNIDAD_MESES.equals(unidadPlazoTotal)) {
                                    calendar.add(Calendar.MONTH, bidPlazoTotal.intValue());
                                } else {
                                    calendar.add(Calendar.DATE, bidPlazoTotal.intValue());
                                }
                                final Date dateFecOper = new Date(calendar.getTime().getTime());
                                if (null != datosSolicitud.getFechaVencimientoFinal()) {
                                    final Date fecVctoFin = datosSolicitud.getFechaVencimientoFinal();
                                    if (0 != fecVctoFin.compareTo(DateUtils.parseDate(DateUtils.CTE_DATELOWESTONLYDAY, DateUtils.FORMATO_FECHA_AMERICANO))) {
                                        calendar.setTime(fecVctoFin);
                                        calendar.add(Calendar.DATE, Integer.valueOf(paramMargenFVctoStr));
                                        final Date dateFecVctoMargen = new Date(calendar.getTime().getTime());
                                        if (0 < dateFecOper.compareTo(dateFecVctoMargen)) {
                                            datosSolicitud.setBidIndFecVctoMayorFecOpe(BigDecimal.ONE);
                                        }
                                    }
                                }
                            }
                        }
                        if (0 >= datosSolicitud.getImporteTotal().compareTo(datosSolicitud.getPlazoTotal())) {
                            // Si importe total <= plazo: NOK
                            ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMPORTE_MENOR_IGUAL_PLAZO, null, null, null);
                        }
                        // Si expediente ampliacion comprobar importe deposito ampliado
                        if (null != datosSolicitud.getTipoExpediente() && 0 == ConstantesComun.EXPEDIENTE_AMPLIACION.compareTo(datosSolicitud.getTipoExpediente())) {
                            // Para introducir importe deposito ampliado hay que seleccionar SI en el combo de deposito
                            if (StringUtils.equals(datosSolicitud.getDeposito(), "0") && 0 < datosSolicitud.getImporteDepositoAmpliado().compareTo(BigDecimal.ZERO)) {
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMP_DEPOSITO_AMPLI_SIN_DEPOSITO, null, null, null);
                            }
                            // 2018-02-21 - Si tiene deposito origen, el importe deposito de la parte ampliada debe ser igual que el importe ampliado
                            if (0 != datosSolicitud.getImporteDepositoOrigen().compareTo(BigDecimal.ZERO)) {
                                if (0 != datosSolicitud.getImporteDepositoAmpliado().compareTo(datosSolicitud.getImporteAmpliado())) {
                                    // Si importe deposito parte ampliada <> importe ampliado: NOK
                                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMP_DEPOSITO_AMPLI_DISTINTO_IMP_AMPLI, null, null, null);
                                }
                            } else // Si no tiene deposito origen, el importe deposito ampliado tiene que ser menor o igual que el importe ampliado
                            if (0 < datosSolicitud.getImporteDepositoAmpliado().compareTo(datosSolicitud.getImporteAmpliado())) {
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMP_DEPOSITO_AMPLI_MAYOR_IMP_AMPLI, null, null, null);
                            }
                        }
                        break;
                    case // paso 3
                    3:
                        // INICIO: COMPROBACION DE QUE EL TIPO TECLEADO MENOS LA BONIFICACION MAXIMA ES MAYOR QUE 0
                        List<CondicionesInteresC> lstCondicionesInteres = GestionCondicionesInteres.buscarCondicionesInteres(datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud().intValue(), datosSolicitud.getDatosSolicitudKey().getVersionSolicitud().intValue(), nuc.intValue());
                        Integer plazoTramoInicial = null;
                        if ((null != lstCondicionesInteres) && (0 < lstCondicionesInteres.size())) {
                            // Comprobamos si alguno de los tipos de intereses es bonificable
                            if (UtilidadesTramitacion.esBonificable(lstCondicionesInteres)) {
                                for (CondicionesInteresC condicionInteres : lstCondicionesInteres) {
                                    Integer ordenInteres = condicionInteres.getCondicionesInteresKey().getIntOrdenDelTramo();
                                    if (0 == BigDecimal.ONE.compareTo(new BigDecimal(ordenInteres))) {
                                        plazoTramoInicial = condicionInteres.getIntPlazo();
                                        break;
                                    }
                                // del if
                                }
                                if (plazoTramoInicial != null) {
                                    // Si alguno es bonificable, obtenemos la bonificacion maxima
                                    BigDecimal bonificacionMaxima = UtilidadesTramitacion.obtenerBonificacionMaxima(datosSolicitud.getProducto(), datosSolicitud.getSubproducto(), datosSolicitud.getIdTarifa(), nuc, new BigDecimal(plazoTramoInicial), datosSolicitud.getVersionGeneral());
                                    for (CondicionesInteresC condicionInteres : lstCondicionesInteres) {
                                        if (condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_BONIFICABLE) || condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_CON_DIFER_BONIF) || condicionInteres.getStrTipoDeInteres().equals(IConstantesSolicitud.CTE_TIPO_INTERES_VARIABLE_PENALIZABLE)) {
                                            BigDecimal interesTramo = null;
                                            Integer tipoRefStrTramo = condicionInteres.getIntTipoReferencia();
                                            // Si no es referenciado, (diferencial + tipo referencia) - bonificacion
                                            if (GestionConsultaDatosSolicitud.esTipoReferenciaNoReferenciado(tipoRefStrTramo.toString())) {
                                                interesTramo = condicionInteres.getIntTecho();
                                            } else {
                                                // Llamada al PTMO_130
                                                BigDecimal interesTipoRefTramo = GestionConsultaDatosSolicitud.obtenerInteresTipoReferencia(tipoRefStrTramo.toString());
                                                // interesTipoReferencia <= 0
                                                if ((null == interesTipoRefTramo) || (0 <= BigDecimal.ZERO.compareTo(interesTipoRefTramo))) {
                                                    interesTipoRefTramo = BigDecimal.ZERO;
                                                }
                                                BigDecimal diferencialTramo = condicionInteres.getIntDif();
                                                MathContext mathContextPrecision17 = new MathContext(17, RoundingMode.HALF_UP);
                                                interesTramo = interesTipoRefTramo.add(diferencialTramo, mathContextPrecision17);
                                            }
                                            BigDecimal calculoInteres = interesTramo.subtract(bonificacionMaxima);
                                            if (calculoInteres.compareTo(BigDecimal.ZERO) == -1) {
                                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_TIPO_TECLEADO_BONIFICACION_MAYOR_0, null, new String[] { condicionInteres.getCondicionesInteresKey().getIntOrdenDelTramo().toString(), interesTramo.toString(), bonificacionMaxima.toString() }, null);
                                            }
                                        }
                                    // comprobacion si el tipo de interes es 3,4 o 5
                                    }
                                // del for
                                }
                            // plazoTramoinicial != null
                            }
                        // si es bonificable
                        }
                        // COMPROBACION: SI ES 5005,SUBPRODUCTO 496 Y TARIFA 7, EL DESTINO SOLO PUEDE SER 5202
                        if ((0 == datosSolicitud.getProducto().compareTo(new BigDecimal(5005))) && 0 == datosSolicitud.getSubproducto().compareTo(new BigDecimal(496)) && 0 == datosSolicitud.getIdTarifa().compareTo(new BigDecimal(7))) {
                            List<DestinosC> lstDestinos = datosSolicitud.getDestinos();
                            if (null != lstDestinos) {
                                int i = 0;
                                int size = lstDestinos.size();
                                boolean destinoValido = true;
                                while (i < size) {
                                    DestinosC destinoC = lstDestinos.get(i);
                                    if (destinoC.getDestino().compareTo(ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS) != 0) {
                                        destinoValido = false;
                                        i = size;
                                    } else {
                                        i++;
                                    }
                                }
                                if (!destinoValido) {
                                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_TARIFA_CAPTACION_DESTINO_5202, null, null, null);
                                }
                            }
                        }
                        if (!UtilidadesComun.esPersonal(datosSolicitud)) {
                            if ((tarifaGi.equals(tarifaGrupoInmovi)) && !(grupoInmo.equals(grupoInmovi))) {
                                // si la tarifa no es 4 y el grupo no es 1
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_GRUPO_INMOBI_NO_VALIDO, null, new String[] {}, null);
                            }
                        }
                        // Si es ASF, se comprueba que la tarifa sea valida para ese plazo
                        if (UtilidadesComun.esASF(datosSolicitud.getEntidad())) {
                            // Obtenemos el id de tarifa que tiene asociado
                            BigDecimal idTarifa = datosSolicitud.getIdTarifa();
                            if ((!Utilidades.isBlankOrNull(idTarifa)) && (idTarifa.compareTo(BigDecimal.ZERO) != 0)) {
                                // Llamamos al ANPM_443 para obtener las tarifas validas para ese plazo
                                IContexto[] datosTarifas = UtilidadesComun.obtencionDatosTarifa(datosSolicitud.getProducto(), datosSolicitud.getSubproducto(), datosSolicitud.getVersionGeneral(), datosSolicitud.getPlazoTotal().toString(), datosSolicitud.getIdTarifa(), Constantes.CTE_ORIGEN_CONSULTA_TARIFA_SOLICITUD, datosSolicitud.getImporteSolicitado(), nuc, null, datosSolicitud.getEntidad());
                                // esta entre las válidas para ese plazo
                                for (IContexto datosTarifa : datosTarifas) {
                                    IRegistro[] matrizPlazosTarifa = datosTarifa.getRegistro(CTE_MATRIZ_VALORES_PRECIOS_TARIFA);
                                    int size = matrizPlazosTarifa.length;
                                    int i = 0;
                                    boolean encontrado = false;
                                    while ((i < size) && (!encontrado)) {
                                        IRegistro registro = matrizPlazosTarifa[i];
                                        if (registro.getBigDecimal(CTE_MATRIZ_ID_TARIFA).compareTo(idTarifa) == 0) {
                                            encontrado = true;
                                        } else {
                                            i++;
                                        }
                                    }
                                    // Si la tarifa que tiene asignada no esta entre las disponibles para ese plazo, le damos error
                                    if (!encontrado) {
                                        ServicioNegocio.rollback(CodigosError.CTE_ERROR_TARIFA_NO_CORRESPONDE_PLAZO, null, new String[] {}, null);
                                    }
                                }
                            }
                        }
                        break;
                    case // Paso numero 5 de solicitud, COMISIONES
                    5:
                        // SE LLAMA SOLO PARA LOS EXPEDIENTES 291-PRECONCEDIDO ABANCA o 407 - PRECONCEDIDO ASF
                        if (UtilidadesComun.esPreconcedido(datosSolicitud.getTipoExpediente())) {
                            IContexto[] ctxPreautorizado = UtilidadesComun.comprobarClienteTieneCuotaPreautorizada(nuc, datosSolicitud.getTipoExpediente());
                            BigDecimal cuotaTotal = ctxPreautorizado[0].getBigDecimal(ConstantesComun.CTX_XPREN028_CUOTA_TOTAL);
                            BigDecimal limiteTotal = ctxPreautorizado[0].getBigDecimal(ConstantesComun.CTX_XPREN028_LIMITE_TOTAL);
                            if (limiteTotal.compareTo(datosSolicitud.getImporteTotal()) < 0) {
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_IMPORTE_MAX_EXCEDIDO, null, new String[] { limiteTotal.toString() }, null);
                            }
                            // Se calcula la cuotaScoring
                            BigDecimal cuotaScoring = new ControlTriad().calculoCuotaScoring(datosSolicitud, null, null);
                            if (cuotaTotal.compareTo(cuotaScoring) < 0) {
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_CUOTA_MAX_EXCEDIDO, null, new String[] { cuotaTotal.toString(), cuotaScoring.toString() }, null);
                            }
                        }
                        // COMPROBACION: SI ES 5005,SUBPRODUCTO 496 Y TARIFA 7, EL DESTINO SOLO PUEDE SER 5202
                        if ((0 == datosSolicitud.getProducto().compareTo(new BigDecimal(5005))) && 0 == datosSolicitud.getSubproducto().compareTo(new BigDecimal(496)) && 0 == datosSolicitud.getIdTarifa().compareTo(new BigDecimal(7))) {
                            List<DestinosC> lstDestinos = datosSolicitud.getDestinos();
                            if (null != lstDestinos) {
                                int i = 0;
                                int size = lstDestinos.size();
                                boolean destinoValido = true;
                                while (i < size) {
                                    DestinosC destinoC = lstDestinos.get(i);
                                    if (destinoC.getDestino().compareTo(ConstantesComun.DESTINO_CANCELACION_OTRAS_DEUDAS) != 0) {
                                        destinoValido = false;
                                        i = size;
                                    } else {
                                        i++;
                                    }
                                }
                                if (!destinoValido) {
                                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_TARIFA_CAPTACION_DESTINO_5202, null, null, null);
                                }
                            }
                        }
                        // FIN COMPROBACION
                        // 2016-06-07 - Si la ultima version completa de la solicitud esta
                        // en estado 6 (formalizada) no se permite modificar la solicitud.
                        GestionDatosSolicitud gds = new GestionDatosSolicitud();
                        DatosSolicitudC datosSolicitudUltimaVsCompleta = gds.getUltimaVersionCompleta(nuc);
                        DatosSolicitudC datosSolicitudUltimaIncompleta = gds.getUltimaVersionIncompleta(nuc);
                        // 2017-12-14 - La solicitud no puede tener mda = 2 y pago único
                        // a vencimiento final (campos AN260090 = 2 y AN260180=1)
                        List<CondicionCapitalC> condicionesCapital = datosSolicitud.getCondicionesCapital();
                        if ((null != condicionesCapital) && (0 < condicionesCapital.size())) {
                            for (CondicionCapitalC condicionCapital : condicionesCapital) {
                                if ((condicionCapital.getIntModalidadDeAmortizacion().equals(Constantes.CTE_DOS)) && (condicionCapital.getStrPagoUnicoVencimientoFinal().equals(Constantes.CTE_UNO))) {
                                    ServicioNegocio.rollback(// Codigo error
                                    CodigosError.CTE_ERROR_MDA_INCOMPATIBLE_PAGO_UNICO_VENC_FINAL, // Titulo
                                    null, // Descripcion
                                    new String[] {}, // Solucion
                                    null);
                                }
                            }
                        }
                        /**
                         * Comprobar si los tramos de comision están correctamente introducidos.
                         * sólo si el expediente es hipotecario (08-11-2017)
                         */
                        boolean esHipotecario = false;
                        esHipotecario = UtilidadesTramitacion.esHipotecario2(datosSolicitud.getTipoExpediente());
                        if (esHipotecario) {
                            GestionComprobaciones.comprobarTramosComision(datosSolicitud);
                        }
                        if ((null != datosSolicitudUltimaVsCompleta) && (0 == datosSolicitudUltimaVsCompleta.getEstadoSolicitud().compareTo(Constantes.CTE_BID_6))) {
                            // Enviar correo para notificar que se ha producido un intento
                            // de modificacion de solicitud ya formalizada.
                            enviarCorreoModificacionSolicitudFormalizada(nuc);
                            // Rollback
                            ServicioNegocio.rollback(CodigosError.CTE_ERROR_GRUPO_INMOBI_NO_VALIDO, null, new String[] {}, null);
                        }
                        if (null != datosSolicitud) {
                            // Se invoca al método ANPM_048 con el paso 9 para que devuelva sólo los contexto 1 y 2 y poder recuperar la tarifa
                            resultado48 = invocacionMetodo048((Integer.parseInt(datosSolicitud.getProducto().toString())), (Integer.parseInt(datosSolicitud.getSubproducto().toString())), (Integer.parseInt(datosSolicitud.getVersionGeneral().toString())), (ComprobacionConstantes.CTE_LOCAL_PASO_9));
                            for (IContexto tarifaRecuperada : resultado48) {
                                tarifa = tarifaRecuperada.getString(ComprobacionConstantes.CTE_LOCAL_CAMPO_TARIFA);
                            }
                            /**
                             * Fecha: 10/05/2017
                             * Motivo: Incidencia en explotación
                             *
                             * Se cambia la comprobacion del colectivo que se estaba haciendo sobre la ultima version
                             * completa por la ultima version incompleta. Si venia de una solicitud que previamente no
                             * tenia un colectivo fallaba la comprobación.
                             */
                            if (null != datosSolicitudUltimaIncompleta && 0 == BigDecimal.ZERO.compareTo(datosSolicitudUltimaIncompleta.getIdColectivo())) {
                                // La comprobacion solo se hace si el colectivo es 0
                                if (// si la tarifa tiene valor 1
                                (ComprobacionConstantes.CTE_LOCAL_UNO.equals(tarifa)) && // la tarifa de la solicitud es 0
                                (0 == ComprobacionConstantes.CTE_LOCAL_CERO.compareTo(datosSolicitudUltimaIncompleta.getIdTarifa()))) {
                                    // rollback
                                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_TARIFA_CON_VALOR_INCORRECTO, null, new String[] {}, null);
                                }
                            }
                        }
                        // Comprobaciones prescriptores
                        if (estadoPrescriptor(nuc)) {
                            // Llamada al servicio ANPM_471 de comprobacion de prescriptores
                            UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_1);
                        }
                        // Se muestra mensaje según la solicitud vaya por circuito corto o largo.
                        // Devuelve vacío si no es ninguno de los dos casos.
                        mensajeAdvertencia = new ControlTriad().advertenciaCircuito(nuc, indOperacion);
                        if (StringUtils.isNotEmpty(mensajeAdvertencia)) {
                            mensajeError = StringUtils.EMPTY;
                        }
                        gds = new GestionDatosSolicitud();
                        DatosSolicitudC solicitud = gds.getUltimaVersionIncompleta(nuc);
                        mensajeAdvertencia2 = compruebaOperacionTarjetizable(solicitud, false);
                        if (StringUtils.isNotEmpty(mensajeAdvertencia2)) {
                            mensajeError2 = StringUtils.EMPTY;
                        }
                        // Se excluye el expediente correspondiente con 150021 de la comprobacion de la vigencia del producto
                        if (UtilidadesTramitacion.comprobarControlOperatoria(nuc, new BigDecimal(150021), true)) {
                            Date fechaHoy = new Date(DateHelper.getInstance().askTime().getTime());
                            String fechaHoyStr = DateHelper.sqlDateToString(fechaHoy, DateHelper.FORMATO_DD_MM_YYYY_GUION);
                            // Comprobamos la vigencia del producto a la fecha actual
                            GestionPreformalizacionFormalizacionComunes gpfc = new GestionPreformalizacionFormalizacionComunes();
                            gpfc.comprobarVigenciaProducto(datosSolicitud, fechaHoyStr);
                        }
                        GestionComprobaciones.comprobarPlazos(datosSolicitudUltimaIncompleta);
                        // Comprobaciones que solo se hacen en el caso de que sea ASF
                        if (UtilidadesComun.esASF(datosSolicitud.getEntidad())) {
                            GestionComprobaciones.comprobarPrescriptoresASF(datosSolicitud);
                            GestionComprobaciones.comprobarComisionesASF(datosSolicitud);
                            GestionComprobaciones.comprobarPeriodoLiquidacion(datosSolicitud);
                        }
                        break;
                    case // paso de preformalización de una solicitud.
                    6:
                        if (estadoPrescriptor(nuc)) {
                            // Llamada al servicio ANPM_471 de comprobacion de prescriptores
                            UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_2);
                        }
                        // Comprobacion de la CER y la TAE: solo se hace en el caso de subrogacion otra entidad (3)
                        if (0 == datosSolicitud.getSubrogacionOtraEntidad().compareTo(new BigDecimal(3))) {
                            if ((datosSolicitud.getTAE().compareTo(datosSolicitud.getCosteEfectivoRemanente())) > 0) {
                                resultado = "8";
                                mensajeError = "";
                                mensajeAdvertencia = new Mensaje(ServicioNegocio.getContexto(), TAE_MAYOR_CER_2028012624).toString();
                            }
                        }
                        break;
                    case // paso de formalización de una solicitud.
                    7:
                        if (estadoPrescriptor(nuc)) {
                            // Llamada al servicio ANPM_471 de comprobacion de prescriptores
                            UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_3);
                        }
                        // Si los precios estan caducados no se permite formalizar
                        if (comprobarCaducidadPrecios(nuc)) {
                            boolean preciosCaducados = UtilidadesTramitacion.comprobarPreciosCaducados(datosSolicitud);
                            if (preciosCaducados) {
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_PRECIO_CADUCADO, null, new String[] {}, null);
                            }
                        }
                        break;
                    case // impresion de la solicitud-contrato
                    8:
                        if (estadoPrescriptor(nuc)) {
                            // Llamada al servicio ANPM_471 de comprobacion de prescriptores
                            UtilidadesComun.comprobacionPrescriptores(nuc, ConstantesComun.CTE_BID_4);
                        }
                        // Si los precios estan caducados no se permite imprimir
                        if (comprobarCaducidadPrecios(nuc)) {
                            boolean preciosCaducados = UtilidadesTramitacion.comprobarPreciosCaducados(datosSolicitud);
                            if (preciosCaducados) {
                                ServicioNegocio.rollback(CodigosError.CTE_ERROR_PRECIO_CADUCADO, null, new String[] {}, null);
                            }
                        }
                        break;
                    case // comprobacion cambio de producto permitido
                    9:
                        // Se comprueba si se permite cambiar el producto de la solicitud o no.
                        // Se permite siempre que en la AN40TB01 no haya ninguna version de la
                        // solicitud enviada a e-notario (estado 01).
                        boolean puedeCambiarProducto = puedeCambiarProducto(nuc);
                        if (!puedeCambiarProducto) {
                            // ServicioNegocio.rollback(
                            // CodigosError.CTE_ERROR_CAMBIO_PRODUCTO_NO_PERMITIDO,
                            // null,
                            // new String [] {nuc.toString()},
                            // null
                            // );
                            resultado = ComprobacionConstantes.CTE_COD_ERROR_CAMBIO_PRODUCTO_NO_PERMITIDO;
                            mensajeError = ComprobacionConstantes.CTE_TXT_ERROR_CAMBIO_PRODUCTO_NO_PERMITIDO;
                        }
                        break;
                }
            // fin switch
            }
        }
        IContexto[] salida = new IContexto[2];
        salida[0] = ContextoFactory.getInstance().getContexto("ANPMN454");
        salida[0].put("ANPMN454010", resultado);
        salida[0].put("ANPMN454020", mensajeError);
        // 20151223:  se añade campo para mostar advertencia
        salida[0].put("ANPMN454030", mensajeAdvertencia);
        salida[0].put("ANPMN454040", destinoErroneo);
        salida[1] = ContextoFactory.getInstance().getContexto("ANPMN454");
        salida[1].put("ANPMN454010", resultado);
        salida[1].put("ANPMN454020", mensajeError2);
        // 20151223:  se añade campo para mostar advertencia
        salida[1].put("ANPMN454030", mensajeAdvertencia2);
        salida[1].put("ANPMN454040", destinoErroneo);
        return salida;
    }

    // fin ejecutar
    private boolean perteneceAgrupacion(List<BigDecimal> valoresAgrupacion, BigDecimal producto) {
        boolean resultado = false;
        for (BigDecimal param : valoresAgrupacion) {
            if (// si es el producto 5804 o 5806
            param.compareTo(producto) == 0) {
                resultado = true;
            }
        }
        return resultado;
    }

    /**
     * Metodo que comprueba si es necesario realizar las comprobaciones de prescriptores
     * para el nuc recibido como entrada, segun lo indicado por el control de operatoria
     * para ese nuc.
     *
     * @param nuc nuc para el que se llamara a control de operatoria.
     * @return true si es necesario comprobar la caducidad de los precios, false en
     *         caso contrario.
     */
    private // control de operatoria para prescriptores
    boolean estadoPrescriptor(// control de operatoria para prescriptores
    BigDecimal nuc) {
        boolean salida = false;
        salida = UtilidadesTramitacion.comprobarControlOperatoria(nuc, ConstantesComun.CTE_CONTROL_OPERATORIA_COMP_PRESCRIP, true);
        return salida;
    }

    /**
     * Metodo que comprueba si es necesario comprobar la caducidad de los precios para
     * el nuc recibido como entrada, segun lo indicado por el control de operatoria
     * para ese nuc.
     *
     * @param nuc nuc para el que se llamara a control de operatoria.
     * @return true si es necesario comprobar la caducidad de los precios, false en
     *         caso contrario.
     */
    private boolean comprobarCaducidadPrecios(BigDecimal nuc) {
        boolean comprobarCaducidadPrecios = false;
        comprobarCaducidadPrecios = UtilidadesTramitacion.comprobarControlOperatoria(nuc, ConstantesComun.CTE_CONTROL_OPERATORIA_COMP_CADUCIDAD_PRECIOS, true);
        return comprobarCaducidadPrecios;
    }

    /**
     * Obtiene los datos de la solicitud en funcion del paso:
     * Para pasos del 1 al 5: se obtiene la ultima version incompleta.
     * Para el paso 9: no es necesaria la solicitud, no se incluye.
     * Para resto de pasos: se obtiene la ultima version completa.
     *
     * @param nuc NUC de la solicitud
     * @param paso paso con el que se llama al servicio
     * @param error indica si se produce error al obtener la solicitud de la tabla
     *              AN25TB01 (0: no hay error, 1: ultima version incompleta
     *              no encontrada, 2: ultima version completa no encontrada)
     * @return objeto DatosSolicitudC
     */
    private DatosSolicitudC getDatosSolicitud(BigDecimal nuc, int paso, int error) {
        // Inicializaciones
        GestionDatosSolicitud gds = new GestionDatosSolicitud();
        DatosSolicitudC datosSolicitud = null;
        error = 0;
        // En funcion del paso, se obtiene la ultima version completa o la ultima version incompleta
        switch(paso) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                {
                    datosSolicitud = gds.getUltimaVersionIncompleta(nuc);
                    if (null == datosSolicitud) {
                        error = 1;
                    }
                    break;
                }
            case 6:
            case 7:
            case 8:
                {
                    datosSolicitud = gds.getUltimaVersionCompleta(nuc);
                    if (null == datosSolicitud) {
                        error = 2;
                    }
                    break;
                }
        }
        // Devolver datos solicitud
        return datosSolicitud;
    }

    /**
     * Metodo que envia un correo de notificacion para el caso de que se haya tratado
     * de modificar una solicitud que ya estaba formalizada.
     *
     * @param nuc NUC de la solicitud que se ha tratado de modificar.
     */
    private void enviarCorreoModificacionSolicitudFormalizada(BigDecimal nuc) {
        // Inicializaciones
        List<String> destinatarios = new ArrayList<String>();
        String asunto = null;
        String remitenteNombre = null;
        String autor = null;
        // Establecer autor, destinatarios y asunto
        autor = UtilidadesTramitacion.obtenerValorParametroUnico(ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_AUTOR);
        destinatarios = UtilidadesTramitacion.obtenerListaValoresParametro(ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_DESTINATARIOS);
        asunto = UtilidadesTramitacion.obtenerValorParametroUnico(ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_ASUNTO);
        if (UtilidadesTramitacion.isBlankOrNull(destinatarios)) {
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO, null, new String[] { ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_DESTINATARIOS }, null);
        } else if (StringUtils.isBlank(asunto)) {
            ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_SE_ENCUENTRA_PARAMETRO, null, new String[] { ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, ComprobacionConstantes.CTE_AGRUP_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA_ASUNTO }, null);
        }
        // Incluir NUC en la plantilla
        Map<String, Object> model = new HashMap<String, Object>(1);
        model.put("PARAM_1", nuc);
        // Enviar correo
        UtilidadesTramitacion.enviarCorreo(destinatarios.toArray(new String[destinatarios.size()]), asunto, autor, remitenteNombre, ComprobacionConstantes.CTE_PLANTILLA_MAIL_MODIFICACION_SOLICITUD_FORMALIZADA, model);
    }

    /**
     * Metodo que determina si se puede cambiar el producto de la solicitud, en
     * funcion de si la solicitud ha sido enviada alguna vez a enotario o no.
     *
     * @param nuc NUC de la solicitud
     * @return true si se permite cambiar el producto de la solicitud, false en
     *         caso contrario.
     */
    private boolean puedeCambiarProducto(BigDecimal nuc) {
        // Inicializaciones
        boolean puedeCambiarProducto = true;
        GestionDatosGeneralesEnotario gdge = new GestionDatosGeneralesEnotario();
        // Obtener datos generales enotario por nuc y estado enviado (01).
        List<DatosgeneralesC> listaDatosGenerales = gdge.obtenerDatosGeneralesPorNucEstado(nuc, ComprobacionConstantes.CTE_ENOTARIO_ESTADO_ENVIADO);
        // Comprobar si se permite cambiar el producto
        if ((null != listaDatosGenerales) && (0 < listaDatosGenerales.size())) {
            // Si hay alguna version de la solicitud en la tabla AN40TB01 con estado
            // enviado a enotario, no se permite cambiar el producto.
            puedeCambiarProducto = false;
        }
        // Devolver resultado
        return puedeCambiarProducto;
    }

    /**
     * Llamada a método ANPM_048
     *
     * @param idProducto
     * @param subProducto
     * @param versionGeneral
     * @param paso
     *
     * @return IContexto
     */
    private IContexto[] invocacionMetodo048(Integer idProducto, Integer subProducto, Integer versionGeneral, BigDecimal paso) {
        IContexto[] salida507048 = new IContexto[] {};
        IDatosEntradaTx datosEntradaTx507048 = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), Integer.valueOf(ComprobacionConstantes.CTE_LOCAL_CC), Integer.valueOf(ComprobacionConstantes.CTE_LOCAL_CO48));
        datosEntradaTx507048.addCampo("Codigo_producto", new BigDecimal(idProducto));
        datosEntradaTx507048.addCampo("Codigo_subproducto", new BigDecimal(subProducto));
        datosEntradaTx507048.addCampo("Colectivo", BigDecimal.ZERO);
        datosEntradaTx507048.addCampo("Version_general", new BigDecimal(versionGeneral));
        datosEntradaTx507048.addCampo("Paso", paso);
        salida507048 = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), datosEntradaTx507048);
        return salida507048;
    }

    /**
     * Comprueba si una operación debe ser tarjetizable o no y avisa de ello.
     * Se le puede agregar la comprobación de que no tenga corretaje pasándole un true como segundo parámetro.
     *
     * @param solicitud
     * @return
     */
    private String compruebaOperacionTarjetizable(DatosSolicitudC solicitud, boolean comprobacionCorretaje) {
        String advertencia = StringUtils.EMPTY;
        if (null != solicitud && null != solicitud.getImporteSolicitado() && null != solicitud.getDatosSolicitudKey() && null != solicitud.getDatosSolicitudKey().getNucExpediente() && UtilidadesComun.esPersonal(solicitud) && !excepcionParametrizada(solicitud)) {
            // Si el préstamo es de < 6000 euros (CGAL_373)
            boolean prestamoInferiorALimite = false;
            IDatosEntradaTx entrada = ServicioNegocio.getPrograma(ServicioNegocio.getContexto(), 100, 373);
            entrada.addCampo("OPCION_A_B_C_D_M_Y_O", "C");
            entrada.addCampo("CLAVE_DE_APLICACION", "PAR");
            entrada.addCampo("CLAVE_DE_PARAMETRO", "OTAR");
            IContexto[] salida = ServicioNegocio.invocarServicio(ServicioNegocio.getContexto(), entrada);
            if (null != salida && 0 < salida.length && null != salida[0] && // Importe 1 de la CG32, límite para préstamo tarjetizable
            null != salida[0].getBigDecimal("CG151C110") && // Importe inferior al límite parametrizado
            0 > solicitud.getImporteSolicitado().compareTo(salida[0].getBigDecimal("CG151C110"))) {
                prestamoInferiorALimite = true;
            }
            // Y no hay más de un interviniente (titular o avalista) (UtilidadesTramitacion.consultarParticipantesPorNuc)
            boolean unicoParticipante = false;
            IContexto[] participantes = UtilidadesTramitacion.consultarParticipantesPorNuc(solicitud.getDatosSolicitudKey().getNucExpediente());
            if (null != participantes && 1 == participantes.length) {
                unicoParticipante = true;
            }
            // No es de convenio con colectivo (¬ convenio eq. colectivo (an251630 = 0))
            boolean noTieneColectivo = false;
            if (0 == BigDecimal.ZERO.compareTo(solicitud.getIdColectivo())) {
                noTieneColectivo = true;
            }
            // Si se ha activado la comprobación adicional no debe tener corretaje, si no siempre será true
            if (comprobacionCorretaje) {
                comprobacionCorretaje = "N".equals(solicitud.getCorretaje());
            } else {
                comprobacionCorretaje = true;
            }
            // Si se cumplen las condiciones para ser tarjetizable se informa de ello.
            if (prestamoInferiorALimite && unicoParticipante && noTieneColectivo && comprobacionCorretaje) {
                // -> Aviso Operación Tarjetizable. Consulta excepciones para poder continuar y se deja continuar
                advertencia = new Mensaje(ServicioNegocio.getContexto(), OPERACI_N_TARJETIZABLE_CONSULTA_EXCEPCIONES_CONTI_889485551).toString();
            }
        }
        return advertencia;
    }

    /**
     * Método auxiliar que comprueba si una solicitud está marcada como excepción en la AN82.
     * Éstas se registran bajo la agrupación EX_TARIFA, con la clave TERNA_TARIFA y un valor
     * con el formato PRODUCTO;SUBPRODUCTO;TARIFA
     *
     * @param solicitud
     * @return
     */
    private boolean excepcionParametrizada(DatosSolicitudC solicitud) {
        boolean esExcepcion = false;
        List<String> parametros = UtilidadesTramitacion.obtenerParametrosANPM("EX_TARIFA", "TARIFA");
        if (null != parametros) {
            for (String parametro : parametros) {
                String[] ternaTarifa = parametro.split(";");
                if (null != ternaTarifa && 3 == ternaTarifa.length && null != ternaTarifa[0] && null != ternaTarifa[1] && null != ternaTarifa[2]) {
                    if (null != solicitud && null != solicitud.getProducto() && null != solicitud.getSubproducto() && null != solicitud.getIdTarifa() && solicitud.getProducto().toString().equals(ternaTarifa[0].trim()) && solicitud.getSubproducto().toString().equals(ternaTarifa[1].trim()) && solicitud.getIdTarifa().toString().equals(ternaTarifa[2].trim())) {
                        esExcepcion = true;
                    }
                }
            }
        }
        return esExcepcion;
    }

    private static final String EJECUCI_N_CORRECTA_189320740 = "EJECUCI_N_CORRECTA_189320740";

    private static final String COMPROBACI_360737679 = "COMPROBACI_360737679";

    private static final String COMPRPLHFB_359509435 = "COMPRPLHFB_359509435";

    private static final String PORCENTAJE_DESTINO_1432432151 = "PORCENTAJE_DESTINO_1432432151";

    private static final String _OPERACI_N_ELEVAR_CAR_1079402046 = "_OPERACI_N_ELEVAR_CAR_1079402046";

    private static final String ERROR_COMPROBACION_PORCENTAJE_1802470137 = "ERROR_COMPROBACION_PORCENTAJE_1802470137";

    private static final String _CANCELACI_N_PR_STAMOS_SUPERA_287175975 = "_CANCELACI_N_PR_STAMOS_SUPERA_287175975";

    private static final String OPERACI_N_TARJETIZABLE_CONSULTA_EXCEPCIONES_CONTI_889485551 = "OPERACI_N_TARJETIZABLE_CONSULTA_EXCEPCIONES_CONTI_889485551";

    private static final String CARACTER_STICAS_OPERACI_N_CUMPLEN_SUBPRODUCTO_1_2107577050 = "CARACTER_STICAS_OPERACI_N_CUMPLEN_SUBPRODUCTO_1_2107577050";

    private static final String COMPROBACI_N_DESTINOS_200562431 = "COMPROBACI_N_DESTINOS_200562431";

    private static final String CONFORME_PLAZO_SOLICITADO_FECHA_VENCIMIENTO_PR_ST_287752658 = "CONFORME_PLAZO_SOLICITADO_FECHA_VENCIMIENTO_PR_ST_287752658";

    private static final String _OBRAS_MEJORAS_IMPORTE_SOLICITADO_SUPERA_991259466 = "_OBRAS_MEJORAS_IMPORTE_SOLICITADO_SUPERA_991259466";

    private static final String TAE_MAYOR_CER_2028012624 = "TAE_MAYOR_CER_2028012624";
}
