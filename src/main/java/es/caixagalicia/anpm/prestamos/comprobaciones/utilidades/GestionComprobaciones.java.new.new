package es.caixagalicia.anpm.prestamos.comprobaciones.utilidades;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import es.caixagalicia.anpm.prestamos.comun.constantes.ConstantesComun;
import es.caixagalicia.anpm.prestamos.comun.utilidades.UtilidadesComun;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.comisiones.ComisionC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.destinos.DestinosC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionCapitalC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.producto.CondicionesInteresC;
import es.caixagalicia.anpm.prestamos.tramitacion.persistencia.solicitud.DatosSolicitudC;
import es.caixagalicia.anpm.prestamos.tramitacion.servicios.aplicacion.GestionCondicionesInteres;
import es.caixagalicia.anpm.prestamos.tramitacion.utilidades.Constantes;
import es.caixagalicia.ifrt.core.ServicioNegocio;
import es.caixagalicia.ifrt.mensajes.Mensaje;

public class GestionComprobaciones {

    public static final Integer CTE_UNO_INT = new Integer(1);

    public static final Integer CTE_DOS_INT = new Integer(2);

    private static final int CTE_ERROR_COMISIONES_PORCENTAJE = 13792;

    private static final int CTE_ERROR_PLAZOS = 14273;

    private static final int CTE_ERROR_ROBO_HIPOTECA = 13823;

    private static final BigDecimal CTE_HIPOTECA_MC_FIJA = new BigDecimal(5804);

    private static final BigDecimal CTE_HIPOTECA_MC_VARIABLE = new BigDecimal(5806);

    private static final BigDecimal CTE_SUBPRODUCTO_ROBO = new BigDecimal(2);

    /**
     * La suma de los plazos de los tramos de interés debe ser igual al plazo total.
     * @param datosSolicitud
     */
    public static void comprobarPlazos(DatosSolicitudC datosSolicitud) {
        Integer plazoTotalTramos = 0;
        List<CondicionesInteresC> listaCondicionesInteres = new ArrayList<CondicionesInteresC>();
        // Sumamos los plazos de todos los tramos de interes que no sean sustitutivos
        listaCondicionesInteres = datosSolicitud.getCondicionesInteres();
        for (CondicionesInteresC condicion : listaCondicionesInteres) {
            if (condicion.getCondicionesInteresKey().getIntTipoCondicion().equals(Constantes.CTE_INT_CERO)) {
                plazoTotalTramos = plazoTotalTramos + condicion.getIntPlazo();
            }
        }
        if (!plazoTotalTramos.equals(datosSolicitud.getPlazoTotal().intValue())) {
            // Rollback
            ServicioNegocio.rollback(CTE_ERROR_PLAZOS, null, new String[] {}, null);
        }
    }

    /**
     * Comprueba para las comisiones de desistimiento 009 y 010
     * Así como para las de amortización 001 y 004
     * Que el primer tramo de comision debe ser mayor que el segundo.
     * @param datosSolicitud
     */
    public static void comprobarTramosComision(DatosSolicitudC datosSolicitud) {
        StringBuffer cadenaDeError = new StringBuffer("");
        BigDecimal porcentajeTramoUno009 = BigDecimal.ZERO;
        BigDecimal porcentajeTramoDos009 = BigDecimal.ZERO;
        BigDecimal porcentajeTramoUno010 = BigDecimal.ZERO;
        BigDecimal porcentajeTramoDos010 = BigDecimal.ZERO;
        BigDecimal porcentajeTramoUno001 = BigDecimal.ZERO;
        BigDecimal porcentajeTramoDos001 = BigDecimal.ZERO;
        BigDecimal porcentajeTramoUno004 = BigDecimal.ZERO;
        BigDecimal porcentajeTramoDos004 = BigDecimal.ZERO;
        String comisionCancelacionParcialAnticipada = new String();
        String comisionCancelacionAnticipada = new String();
        String comisionDesistimientoParcial = new String();
        String comisionDesistimientoTotal = new String();
        List<ComisionC> comisiones = datosSolicitud.getComisiones();
        /**
         * Primero busco una coincidencia
         */
        for (ComisionC comision : comisiones) {
            if (comision.getComisionesKey().getStrTipoComision().equals("009")) {
                if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_UNO_INT)) {
                    porcentajeTramoUno009 = comision.getBidPorcentajeComision();
                } else if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_DOS_INT)) {
                    porcentajeTramoDos009 = comision.getBidPorcentajeComision();
                }
            } else if (comision.getComisionesKey().getStrTipoComision().equals("010")) {
                if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_UNO_INT)) {
                    porcentajeTramoUno010 = comision.getBidPorcentajeComision();
                } else if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_DOS_INT)) {
                    porcentajeTramoDos010 = comision.getBidPorcentajeComision();
                }
            } else if (comision.getComisionesKey().getStrTipoComision().equals(Constantes.TIPO_COMISION_ADELANTO)) {
                if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_UNO_INT)) {
                    porcentajeTramoUno001 = comision.getBidPorcentajeComision();
                } else if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_DOS_INT)) {
                    porcentajeTramoDos001 = comision.getBidPorcentajeComision();
                }
            } else if (comision.getComisionesKey().getStrTipoComision().equals(Constantes.TIPO_COMISION_CANCELACION)) {
                if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_UNO_INT)) {
                    porcentajeTramoUno004 = comision.getBidPorcentajeComision();
                } else if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_DOS_INT)) {
                    porcentajeTramoDos004 = comision.getBidPorcentajeComision();
                }
            }
        }
        /**
         * Verificamos que tramo 1 de comision mayor que tramo dos
         */
        if (-1 == porcentajeTramoUno001.compareTo(porcentajeTramoDos001)) {
            // Error en la comision de amortizacion parcial anticipada
            comisionCancelacionParcialAnticipada = new Mensaje(ServicioNegocio.getContexto(), COMISI_N_CANCELACI_N_PARCIAL_ANTICIPADA_900490461).toString();
        }
        if (-1 == porcentajeTramoUno004.compareTo(porcentajeTramoDos004)) {
            // Error en la comision de cancelacion anticipada
            comisionCancelacionAnticipada = new Mensaje(ServicioNegocio.getContexto(), COMISI_N_CANCELACI_N_ANTICIPADA_1623534475).toString();
        }
        if (-1 == porcentajeTramoUno009.compareTo(porcentajeTramoDos009)) {
            // Error en la comision de desistimiento parcial
            comisionDesistimientoParcial = new Mensaje(ServicioNegocio.getContexto(), COMPENSACI_N_DESISTIMIENTO_PARCIAL_2141661014).toString();
        }
        if (-1 == porcentajeTramoUno010.compareTo(porcentajeTramoDos010)) {
            // Error en la comision de desistimiento total
            comisionDesistimientoTotal = new Mensaje(ServicioNegocio.getContexto(), COMPENSACI_N_DESISTIMIENTO_TOTAL_1963893436).toString();
        }
        if (comisionCancelacionAnticipada.length() > 0 && comisionCancelacionParcialAnticipada.length() > 0) {
            cadenaDeError.append(comisionCancelacionAnticipada);
            cadenaDeError.append(new Mensaje(ServicioNegocio.getContexto(), Y_121).toString());
            cadenaDeError.append(comisionCancelacionParcialAnticipada);
        } else if (comisionDesistimientoParcial.length() > 0 && comisionDesistimientoTotal.length() > 0) {
            cadenaDeError.append(comisionDesistimientoParcial);
            cadenaDeError.append(new Mensaje(ServicioNegocio.getContexto(), Y_121).toString());
            cadenaDeError.append(comisionDesistimientoTotal);
        } else if (comisionCancelacionAnticipada.length() > 0) {
            cadenaDeError.append(comisionCancelacionAnticipada);
        } else if (comisionCancelacionParcialAnticipada.length() > 0) {
            cadenaDeError.append(comisionCancelacionParcialAnticipada);
        } else if (comisionDesistimientoParcial.length() > 0) {
            cadenaDeError.append(comisionDesistimientoParcial);
        } else if (comisionDesistimientoTotal.length() > 0) {
            cadenaDeError.append(comisionDesistimientoTotal);
        }
        if (!UtilidadesComun.isBlankOrNull(cadenaDeError)) {
            ServicioNegocio.rollback(CTE_ERROR_COMISIONES_PORCENTAJE, null, new String[] { cadenaDeError.toString() }, null);
        }
    }

    /**
     * Comprueba para las comisiones de apertura y gastos de estudio (003 y 005)
     * que tenga la misma forma de pago (financiadas o cobro en el primer recibo)
     * Para ninguna de ellas se permite, cargo en cuenta formalizacion
     * (getBidIndCapitalizacionComDisponibilidad = 0)
     * @param datosSolicitud
     */
    public static void comprobarComisionesASF(DatosSolicitudC datosSolicitud) {
        BigDecimal porcentajeApertura = BigDecimal.ZERO;
        BigDecimal porcentajeGastosEstudio = BigDecimal.ZERO;
        BigDecimal formaPagoApertura = BigDecimal.ZERO;
        BigDecimal formaPagoGastosEstudio = BigDecimal.ZERO;
        boolean comisionAperturaEncontrada = false;
        boolean comisionGastosEstudioEncontrada = false;
        List<ComisionC> comisiones = datosSolicitud.getComisiones();
        int size = comisiones.size();
        int i = 0;
        // Se recorren las comisiones, obteniendo los datos de la comisión de apertura y gastos de estudio
        while ((i < size) && ((!comisionAperturaEncontrada) || (!comisionGastosEstudioEncontrada))) {
            ComisionC comision = comisiones.get(i);
            if (comision.getComisionesKey().getStrTipoComision().equals(Constantes.TIPO_COMISION_APERTURA)) {
                if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_UNO_INT)) {
                    porcentajeApertura = comision.getBidPorcentajeComision();
                    formaPagoApertura = comision.getBidIndCapitalizacionComDisponibilidad();
                    comisionAperturaEncontrada = true;
                }
            } else if (comision.getComisionesKey().getStrTipoComision().equals(Constantes.TIPO_COMISION_ESTUDIO)) {
                if (0 == comision.getComisionesKey().getIntOrden().compareTo(CTE_UNO_INT)) {
                    porcentajeGastosEstudio = comision.getBidPorcentajeComision();
                    formaPagoGastosEstudio = comision.getBidIndCapitalizacionComDisponibilidad();
                    comisionGastosEstudioEncontrada = true;
                }
            }
            i++;
        }
        // Se comprueba que la forma de pago de la comision de apertura no sea cargo en cuenta formalizacion
        if (comisionAperturaEncontrada && (porcentajeApertura.compareTo(BigDecimal.ZERO) > 0)) {
            if (formaPagoApertura.compareTo(BigDecimal.ZERO) == 0) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_PERMITIDO_CARGO_CUENTA_FORMALIZACION, null, new String[] { new Mensaje(ServicioNegocio.getContexto(), COMISI_N_APERTURA_1008812563).toString() }, null);
            }
        }
        // Se comprueba que la forma de pago de gastos de estudio no sea cargo en cuenta formalizacion
        if (comisionGastosEstudioEncontrada && (porcentajeGastosEstudio.compareTo(BigDecimal.ZERO) > 0)) {
            if (formaPagoGastosEstudio.compareTo(BigDecimal.ZERO) == 0) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_PERMITIDO_CARGO_CUENTA_FORMALIZACION, null, new String[] { new Mensaje(ServicioNegocio.getContexto(), GASTOS_ESTUDIO_1488416570).toString() }, null);
            }
        }
        // Si tiene las dos comisiones, se comprueba que la forma de pago sea la misma en los dos casos
        if (comisionAperturaEncontrada && comisionGastosEstudioEncontrada) {
            if ((porcentajeApertura.compareTo(BigDecimal.ZERO) > 0) && (porcentajeGastosEstudio.compareTo(BigDecimal.ZERO) > 0)) {
                if (formaPagoApertura.compareTo(formaPagoGastosEstudio) != 0) {
                    ServicioNegocio.rollback(CodigosError.CTE_ERROR_COMISIONES_MISMA_FORMA_PAGO, null, new String[] {}, null);
                }
            }
        }
    }

    /**
     * Comprueba si es preconcedido o refinanciación, que no tenga prescriptor y que
     * no tenga comision al comercio
     * Si es concesionario o consumo sin ser refinanciación, que tenga prescriptor
     * @param datosSolicitud
     */
    public static void comprobarPrescriptoresASF(DatosSolicitudC datosSolicitud) {
        BigDecimal tipoExpediente = datosSolicitud.getTipoExpediente();
        BigDecimal prescriptor = datosSolicitud.getTipoPrescriptor();
        // Obtenemos el destino
        List<DestinosC> lstDestinos = datosSolicitud.getDestinos();
        int size = lstDestinos.size();
        String destino = ConstantesComun.CTE_STR_EMPTY;
        int i = 0;
        while (i < size) {
            DestinosC destinoC = lstDestinos.get(i);
            if (destinoC.getEsPrincipal().compareTo(ConstantesComun.CTE_STR_S) == 0) {
                destino = destinoC.getDestino();
                i = size;
            } else {
                i++;
            }
        }
        // Si tiene prescriptor, damos error
        if (UtilidadesComun.esPreconcedidoASF(tipoExpediente) || UtilidadesComun.esRefinanciancionASF(tipoExpediente, destino)) {
            // Obtenemos la comision al comercio, porque estos expedientes no pueden tener
            List<ComisionC> lstComisiones = datosSolicitud.getComisiones();
            int tamanho = lstComisiones.size();
            int j = 0;
            boolean comisionComercioEncontrada = false;
            BigDecimal porcentajeComercio = BigDecimal.ZERO;
            // Se recorren las comisiones, para obtener la comision al comercio
            while ((j < tamanho) && (!comisionComercioEncontrada)) {
                ComisionC comision = lstComisiones.get(j);
                if (comision.getComisionesKey().getStrTipoComision().equals(Constantes.TIPO_COMISION_AL_COMERCIO)) {
                    comisionComercioEncontrada = true;
                    porcentajeComercio = comision.getBidPorcentajeComision();
                }
                j++;
            }
            if (comisionComercioEncontrada && (porcentajeComercio.compareTo(BigDecimal.ZERO) > 0)) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_NO_COMISION_COMERCIO, null, new String[] {}, null);
            }
            if (prescriptor.compareTo(ConstantesComun.PRESCRIPTOR_EXTERNO) == 0) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_SIN_PRESCRIPTOR_ASF, null, new String[] {}, null);
            }
        } else // Si no tiene damos error
        if (UtilidadesComun.esConcesionarioASF(tipoExpediente) || UtilidadesComun.esConsumoASFsinRefinaciacion(tipoExpediente, destino)) {
            if (prescriptor.compareTo(ConstantesComun.SIN_PRESCRIPTOR) == 0) {
                ServicioNegocio.rollback(CodigosError.CTE_ERROR_CON_PRESCRIPTOR_ASF, null, new String[] {}, null);
            }
        }
    }

    /**
     * Comprueba que si el alguno de los periodos minimos de liquidacion de las condiciones de interés,
     * es 2, que todos los periodos minimos de liquidación, tanto de interés como de capital, deben de
     * ser igual a 2.
     * @param datosSolicitud
     */
    public static void comprobarPeriodoLiquidacion(DatosSolicitudC datosSolicitud) {
        // Recuperamos las condiciones de interes
        List<CondicionesInteresC> lstCondicionesInteres = GestionCondicionesInteres.buscarCondicionesInteres(datosSolicitud.getDatosSolicitudKey().getOficinaSolicitud().intValue(), datosSolicitud.getDatosSolicitudKey().getVersionSolicitud().intValue(), datosSolicitud.getDatosSolicitudKey().getNucExpediente().intValue());
        int condicionesInteresDos = 0;
        if ((null != lstCondicionesInteres) && (0 < lstCondicionesInteres.size())) {
            // Recorro las condiciones de interes, contando las que el periodo minimo de liquidacion es 2
            for (CondicionesInteresC condicionInteres : lstCondicionesInteres) {
                if (condicionInteres.getIntIndPeriodoMinimoLiquidacion().compareTo(Constantes.CTE_DOS) == 0) {
                    condicionesInteresDos++;
                }
            }
            // Si alguna condiciones de interes es 2, entonces todas deben de ser dos(tanto interes como capital)
            if (condicionesInteresDos > 0) {
                // Si no coincide el total de condiciones de interes, con el total de condiciones que son 2, damos error
                if (lstCondicionesInteres.size() != condicionesInteresDos) {
                    ServicioNegocio.rollback(// Codigo error
                    CodigosError.CTE_ERROR_PERIODO_MINIMO_LIQUIDACION_DOS, // Titulo
                    null, // Descripcion
                    new String[] {}, // Solucion
                    null);
                } else // Si coincide lo anterior, comprobamos que todas las condiciones de capital sean 2
                {
                    List<CondicionCapitalC> condicionesCapital = datosSolicitud.getCondicionesCapital();
                    if ((null != condicionesCapital) && (0 < condicionesCapital.size())) {
                        for (CondicionCapitalC condicionCapital : condicionesCapital) {
                            if (!condicionCapital.getIntIndPeriodoMinimoLiquidacion().equals(Constantes.CTE_DOS)) {
                                ServicioNegocio.rollback(// Codigo error
                                CodigosError.CTE_ERROR_PERIODO_MINIMO_LIQUIDACION_DOS, // Titulo
                                null, // Descripcion
                                new String[] {}, // Solucion
                                null);
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Comprueba que si robo de hipoteca esta marcado, solo puede ir por el subproducto dos
     * Esta comprobacion solo se utiliza para las maricarmen 5804 y 5806
     * @param datosSolicitud
     */
    public static void roboHipotecaPorSubproductoDos(DatosSolicitudC datosSolicitud) {
        if (0 == datosSolicitud.getProducto().compareTo(CTE_HIPOTECA_MC_FIJA) || 0 == datosSolicitud.getProducto().compareTo(CTE_HIPOTECA_MC_VARIABLE)) {
            if (0 == datosSolicitud.getSubrogacionOtraEntidad().compareTo(BigDecimal.ONE)) {
                if (0 != datosSolicitud.getSubproducto().compareTo(CTE_SUBPRODUCTO_ROBO)) {
                    ServicioNegocio.rollback(CTE_ERROR_ROBO_HIPOTECA, null, new String[] {}, null);
                }
            }
        }
    }

    private static final String GASTOS_ESTUDIO_1488416570 = "GASTOS_ESTUDIO_1488416570";

    private static final String COMISI_N_APERTURA_1008812563 = "COMISI_N_APERTURA_1008812563";

    private static final String COMPENSACI_N_DESISTIMIENTO_TOTAL_1963893436 = "COMPENSACI_N_DESISTIMIENTO_TOTAL_1963893436";

    private static final String COMISI_N_CANCELACI_N_ANTICIPADA_1623534475 = "COMISI_N_CANCELACI_N_ANTICIPADA_1623534475";

    private static final String Y_121 = "Y_121";

    private static final String COMPENSACI_N_DESISTIMIENTO_PARCIAL_2141661014 = "COMPENSACI_N_DESISTIMIENTO_PARCIAL_2141661014";

    private static final String COMISI_N_CANCELACI_N_PARCIAL_ANTICIPADA_900490461 = "COMISI_N_CANCELACI_N_PARCIAL_ANTICIPADA_900490461";
}
